// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: risenlighten/lasvsim/simulation_task_kratos/api/simulation/v2/simulation.proto
#ifndef GRPC_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto__INCLUDED
#define GRPC_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto__INCLUDED

#include "risenlighten/lasvsim/simulation_task_kratos/api/simulation/v2/simulation.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace risenlighten {
namespace lasvsim {
namespace simulation_task_kratos {
namespace api {
namespace simulation {
namespace v2 {

//
// 联合仿真服务
// 以下是错误码定义:
// StartErrorCode    = -100
// TaskNotExistCode  = -200
// StopErrorCode     = -300
// MapErrorCode      = -400
// NextStepErrorCode = -500
// VehicleErrorCode  = -600
// ErrorCode         = -800
//
// 仿真状态码:
// 0    : 待开始
// 1-99 : 运行中
// 100  : 已完成
// -1   : 运行错误
// -100 : 任务非正常终止
class SimulationV2 final {
 public:
  static constexpr char const* service_full_name() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationV2";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 开始任务, 任务初始化
    virtual ::grpc::Status Start(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>> AsyncStart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>>(AsyncStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>> PrepareAsyncStart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>>(PrepareAsyncStartRaw(context, request, cq));
    }
    // 执行仿真步骤
    virtual ::grpc::Status NextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>> AsyncNextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>>(AsyncNextStepRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>> PrepareAsyncNextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>>(PrepareAsyncNextStepRaw(context, request, cq));
    }
    // 重置仿真
    virtual ::grpc::Status ResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>> AsyncResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>>(AsyncResetSimulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>> PrepareAsyncResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>>(PrepareAsyncResetSimulationRaw(context, request, cq));
    }
    // 强制结束仿真
    virtual ::grpc::Status Stop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>> AsyncStop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>> PrepareAsyncStop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>>(PrepareAsyncStopRaw(context, request, cq));
    }
    // 获取全量地图
    virtual ::grpc::Status GetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>> AsyncGetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>>(AsyncGetMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>> PrepareAsyncGetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>>(PrepareAsyncGetMapRaw(context, request, cq));
    }
    // 获取全量交通流信息(车辆)
    virtual ::grpc::Status GetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>> AsyncGetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>>(AsyncGetAllTrafficPartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>> PrepareAsyncGetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>>(PrepareAsyncGetAllTrafficPartRaw(context, request, cq));
    }
    // 修改车辆状态, lon_acc:纵向加速度, ste_wheel: 方向盘转速
    virtual ::grpc::Status SetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>> AsyncSetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>>(AsyncSetVehicleControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>> PrepareAsyncSetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>>(PrepareAsyncSetVehicleControlRaw(context, request, cq));
    }
    // 根据id获取自测车辆信息
    virtual ::grpc::Status GetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>> AsyncGetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>>(AsyncGetVehicleEgoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>> PrepareAsyncGetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>>(PrepareAsyncGetVehicleEgoRaw(context, request, cq));
    }
    // 获取仿真结果数据 map<string, [][]float64> 多层嵌套结构
    virtual ::grpc::Status GetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>> AsyncGetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>>(AsyncGetResultsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>> PrepareAsyncGetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>>(PrepareAsyncGetResultsRaw(context, request, cq));
    }
    // 根据LinkID获取link信息
    virtual ::grpc::Status GetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>> AsyncGetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>>(AsyncGetLinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>> PrepareAsyncGetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>>(PrepareAsyncGetLinkRaw(context, request, cq));
    }
    // 根据LaneID获取lane信息
    virtual ::grpc::Status GetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>> AsyncGetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>>(AsyncGetLaneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>> PrepareAsyncGetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>>(PrepareAsyncGetLaneRaw(context, request, cq));
    }
    // 根据junctionID获取junction信息
    virtual ::grpc::Status GetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>> AsyncGetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>>(AsyncGetJunctionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>> PrepareAsyncGetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>>(PrepareAsyncGetJunctionRaw(context, request, cq));
    }
    // 根据segmentID获取segment信息
    virtual ::grpc::Status GetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>> AsyncGetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>>(AsyncGetSegmentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>> PrepareAsyncGetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>>(PrepareAsyncGetSegmentRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // 开始任务, 任务初始化
      virtual void Start(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Start(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 执行仿真步骤
      virtual void NextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 重置仿真
      virtual void ResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 强制结束仿真
      virtual void Stop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取全量地图
      virtual void GetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取全量交通流信息(车辆)
      virtual void GetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 修改车辆状态, lon_acc:纵向加速度, ste_wheel: 方向盘转速
      virtual void SetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 根据id获取自测车辆信息
      virtual void GetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取仿真结果数据 map<string, [][]float64> 多层嵌套结构
      virtual void GetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 根据LinkID获取link信息
      virtual void GetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 根据LaneID获取lane信息
      virtual void GetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 根据junctionID获取junction信息
      virtual void GetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 根据segmentID获取segment信息
      virtual void GetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>* AsyncStartRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>* PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>* AsyncNextStepRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>* PrepareAsyncNextStepRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>* AsyncResetSimulationRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>* PrepareAsyncResetSimulationRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>* AsyncStopRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>* AsyncGetMapRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>* PrepareAsyncGetMapRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>* AsyncGetAllTrafficPartRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>* PrepareAsyncGetAllTrafficPartRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>* AsyncSetVehicleControlRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>* PrepareAsyncSetVehicleControlRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>* AsyncGetVehicleEgoRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>* PrepareAsyncGetVehicleEgoRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>* AsyncGetResultsRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>* PrepareAsyncGetResultsRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>* AsyncGetLinkRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>* PrepareAsyncGetLinkRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>* AsyncGetLaneRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>* PrepareAsyncGetLaneRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>* AsyncGetJunctionRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>* PrepareAsyncGetJunctionRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>* AsyncGetSegmentRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>* PrepareAsyncGetSegmentRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Start(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>> AsyncStart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>>(AsyncStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>> PrepareAsyncStart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>>(PrepareAsyncStartRaw(context, request, cq));
    }
    ::grpc::Status NextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>> AsyncNextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>>(AsyncNextStepRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>> PrepareAsyncNextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>>(PrepareAsyncNextStepRaw(context, request, cq));
    }
    ::grpc::Status ResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>> AsyncResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>>(AsyncResetSimulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>> PrepareAsyncResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>>(PrepareAsyncResetSimulationRaw(context, request, cq));
    }
    ::grpc::Status Stop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>> AsyncStop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>> PrepareAsyncStop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>>(PrepareAsyncStopRaw(context, request, cq));
    }
    ::grpc::Status GetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>> AsyncGetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>>(AsyncGetMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>> PrepareAsyncGetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>>(PrepareAsyncGetMapRaw(context, request, cq));
    }
    ::grpc::Status GetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>> AsyncGetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>>(AsyncGetAllTrafficPartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>> PrepareAsyncGetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>>(PrepareAsyncGetAllTrafficPartRaw(context, request, cq));
    }
    ::grpc::Status SetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>> AsyncSetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>>(AsyncSetVehicleControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>> PrepareAsyncSetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>>(PrepareAsyncSetVehicleControlRaw(context, request, cq));
    }
    ::grpc::Status GetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>> AsyncGetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>>(AsyncGetVehicleEgoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>> PrepareAsyncGetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>>(PrepareAsyncGetVehicleEgoRaw(context, request, cq));
    }
    ::grpc::Status GetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>> AsyncGetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>>(AsyncGetResultsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>> PrepareAsyncGetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>>(PrepareAsyncGetResultsRaw(context, request, cq));
    }
    ::grpc::Status GetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>> AsyncGetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>>(AsyncGetLinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>> PrepareAsyncGetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>>(PrepareAsyncGetLinkRaw(context, request, cq));
    }
    ::grpc::Status GetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>> AsyncGetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>>(AsyncGetLaneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>> PrepareAsyncGetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>>(PrepareAsyncGetLaneRaw(context, request, cq));
    }
    ::grpc::Status GetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>> AsyncGetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>>(AsyncGetJunctionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>> PrepareAsyncGetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>>(PrepareAsyncGetJunctionRaw(context, request, cq));
    }
    ::grpc::Status GetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>> AsyncGetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>>(AsyncGetSegmentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>> PrepareAsyncGetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>>(PrepareAsyncGetSegmentRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Start(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* response, std::function<void(::grpc::Status)>) override;
      void Start(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void NextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* response, std::function<void(::grpc::Status)>) override;
      void NextStep(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* response, std::function<void(::grpc::Status)>) override;
      void ResetSimulation(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Stop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* response, std::function<void(::grpc::Status)>) override;
      void Stop(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* response, std::function<void(::grpc::Status)>) override;
      void GetMap(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* response, std::function<void(::grpc::Status)>) override;
      void GetAllTrafficPart(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* response, std::function<void(::grpc::Status)>) override;
      void SetVehicleControl(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* response, std::function<void(::grpc::Status)>) override;
      void GetVehicleEgo(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* response, std::function<void(::grpc::Status)>) override;
      void GetResults(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* response, std::function<void(::grpc::Status)>) override;
      void GetLink(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* response, std::function<void(::grpc::Status)>) override;
      void GetLane(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* response, std::function<void(::grpc::Status)>) override;
      void GetJunction(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* response, std::function<void(::grpc::Status)>) override;
      void GetSegment(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>* AsyncStartRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>* PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>* AsyncNextStepRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>* PrepareAsyncNextStepRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>* AsyncResetSimulationRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>* PrepareAsyncResetSimulationRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>* AsyncStopRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>* AsyncGetMapRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>* PrepareAsyncGetMapRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>* AsyncGetAllTrafficPartRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>* PrepareAsyncGetAllTrafficPartRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>* AsyncSetVehicleControlRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>* PrepareAsyncSetVehicleControlRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>* AsyncGetVehicleEgoRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>* PrepareAsyncGetVehicleEgoRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>* AsyncGetResultsRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>* PrepareAsyncGetResultsRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>* AsyncGetLinkRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>* PrepareAsyncGetLinkRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>* AsyncGetLaneRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>* PrepareAsyncGetLaneRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>* AsyncGetJunctionRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>* PrepareAsyncGetJunctionRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>* AsyncGetSegmentRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>* PrepareAsyncGetSegmentRaw(::grpc::ClientContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Start_;
    const ::grpc::internal::RpcMethod rpcmethod_NextStep_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetSimulation_;
    const ::grpc::internal::RpcMethod rpcmethod_Stop_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMap_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAllTrafficPart_;
    const ::grpc::internal::RpcMethod rpcmethod_SetVehicleControl_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVehicleEgo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetResults_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLink_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLane_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJunction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSegment_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 开始任务, 任务初始化
    virtual ::grpc::Status Start(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* response);
    // 执行仿真步骤
    virtual ::grpc::Status NextStep(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* response);
    // 重置仿真
    virtual ::grpc::Status ResetSimulation(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* response);
    // 强制结束仿真
    virtual ::grpc::Status Stop(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* response);
    // 获取全量地图
    virtual ::grpc::Status GetMap(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* response);
    // 获取全量交通流信息(车辆)
    virtual ::grpc::Status GetAllTrafficPart(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* response);
    // 修改车辆状态, lon_acc:纵向加速度, ste_wheel: 方向盘转速
    virtual ::grpc::Status SetVehicleControl(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* response);
    // 根据id获取自测车辆信息
    virtual ::grpc::Status GetVehicleEgo(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* response);
    // 获取仿真结果数据 map<string, [][]float64> 多层嵌套结构
    virtual ::grpc::Status GetResults(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* response);
    // 根据LinkID获取link信息
    virtual ::grpc::Status GetLink(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* response);
    // 根据LaneID获取lane信息
    virtual ::grpc::Status GetLane(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* response);
    // 根据junctionID获取junction信息
    virtual ::grpc::Status GetJunction(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* response);
    // 根据segmentID获取segment信息
    virtual ::grpc::Status GetSegment(::grpc::ServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Start() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStart(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NextStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NextStep() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_NextStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NextStep(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNextStep(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetSimulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetSimulation() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ResetSimulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSimulation(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetSimulation(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Stop() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMap() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMap(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAllTrafficPart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAllTrafficPart() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetAllTrafficPart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllTrafficPart(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllTrafficPart(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetVehicleControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetVehicleControl() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SetVehicleControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVehicleControl(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVehicleControl(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVehicleEgo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVehicleEgo() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetVehicleEgo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVehicleEgo(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVehicleEgo(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetResults() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResults(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetResults(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLink() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLink(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLane : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLane() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetLane() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLane(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLane(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJunction() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetJunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJunction(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJunction(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSegment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSegment() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetSegment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSegment(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSegment(::grpc::ServerContext* context, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* request, ::grpc::ServerAsyncResponseWriter< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Start<WithAsyncMethod_NextStep<WithAsyncMethod_ResetSimulation<WithAsyncMethod_Stop<WithAsyncMethod_GetMap<WithAsyncMethod_GetAllTrafficPart<WithAsyncMethod_SetVehicleControl<WithAsyncMethod_GetVehicleEgo<WithAsyncMethod_GetResults<WithAsyncMethod_GetLink<WithAsyncMethod_GetLane<WithAsyncMethod_GetJunction<WithAsyncMethod_GetSegment<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Start() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* response) { return this->Start(context, request, response); }));}
    void SetMessageAllocatorFor_Start(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Start(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_NextStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_NextStep() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* response) { return this->NextStep(context, request, response); }));}
    void SetMessageAllocatorFor_NextStep(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_NextStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NextStep(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NextStep(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResetSimulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetSimulation() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* response) { return this->ResetSimulation(context, request, response); }));}
    void SetMessageAllocatorFor_ResetSimulation(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetSimulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSimulation(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetSimulation(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Stop() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* response) { return this->Stop(context, request, response); }));}
    void SetMessageAllocatorFor_Stop(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Stop(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetMap() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* response) { return this->GetMap(context, request, response); }));}
    void SetMessageAllocatorFor_GetMap(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMap(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAllTrafficPart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAllTrafficPart() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* response) { return this->GetAllTrafficPart(context, request, response); }));}
    void SetMessageAllocatorFor_GetAllTrafficPart(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAllTrafficPart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllTrafficPart(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAllTrafficPart(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetVehicleControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetVehicleControl() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* response) { return this->SetVehicleControl(context, request, response); }));}
    void SetMessageAllocatorFor_SetVehicleControl(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetVehicleControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVehicleControl(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVehicleControl(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVehicleEgo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVehicleEgo() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* response) { return this->GetVehicleEgo(context, request, response); }));}
    void SetMessageAllocatorFor_GetVehicleEgo(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVehicleEgo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVehicleEgo(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVehicleEgo(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetResults() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* response) { return this->GetResults(context, request, response); }));}
    void SetMessageAllocatorFor_GetResults(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResults(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetResults(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLink() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* response) { return this->GetLink(context, request, response); }));}
    void SetMessageAllocatorFor_GetLink(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLink(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLane : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLane() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* response) { return this->GetLane(context, request, response); }));}
    void SetMessageAllocatorFor_GetLane(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLane() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLane(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLane(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJunction() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* response) { return this->GetJunction(context, request, response); }));}
    void SetMessageAllocatorFor_GetJunction(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJunction(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJunction(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSegment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSegment() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* request, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* response) { return this->GetSegment(context, request, response); }));}
    void SetMessageAllocatorFor_GetSegment(
        ::grpc::MessageAllocator< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSegment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSegment(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSegment(
      ::grpc::CallbackServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Start<WithCallbackMethod_NextStep<WithCallbackMethod_ResetSimulation<WithCallbackMethod_Stop<WithCallbackMethod_GetMap<WithCallbackMethod_GetAllTrafficPart<WithCallbackMethod_SetVehicleControl<WithCallbackMethod_GetVehicleEgo<WithCallbackMethod_GetResults<WithCallbackMethod_GetLink<WithCallbackMethod_GetLane<WithCallbackMethod_GetJunction<WithCallbackMethod_GetSegment<Service > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Start() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NextStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NextStep() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_NextStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NextStep(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetSimulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetSimulation() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ResetSimulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSimulation(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Stop() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMap() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAllTrafficPart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAllTrafficPart() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetAllTrafficPart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllTrafficPart(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetVehicleControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetVehicleControl() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SetVehicleControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVehicleControl(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVehicleEgo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVehicleEgo() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetVehicleEgo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVehicleEgo(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetResults() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResults(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLink() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLane : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLane() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetLane() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLane(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJunction() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetJunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJunction(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSegment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSegment() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetSegment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSegment(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Start() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NextStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NextStep() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_NextStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NextStep(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNextStep(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetSimulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetSimulation() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ResetSimulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSimulation(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetSimulation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Stop() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMap() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAllTrafficPart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAllTrafficPart() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetAllTrafficPart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllTrafficPart(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllTrafficPart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetVehicleControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetVehicleControl() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SetVehicleControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVehicleControl(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVehicleControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVehicleEgo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVehicleEgo() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetVehicleEgo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVehicleEgo(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVehicleEgo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetResults() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResults(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetResults(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLink() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLink(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLane : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLane() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetLane() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLane(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLane(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJunction() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetJunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJunction(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJunction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSegment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSegment() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetSegment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSegment(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSegment(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Start() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Start(context, request, response); }));
    }
    ~WithRawCallbackMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Start(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_NextStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_NextStep() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NextStep(context, request, response); }));
    }
    ~WithRawCallbackMethod_NextStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NextStep(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NextStep(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetSimulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetSimulation() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetSimulation(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetSimulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetSimulation(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetSimulation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Stop() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Stop(context, request, response); }));
    }
    ~WithRawCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Stop(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetMap() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMap(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAllTrafficPart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAllTrafficPart() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAllTrafficPart(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAllTrafficPart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllTrafficPart(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAllTrafficPart(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetVehicleControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetVehicleControl() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetVehicleControl(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetVehicleControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVehicleControl(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVehicleControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVehicleEgo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVehicleEgo() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVehicleEgo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVehicleEgo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVehicleEgo(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVehicleEgo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetResults() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetResults(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetResults(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetResults(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLink() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLink(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLink(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLane : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLane() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLane(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLane() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLane(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLane(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJunction() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJunction(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJunction(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJunction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSegment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSegment() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSegment(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSegment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSegment(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSegment(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Start() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>* streamer) {
                       return this->StreamedStart(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NextStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NextStep() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>* streamer) {
                       return this->StreamedNextStep(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NextStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NextStep(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNextStep(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetSimulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetSimulation() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>* streamer) {
                       return this->StreamedResetSimulation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetSimulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetSimulation(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetSimulation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Stop() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>* streamer) {
                       return this->StreamedStop(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMap() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>* streamer) {
                       return this->StreamedGetMap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAllTrafficPart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAllTrafficPart() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>* streamer) {
                       return this->StreamedGetAllTrafficPart(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAllTrafficPart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAllTrafficPart(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAllTrafficPart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetVehicleControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetVehicleControl() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>* streamer) {
                       return this->StreamedSetVehicleControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetVehicleControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetVehicleControl(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetVehicleControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVehicleEgo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVehicleEgo() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>* streamer) {
                       return this->StreamedGetVehicleEgo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVehicleEgo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVehicleEgo(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVehicleEgo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleEgoRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetResults : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetResults() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>* streamer) {
                       return this->StreamedGetResults(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetResults() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetResults(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetResults(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLink() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>* streamer) {
                       return this->StreamedGetLink(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLink(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLane : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLane() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>* streamer) {
                       return this->StreamedGetLane(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLane() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLane(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLane(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJunction() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>* streamer) {
                       return this->StreamedGetJunction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJunction(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJunction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSegment : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSegment() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>* streamer) {
                       return this->StreamedGetSegment(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSegment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSegment(::grpc::ServerContext* /*context*/, const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* /*request*/, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSegment(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq,::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Start<WithStreamedUnaryMethod_NextStep<WithStreamedUnaryMethod_ResetSimulation<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_GetMap<WithStreamedUnaryMethod_GetAllTrafficPart<WithStreamedUnaryMethod_SetVehicleControl<WithStreamedUnaryMethod_GetVehicleEgo<WithStreamedUnaryMethod_GetResults<WithStreamedUnaryMethod_GetLink<WithStreamedUnaryMethod_GetLane<WithStreamedUnaryMethod_GetJunction<WithStreamedUnaryMethod_GetSegment<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Start<WithStreamedUnaryMethod_NextStep<WithStreamedUnaryMethod_ResetSimulation<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_GetMap<WithStreamedUnaryMethod_GetAllTrafficPart<WithStreamedUnaryMethod_SetVehicleControl<WithStreamedUnaryMethod_GetVehicleEgo<WithStreamedUnaryMethod_GetResults<WithStreamedUnaryMethod_GetLink<WithStreamedUnaryMethod_GetLane<WithStreamedUnaryMethod_GetJunction<WithStreamedUnaryMethod_GetSegment<Service > > > > > > > > > > > > > StreamedService;
};

}  // namespace v2
}  // namespace simulation
}  // namespace api
}  // namespace simulation_task_kratos
}  // namespace lasvsim
}  // namespace risenlighten


#endif  // GRPC_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto__INCLUDED
