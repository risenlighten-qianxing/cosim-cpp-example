// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/api/serviceusage/v1/serviceusage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/serviceusage/v1/resources.pb.h"
#include "google/longrunning/operations.pb.h"
#include "google/api/client.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
namespace google {
namespace api {
namespace serviceusage {
namespace v1 {
class BatchEnableServicesRequest;
struct BatchEnableServicesRequestDefaultTypeInternal;
extern BatchEnableServicesRequestDefaultTypeInternal _BatchEnableServicesRequest_default_instance_;
class BatchEnableServicesResponse;
struct BatchEnableServicesResponseDefaultTypeInternal;
extern BatchEnableServicesResponseDefaultTypeInternal _BatchEnableServicesResponse_default_instance_;
class BatchEnableServicesResponse_EnableFailure;
struct BatchEnableServicesResponse_EnableFailureDefaultTypeInternal;
extern BatchEnableServicesResponse_EnableFailureDefaultTypeInternal _BatchEnableServicesResponse_EnableFailure_default_instance_;
class BatchGetServicesRequest;
struct BatchGetServicesRequestDefaultTypeInternal;
extern BatchGetServicesRequestDefaultTypeInternal _BatchGetServicesRequest_default_instance_;
class BatchGetServicesResponse;
struct BatchGetServicesResponseDefaultTypeInternal;
extern BatchGetServicesResponseDefaultTypeInternal _BatchGetServicesResponse_default_instance_;
class DisableServiceRequest;
struct DisableServiceRequestDefaultTypeInternal;
extern DisableServiceRequestDefaultTypeInternal _DisableServiceRequest_default_instance_;
class DisableServiceResponse;
struct DisableServiceResponseDefaultTypeInternal;
extern DisableServiceResponseDefaultTypeInternal _DisableServiceResponse_default_instance_;
class EnableServiceRequest;
struct EnableServiceRequestDefaultTypeInternal;
extern EnableServiceRequestDefaultTypeInternal _EnableServiceRequest_default_instance_;
class EnableServiceResponse;
struct EnableServiceResponseDefaultTypeInternal;
extern EnableServiceResponseDefaultTypeInternal _EnableServiceResponse_default_instance_;
class GetServiceRequest;
struct GetServiceRequestDefaultTypeInternal;
extern GetServiceRequestDefaultTypeInternal _GetServiceRequest_default_instance_;
class ListServicesRequest;
struct ListServicesRequestDefaultTypeInternal;
extern ListServicesRequestDefaultTypeInternal _ListServicesRequest_default_instance_;
class ListServicesResponse;
struct ListServicesResponseDefaultTypeInternal;
extern ListServicesResponseDefaultTypeInternal _ListServicesResponse_default_instance_;
}  // namespace v1
}  // namespace serviceusage
}  // namespace api
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::api::serviceusage::v1::BatchEnableServicesRequest* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::BatchEnableServicesRequest>(Arena*);
template<> ::google::api::serviceusage::v1::BatchEnableServicesResponse* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::BatchEnableServicesResponse>(Arena*);
template<> ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure>(Arena*);
template<> ::google::api::serviceusage::v1::BatchGetServicesRequest* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::BatchGetServicesRequest>(Arena*);
template<> ::google::api::serviceusage::v1::BatchGetServicesResponse* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::BatchGetServicesResponse>(Arena*);
template<> ::google::api::serviceusage::v1::DisableServiceRequest* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::DisableServiceRequest>(Arena*);
template<> ::google::api::serviceusage::v1::DisableServiceResponse* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::DisableServiceResponse>(Arena*);
template<> ::google::api::serviceusage::v1::EnableServiceRequest* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::EnableServiceRequest>(Arena*);
template<> ::google::api::serviceusage::v1::EnableServiceResponse* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::EnableServiceResponse>(Arena*);
template<> ::google::api::serviceusage::v1::GetServiceRequest* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::GetServiceRequest>(Arena*);
template<> ::google::api::serviceusage::v1::ListServicesRequest* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::ListServicesRequest>(Arena*);
template<> ::google::api::serviceusage::v1::ListServicesResponse* Arena::CreateMaybeMessage<::google::api::serviceusage::v1::ListServicesResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace api {
namespace serviceusage {
namespace v1 {

enum DisableServiceRequest_CheckIfServiceHasUsage : int {
  DisableServiceRequest_CheckIfServiceHasUsage_CHECK_IF_SERVICE_HAS_USAGE_UNSPECIFIED = 0,
  DisableServiceRequest_CheckIfServiceHasUsage_SKIP = 1,
  DisableServiceRequest_CheckIfServiceHasUsage_CHECK = 2,
  DisableServiceRequest_CheckIfServiceHasUsage_DisableServiceRequest_CheckIfServiceHasUsage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DisableServiceRequest_CheckIfServiceHasUsage_DisableServiceRequest_CheckIfServiceHasUsage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DisableServiceRequest_CheckIfServiceHasUsage_IsValid(int value);
constexpr DisableServiceRequest_CheckIfServiceHasUsage DisableServiceRequest_CheckIfServiceHasUsage_CheckIfServiceHasUsage_MIN = DisableServiceRequest_CheckIfServiceHasUsage_CHECK_IF_SERVICE_HAS_USAGE_UNSPECIFIED;
constexpr DisableServiceRequest_CheckIfServiceHasUsage DisableServiceRequest_CheckIfServiceHasUsage_CheckIfServiceHasUsage_MAX = DisableServiceRequest_CheckIfServiceHasUsage_CHECK;
constexpr int DisableServiceRequest_CheckIfServiceHasUsage_CheckIfServiceHasUsage_ARRAYSIZE = DisableServiceRequest_CheckIfServiceHasUsage_CheckIfServiceHasUsage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DisableServiceRequest_CheckIfServiceHasUsage_descriptor();
template<typename T>
inline const std::string& DisableServiceRequest_CheckIfServiceHasUsage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DisableServiceRequest_CheckIfServiceHasUsage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DisableServiceRequest_CheckIfServiceHasUsage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DisableServiceRequest_CheckIfServiceHasUsage_descriptor(), enum_t_value);
}
inline bool DisableServiceRequest_CheckIfServiceHasUsage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DisableServiceRequest_CheckIfServiceHasUsage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DisableServiceRequest_CheckIfServiceHasUsage>(
    DisableServiceRequest_CheckIfServiceHasUsage_descriptor(), name, value);
}
// ===================================================================

class EnableServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.EnableServiceRequest) */ {
 public:
  inline EnableServiceRequest() : EnableServiceRequest(nullptr) {}
  ~EnableServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR EnableServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableServiceRequest(const EnableServiceRequest& from);
  EnableServiceRequest(EnableServiceRequest&& from) noexcept
    : EnableServiceRequest() {
    *this = ::std::move(from);
  }

  inline EnableServiceRequest& operator=(const EnableServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableServiceRequest& operator=(EnableServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableServiceRequest* internal_default_instance() {
    return reinterpret_cast<const EnableServiceRequest*>(
               &_EnableServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EnableServiceRequest& a, EnableServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnableServiceRequest& from) {
    EnableServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.EnableServiceRequest";
  }
  protected:
  explicit EnableServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.EnableServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class EnableServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.EnableServiceResponse) */ {
 public:
  inline EnableServiceResponse() : EnableServiceResponse(nullptr) {}
  ~EnableServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR EnableServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableServiceResponse(const EnableServiceResponse& from);
  EnableServiceResponse(EnableServiceResponse&& from) noexcept
    : EnableServiceResponse() {
    *this = ::std::move(from);
  }

  inline EnableServiceResponse& operator=(const EnableServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableServiceResponse& operator=(EnableServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableServiceResponse* internal_default_instance() {
    return reinterpret_cast<const EnableServiceResponse*>(
               &_EnableServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EnableServiceResponse& a, EnableServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnableServiceResponse& from) {
    EnableServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.EnableServiceResponse";
  }
  protected:
  explicit EnableServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
  };
  // .google.api.serviceusage.v1.Service service = 1;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::google::api::serviceusage::v1::Service& service() const;
  PROTOBUF_NODISCARD ::google::api::serviceusage::v1::Service* release_service();
  ::google::api::serviceusage::v1::Service* mutable_service();
  void set_allocated_service(::google::api::serviceusage::v1::Service* service);
  private:
  const ::google::api::serviceusage::v1::Service& _internal_service() const;
  ::google::api::serviceusage::v1::Service* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::google::api::serviceusage::v1::Service* service);
  ::google::api::serviceusage::v1::Service* unsafe_arena_release_service();

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.EnableServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::api::serviceusage::v1::Service* service_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class DisableServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.DisableServiceRequest) */ {
 public:
  inline DisableServiceRequest() : DisableServiceRequest(nullptr) {}
  ~DisableServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR DisableServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisableServiceRequest(const DisableServiceRequest& from);
  DisableServiceRequest(DisableServiceRequest&& from) noexcept
    : DisableServiceRequest() {
    *this = ::std::move(from);
  }

  inline DisableServiceRequest& operator=(const DisableServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableServiceRequest& operator=(DisableServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableServiceRequest* internal_default_instance() {
    return reinterpret_cast<const DisableServiceRequest*>(
               &_DisableServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DisableServiceRequest& a, DisableServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisableServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisableServiceRequest& from) {
    DisableServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisableServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.DisableServiceRequest";
  }
  protected:
  explicit DisableServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DisableServiceRequest_CheckIfServiceHasUsage CheckIfServiceHasUsage;
  static constexpr CheckIfServiceHasUsage CHECK_IF_SERVICE_HAS_USAGE_UNSPECIFIED =
    DisableServiceRequest_CheckIfServiceHasUsage_CHECK_IF_SERVICE_HAS_USAGE_UNSPECIFIED;
  static constexpr CheckIfServiceHasUsage SKIP =
    DisableServiceRequest_CheckIfServiceHasUsage_SKIP;
  static constexpr CheckIfServiceHasUsage CHECK =
    DisableServiceRequest_CheckIfServiceHasUsage_CHECK;
  static inline bool CheckIfServiceHasUsage_IsValid(int value) {
    return DisableServiceRequest_CheckIfServiceHasUsage_IsValid(value);
  }
  static constexpr CheckIfServiceHasUsage CheckIfServiceHasUsage_MIN =
    DisableServiceRequest_CheckIfServiceHasUsage_CheckIfServiceHasUsage_MIN;
  static constexpr CheckIfServiceHasUsage CheckIfServiceHasUsage_MAX =
    DisableServiceRequest_CheckIfServiceHasUsage_CheckIfServiceHasUsage_MAX;
  static constexpr int CheckIfServiceHasUsage_ARRAYSIZE =
    DisableServiceRequest_CheckIfServiceHasUsage_CheckIfServiceHasUsage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CheckIfServiceHasUsage_descriptor() {
    return DisableServiceRequest_CheckIfServiceHasUsage_descriptor();
  }
  template<typename T>
  static inline const std::string& CheckIfServiceHasUsage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CheckIfServiceHasUsage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CheckIfServiceHasUsage_Name.");
    return DisableServiceRequest_CheckIfServiceHasUsage_Name(enum_t_value);
  }
  static inline bool CheckIfServiceHasUsage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CheckIfServiceHasUsage* value) {
    return DisableServiceRequest_CheckIfServiceHasUsage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDisableDependentServicesFieldNumber = 2,
    kCheckIfServiceHasUsageFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool disable_dependent_services = 2;
  void clear_disable_dependent_services();
  bool disable_dependent_services() const;
  void set_disable_dependent_services(bool value);
  private:
  bool _internal_disable_dependent_services() const;
  void _internal_set_disable_dependent_services(bool value);
  public:

  // .google.api.serviceusage.v1.DisableServiceRequest.CheckIfServiceHasUsage check_if_service_has_usage = 3;
  void clear_check_if_service_has_usage();
  ::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage check_if_service_has_usage() const;
  void set_check_if_service_has_usage(::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage value);
  private:
  ::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage _internal_check_if_service_has_usage() const;
  void _internal_set_check_if_service_has_usage(::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.DisableServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool disable_dependent_services_;
    int check_if_service_has_usage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class DisableServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.DisableServiceResponse) */ {
 public:
  inline DisableServiceResponse() : DisableServiceResponse(nullptr) {}
  ~DisableServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR DisableServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisableServiceResponse(const DisableServiceResponse& from);
  DisableServiceResponse(DisableServiceResponse&& from) noexcept
    : DisableServiceResponse() {
    *this = ::std::move(from);
  }

  inline DisableServiceResponse& operator=(const DisableServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableServiceResponse& operator=(DisableServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableServiceResponse* internal_default_instance() {
    return reinterpret_cast<const DisableServiceResponse*>(
               &_DisableServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DisableServiceResponse& a, DisableServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisableServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisableServiceResponse& from) {
    DisableServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisableServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.DisableServiceResponse";
  }
  protected:
  explicit DisableServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
  };
  // .google.api.serviceusage.v1.Service service = 1;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::google::api::serviceusage::v1::Service& service() const;
  PROTOBUF_NODISCARD ::google::api::serviceusage::v1::Service* release_service();
  ::google::api::serviceusage::v1::Service* mutable_service();
  void set_allocated_service(::google::api::serviceusage::v1::Service* service);
  private:
  const ::google::api::serviceusage::v1::Service& _internal_service() const;
  ::google::api::serviceusage::v1::Service* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::google::api::serviceusage::v1::Service* service);
  ::google::api::serviceusage::v1::Service* unsafe_arena_release_service();

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.DisableServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::api::serviceusage::v1::Service* service_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class GetServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.GetServiceRequest) */ {
 public:
  inline GetServiceRequest() : GetServiceRequest(nullptr) {}
  ~GetServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR GetServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceRequest(const GetServiceRequest& from);
  GetServiceRequest(GetServiceRequest&& from) noexcept
    : GetServiceRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceRequest& operator=(const GetServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceRequest& operator=(GetServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceRequest*>(
               &_GetServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetServiceRequest& a, GetServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceRequest& from) {
    GetServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.GetServiceRequest";
  }
  protected:
  explicit GetServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.GetServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class ListServicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.ListServicesRequest) */ {
 public:
  inline ListServicesRequest() : ListServicesRequest(nullptr) {}
  ~ListServicesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListServicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServicesRequest(const ListServicesRequest& from);
  ListServicesRequest(ListServicesRequest&& from) noexcept
    : ListServicesRequest() {
    *this = ::std::move(from);
  }

  inline ListServicesRequest& operator=(const ListServicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServicesRequest& operator=(ListServicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListServicesRequest*>(
               &_ListServicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListServicesRequest& a, ListServicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServicesRequest& from) {
    ListServicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.ListServicesRequest";
  }
  protected:
  explicit ListServicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kFilterFieldNumber = 4,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1;
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // string filter = 4;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.ListServicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class ListServicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.ListServicesResponse) */ {
 public:
  inline ListServicesResponse() : ListServicesResponse(nullptr) {}
  ~ListServicesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListServicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServicesResponse(const ListServicesResponse& from);
  ListServicesResponse(ListServicesResponse&& from) noexcept
    : ListServicesResponse() {
    *this = ::std::move(from);
  }

  inline ListServicesResponse& operator=(const ListServicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServicesResponse& operator=(ListServicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListServicesResponse*>(
               &_ListServicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListServicesResponse& a, ListServicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServicesResponse& from) {
    ListServicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.ListServicesResponse";
  }
  protected:
  explicit ListServicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.api.serviceusage.v1.Service services = 1;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::google::api::serviceusage::v1::Service* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >*
      mutable_services();
  private:
  const ::google::api::serviceusage::v1::Service& _internal_services(int index) const;
  ::google::api::serviceusage::v1::Service* _internal_add_services();
  public:
  const ::google::api::serviceusage::v1::Service& services(int index) const;
  ::google::api::serviceusage::v1::Service* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >&
      services() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.ListServicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service > services_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class BatchEnableServicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.BatchEnableServicesRequest) */ {
 public:
  inline BatchEnableServicesRequest() : BatchEnableServicesRequest(nullptr) {}
  ~BatchEnableServicesRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchEnableServicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchEnableServicesRequest(const BatchEnableServicesRequest& from);
  BatchEnableServicesRequest(BatchEnableServicesRequest&& from) noexcept
    : BatchEnableServicesRequest() {
    *this = ::std::move(from);
  }

  inline BatchEnableServicesRequest& operator=(const BatchEnableServicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchEnableServicesRequest& operator=(BatchEnableServicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchEnableServicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchEnableServicesRequest* internal_default_instance() {
    return reinterpret_cast<const BatchEnableServicesRequest*>(
               &_BatchEnableServicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BatchEnableServicesRequest& a, BatchEnableServicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchEnableServicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchEnableServicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchEnableServicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchEnableServicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchEnableServicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchEnableServicesRequest& from) {
    BatchEnableServicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchEnableServicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.BatchEnableServicesRequest";
  }
  protected:
  explicit BatchEnableServicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceIdsFieldNumber = 2,
    kParentFieldNumber = 1,
  };
  // repeated string service_ids = 2;
  int service_ids_size() const;
  private:
  int _internal_service_ids_size() const;
  public:
  void clear_service_ids();
  const std::string& service_ids(int index) const;
  std::string* mutable_service_ids(int index);
  void set_service_ids(int index, const std::string& value);
  void set_service_ids(int index, std::string&& value);
  void set_service_ids(int index, const char* value);
  void set_service_ids(int index, const char* value, size_t size);
  std::string* add_service_ids();
  void add_service_ids(const std::string& value);
  void add_service_ids(std::string&& value);
  void add_service_ids(const char* value);
  void add_service_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& service_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_service_ids();
  private:
  const std::string& _internal_service_ids(int index) const;
  std::string* _internal_add_service_ids();
  public:

  // string parent = 1;
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.BatchEnableServicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> service_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class BatchEnableServicesResponse_EnableFailure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure) */ {
 public:
  inline BatchEnableServicesResponse_EnableFailure() : BatchEnableServicesResponse_EnableFailure(nullptr) {}
  ~BatchEnableServicesResponse_EnableFailure() override;
  explicit PROTOBUF_CONSTEXPR BatchEnableServicesResponse_EnableFailure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchEnableServicesResponse_EnableFailure(const BatchEnableServicesResponse_EnableFailure& from);
  BatchEnableServicesResponse_EnableFailure(BatchEnableServicesResponse_EnableFailure&& from) noexcept
    : BatchEnableServicesResponse_EnableFailure() {
    *this = ::std::move(from);
  }

  inline BatchEnableServicesResponse_EnableFailure& operator=(const BatchEnableServicesResponse_EnableFailure& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchEnableServicesResponse_EnableFailure& operator=(BatchEnableServicesResponse_EnableFailure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchEnableServicesResponse_EnableFailure& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchEnableServicesResponse_EnableFailure* internal_default_instance() {
    return reinterpret_cast<const BatchEnableServicesResponse_EnableFailure*>(
               &_BatchEnableServicesResponse_EnableFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BatchEnableServicesResponse_EnableFailure& a, BatchEnableServicesResponse_EnableFailure& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchEnableServicesResponse_EnableFailure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchEnableServicesResponse_EnableFailure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchEnableServicesResponse_EnableFailure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchEnableServicesResponse_EnableFailure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchEnableServicesResponse_EnableFailure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchEnableServicesResponse_EnableFailure& from) {
    BatchEnableServicesResponse_EnableFailure::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchEnableServicesResponse_EnableFailure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure";
  }
  protected:
  explicit BatchEnableServicesResponse_EnableFailure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceIdFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
  };
  // string service_id = 1;
  void clear_service_id();
  const std::string& service_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_id();
  PROTOBUF_NODISCARD std::string* release_service_id();
  void set_allocated_service_id(std::string* service_id);
  private:
  const std::string& _internal_service_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_id(const std::string& value);
  std::string* _internal_mutable_service_id();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class BatchEnableServicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.BatchEnableServicesResponse) */ {
 public:
  inline BatchEnableServicesResponse() : BatchEnableServicesResponse(nullptr) {}
  ~BatchEnableServicesResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchEnableServicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchEnableServicesResponse(const BatchEnableServicesResponse& from);
  BatchEnableServicesResponse(BatchEnableServicesResponse&& from) noexcept
    : BatchEnableServicesResponse() {
    *this = ::std::move(from);
  }

  inline BatchEnableServicesResponse& operator=(const BatchEnableServicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchEnableServicesResponse& operator=(BatchEnableServicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchEnableServicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchEnableServicesResponse* internal_default_instance() {
    return reinterpret_cast<const BatchEnableServicesResponse*>(
               &_BatchEnableServicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BatchEnableServicesResponse& a, BatchEnableServicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchEnableServicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchEnableServicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchEnableServicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchEnableServicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchEnableServicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchEnableServicesResponse& from) {
    BatchEnableServicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchEnableServicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.BatchEnableServicesResponse";
  }
  protected:
  explicit BatchEnableServicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatchEnableServicesResponse_EnableFailure EnableFailure;

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 1,
    kFailuresFieldNumber = 2,
  };
  // repeated .google.api.serviceusage.v1.Service services = 1;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::google::api::serviceusage::v1::Service* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >*
      mutable_services();
  private:
  const ::google::api::serviceusage::v1::Service& _internal_services(int index) const;
  ::google::api::serviceusage::v1::Service* _internal_add_services();
  public:
  const ::google::api::serviceusage::v1::Service& services(int index) const;
  ::google::api::serviceusage::v1::Service* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >&
      services() const;

  // repeated .google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure failures = 2;
  int failures_size() const;
  private:
  int _internal_failures_size() const;
  public:
  void clear_failures();
  ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure* mutable_failures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure >*
      mutable_failures();
  private:
  const ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure& _internal_failures(int index) const;
  ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure* _internal_add_failures();
  public:
  const ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure& failures(int index) const;
  ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure* add_failures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure >&
      failures() const;

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.BatchEnableServicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service > services_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure > failures_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class BatchGetServicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.BatchGetServicesRequest) */ {
 public:
  inline BatchGetServicesRequest() : BatchGetServicesRequest(nullptr) {}
  ~BatchGetServicesRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchGetServicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchGetServicesRequest(const BatchGetServicesRequest& from);
  BatchGetServicesRequest(BatchGetServicesRequest&& from) noexcept
    : BatchGetServicesRequest() {
    *this = ::std::move(from);
  }

  inline BatchGetServicesRequest& operator=(const BatchGetServicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchGetServicesRequest& operator=(BatchGetServicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchGetServicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchGetServicesRequest* internal_default_instance() {
    return reinterpret_cast<const BatchGetServicesRequest*>(
               &_BatchGetServicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BatchGetServicesRequest& a, BatchGetServicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchGetServicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchGetServicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchGetServicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchGetServicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchGetServicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchGetServicesRequest& from) {
    BatchGetServicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchGetServicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.BatchGetServicesRequest";
  }
  protected:
  explicit BatchGetServicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 2,
    kParentFieldNumber = 1,
  };
  // repeated string names = 2;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // string parent = 1;
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.BatchGetServicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// -------------------------------------------------------------------

class BatchGetServicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.serviceusage.v1.BatchGetServicesResponse) */ {
 public:
  inline BatchGetServicesResponse() : BatchGetServicesResponse(nullptr) {}
  ~BatchGetServicesResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchGetServicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchGetServicesResponse(const BatchGetServicesResponse& from);
  BatchGetServicesResponse(BatchGetServicesResponse&& from) noexcept
    : BatchGetServicesResponse() {
    *this = ::std::move(from);
  }

  inline BatchGetServicesResponse& operator=(const BatchGetServicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchGetServicesResponse& operator=(BatchGetServicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchGetServicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchGetServicesResponse* internal_default_instance() {
    return reinterpret_cast<const BatchGetServicesResponse*>(
               &_BatchGetServicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BatchGetServicesResponse& a, BatchGetServicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchGetServicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchGetServicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchGetServicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchGetServicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchGetServicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchGetServicesResponse& from) {
    BatchGetServicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchGetServicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.serviceusage.v1.BatchGetServicesResponse";
  }
  protected:
  explicit BatchGetServicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 1,
  };
  // repeated .google.api.serviceusage.v1.Service services = 1;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::google::api::serviceusage::v1::Service* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >*
      mutable_services();
  private:
  const ::google::api::serviceusage::v1::Service& _internal_services(int index) const;
  ::google::api::serviceusage::v1::Service* _internal_add_services();
  public:
  const ::google::api::serviceusage::v1::Service& services(int index) const;
  ::google::api::serviceusage::v1::Service* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >&
      services() const;

  // @@protoc_insertion_point(class_scope:google.api.serviceusage.v1.BatchGetServicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service > services_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EnableServiceRequest

// string name = 1;
inline void EnableServiceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EnableServiceRequest::name() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.EnableServiceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnableServiceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.EnableServiceRequest.name)
}
inline std::string* EnableServiceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.EnableServiceRequest.name)
  return _s;
}
inline const std::string& EnableServiceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EnableServiceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EnableServiceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EnableServiceRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.EnableServiceRequest.name)
  return _impl_.name_.Release();
}
inline void EnableServiceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.EnableServiceRequest.name)
}

// -------------------------------------------------------------------

// EnableServiceResponse

// .google.api.serviceusage.v1.Service service = 1;
inline bool EnableServiceResponse::_internal_has_service() const {
  return this != internal_default_instance() && _impl_.service_ != nullptr;
}
inline bool EnableServiceResponse::has_service() const {
  return _internal_has_service();
}
inline const ::google::api::serviceusage::v1::Service& EnableServiceResponse::_internal_service() const {
  const ::google::api::serviceusage::v1::Service* p = _impl_.service_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::api::serviceusage::v1::Service&>(
      ::google::api::serviceusage::v1::_Service_default_instance_);
}
inline const ::google::api::serviceusage::v1::Service& EnableServiceResponse::service() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.EnableServiceResponse.service)
  return _internal_service();
}
inline void EnableServiceResponse::unsafe_arena_set_allocated_service(
    ::google::api::serviceusage::v1::Service* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_);
  }
  _impl_.service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.serviceusage.v1.EnableServiceResponse.service)
}
inline ::google::api::serviceusage::v1::Service* EnableServiceResponse::release_service() {
  
  ::google::api::serviceusage::v1::Service* temp = _impl_.service_;
  _impl_.service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::api::serviceusage::v1::Service* EnableServiceResponse::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.EnableServiceResponse.service)
  
  ::google::api::serviceusage::v1::Service* temp = _impl_.service_;
  _impl_.service_ = nullptr;
  return temp;
}
inline ::google::api::serviceusage::v1::Service* EnableServiceResponse::_internal_mutable_service() {
  
  if (_impl_.service_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::api::serviceusage::v1::Service>(GetArenaForAllocation());
    _impl_.service_ = p;
  }
  return _impl_.service_;
}
inline ::google::api::serviceusage::v1::Service* EnableServiceResponse::mutable_service() {
  ::google::api::serviceusage::v1::Service* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.EnableServiceResponse.service)
  return _msg;
}
inline void EnableServiceResponse::set_allocated_service(::google::api::serviceusage::v1::Service* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_ = service;
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.EnableServiceResponse.service)
}

// -------------------------------------------------------------------

// DisableServiceRequest

// string name = 1;
inline void DisableServiceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DisableServiceRequest::name() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.DisableServiceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DisableServiceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.DisableServiceRequest.name)
}
inline std::string* DisableServiceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.DisableServiceRequest.name)
  return _s;
}
inline const std::string& DisableServiceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DisableServiceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DisableServiceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DisableServiceRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.DisableServiceRequest.name)
  return _impl_.name_.Release();
}
inline void DisableServiceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.DisableServiceRequest.name)
}

// bool disable_dependent_services = 2;
inline void DisableServiceRequest::clear_disable_dependent_services() {
  _impl_.disable_dependent_services_ = false;
}
inline bool DisableServiceRequest::_internal_disable_dependent_services() const {
  return _impl_.disable_dependent_services_;
}
inline bool DisableServiceRequest::disable_dependent_services() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.DisableServiceRequest.disable_dependent_services)
  return _internal_disable_dependent_services();
}
inline void DisableServiceRequest::_internal_set_disable_dependent_services(bool value) {
  
  _impl_.disable_dependent_services_ = value;
}
inline void DisableServiceRequest::set_disable_dependent_services(bool value) {
  _internal_set_disable_dependent_services(value);
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.DisableServiceRequest.disable_dependent_services)
}

// .google.api.serviceusage.v1.DisableServiceRequest.CheckIfServiceHasUsage check_if_service_has_usage = 3;
inline void DisableServiceRequest::clear_check_if_service_has_usage() {
  _impl_.check_if_service_has_usage_ = 0;
}
inline ::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage DisableServiceRequest::_internal_check_if_service_has_usage() const {
  return static_cast< ::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage >(_impl_.check_if_service_has_usage_);
}
inline ::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage DisableServiceRequest::check_if_service_has_usage() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.DisableServiceRequest.check_if_service_has_usage)
  return _internal_check_if_service_has_usage();
}
inline void DisableServiceRequest::_internal_set_check_if_service_has_usage(::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage value) {
  
  _impl_.check_if_service_has_usage_ = value;
}
inline void DisableServiceRequest::set_check_if_service_has_usage(::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage value) {
  _internal_set_check_if_service_has_usage(value);
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.DisableServiceRequest.check_if_service_has_usage)
}

// -------------------------------------------------------------------

// DisableServiceResponse

// .google.api.serviceusage.v1.Service service = 1;
inline bool DisableServiceResponse::_internal_has_service() const {
  return this != internal_default_instance() && _impl_.service_ != nullptr;
}
inline bool DisableServiceResponse::has_service() const {
  return _internal_has_service();
}
inline const ::google::api::serviceusage::v1::Service& DisableServiceResponse::_internal_service() const {
  const ::google::api::serviceusage::v1::Service* p = _impl_.service_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::api::serviceusage::v1::Service&>(
      ::google::api::serviceusage::v1::_Service_default_instance_);
}
inline const ::google::api::serviceusage::v1::Service& DisableServiceResponse::service() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.DisableServiceResponse.service)
  return _internal_service();
}
inline void DisableServiceResponse::unsafe_arena_set_allocated_service(
    ::google::api::serviceusage::v1::Service* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_);
  }
  _impl_.service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.serviceusage.v1.DisableServiceResponse.service)
}
inline ::google::api::serviceusage::v1::Service* DisableServiceResponse::release_service() {
  
  ::google::api::serviceusage::v1::Service* temp = _impl_.service_;
  _impl_.service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::api::serviceusage::v1::Service* DisableServiceResponse::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.DisableServiceResponse.service)
  
  ::google::api::serviceusage::v1::Service* temp = _impl_.service_;
  _impl_.service_ = nullptr;
  return temp;
}
inline ::google::api::serviceusage::v1::Service* DisableServiceResponse::_internal_mutable_service() {
  
  if (_impl_.service_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::api::serviceusage::v1::Service>(GetArenaForAllocation());
    _impl_.service_ = p;
  }
  return _impl_.service_;
}
inline ::google::api::serviceusage::v1::Service* DisableServiceResponse::mutable_service() {
  ::google::api::serviceusage::v1::Service* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.DisableServiceResponse.service)
  return _msg;
}
inline void DisableServiceResponse::set_allocated_service(::google::api::serviceusage::v1::Service* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_ = service;
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.DisableServiceResponse.service)
}

// -------------------------------------------------------------------

// GetServiceRequest

// string name = 1;
inline void GetServiceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetServiceRequest::name() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.GetServiceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.GetServiceRequest.name)
}
inline std::string* GetServiceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.GetServiceRequest.name)
  return _s;
}
inline const std::string& GetServiceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetServiceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.GetServiceRequest.name)
  return _impl_.name_.Release();
}
inline void GetServiceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.GetServiceRequest.name)
}

// -------------------------------------------------------------------

// ListServicesRequest

// string parent = 1;
inline void ListServicesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListServicesRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.ListServicesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServicesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.ListServicesRequest.parent)
}
inline std::string* ListServicesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.ListServicesRequest.parent)
  return _s;
}
inline const std::string& ListServicesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListServicesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServicesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServicesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.ListServicesRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListServicesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.ListServicesRequest.parent)
}

// int32 page_size = 2;
inline void ListServicesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListServicesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListServicesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.ListServicesRequest.page_size)
  return _internal_page_size();
}
inline void ListServicesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListServicesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.ListServicesRequest.page_size)
}

// string page_token = 3;
inline void ListServicesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListServicesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.ListServicesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServicesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.ListServicesRequest.page_token)
}
inline std::string* ListServicesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.ListServicesRequest.page_token)
  return _s;
}
inline const std::string& ListServicesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListServicesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServicesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServicesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.ListServicesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListServicesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.ListServicesRequest.page_token)
}

// string filter = 4;
inline void ListServicesRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& ListServicesRequest::filter() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.ListServicesRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServicesRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.ListServicesRequest.filter)
}
inline std::string* ListServicesRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.ListServicesRequest.filter)
  return _s;
}
inline const std::string& ListServicesRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void ListServicesRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServicesRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServicesRequest::release_filter() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.ListServicesRequest.filter)
  return _impl_.filter_.Release();
}
inline void ListServicesRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.ListServicesRequest.filter)
}

// -------------------------------------------------------------------

// ListServicesResponse

// repeated .google.api.serviceusage.v1.Service services = 1;
inline int ListServicesResponse::_internal_services_size() const {
  return _impl_.services_.size();
}
inline int ListServicesResponse::services_size() const {
  return _internal_services_size();
}
inline ::google::api::serviceusage::v1::Service* ListServicesResponse::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.ListServicesResponse.services)
  return _impl_.services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >*
ListServicesResponse::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:google.api.serviceusage.v1.ListServicesResponse.services)
  return &_impl_.services_;
}
inline const ::google::api::serviceusage::v1::Service& ListServicesResponse::_internal_services(int index) const {
  return _impl_.services_.Get(index);
}
inline const ::google::api::serviceusage::v1::Service& ListServicesResponse::services(int index) const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.ListServicesResponse.services)
  return _internal_services(index);
}
inline ::google::api::serviceusage::v1::Service* ListServicesResponse::_internal_add_services() {
  return _impl_.services_.Add();
}
inline ::google::api::serviceusage::v1::Service* ListServicesResponse::add_services() {
  ::google::api::serviceusage::v1::Service* _add = _internal_add_services();
  // @@protoc_insertion_point(field_add:google.api.serviceusage.v1.ListServicesResponse.services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >&
ListServicesResponse::services() const {
  // @@protoc_insertion_point(field_list:google.api.serviceusage.v1.ListServicesResponse.services)
  return _impl_.services_;
}

// string next_page_token = 2;
inline void ListServicesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListServicesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.ListServicesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServicesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.ListServicesResponse.next_page_token)
}
inline std::string* ListServicesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.ListServicesResponse.next_page_token)
  return _s;
}
inline const std::string& ListServicesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListServicesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServicesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServicesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.ListServicesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListServicesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.ListServicesResponse.next_page_token)
}

// -------------------------------------------------------------------

// BatchEnableServicesRequest

// string parent = 1;
inline void BatchEnableServicesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& BatchEnableServicesRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.BatchEnableServicesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchEnableServicesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.BatchEnableServicesRequest.parent)
}
inline std::string* BatchEnableServicesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.BatchEnableServicesRequest.parent)
  return _s;
}
inline const std::string& BatchEnableServicesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void BatchEnableServicesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchEnableServicesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* BatchEnableServicesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.BatchEnableServicesRequest.parent)
  return _impl_.parent_.Release();
}
inline void BatchEnableServicesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.BatchEnableServicesRequest.parent)
}

// repeated string service_ids = 2;
inline int BatchEnableServicesRequest::_internal_service_ids_size() const {
  return _impl_.service_ids_.size();
}
inline int BatchEnableServicesRequest::service_ids_size() const {
  return _internal_service_ids_size();
}
inline void BatchEnableServicesRequest::clear_service_ids() {
  _impl_.service_ids_.Clear();
}
inline std::string* BatchEnableServicesRequest::add_service_ids() {
  std::string* _s = _internal_add_service_ids();
  // @@protoc_insertion_point(field_add_mutable:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
  return _s;
}
inline const std::string& BatchEnableServicesRequest::_internal_service_ids(int index) const {
  return _impl_.service_ids_.Get(index);
}
inline const std::string& BatchEnableServicesRequest::service_ids(int index) const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
  return _internal_service_ids(index);
}
inline std::string* BatchEnableServicesRequest::mutable_service_ids(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
  return _impl_.service_ids_.Mutable(index);
}
inline void BatchEnableServicesRequest::set_service_ids(int index, const std::string& value) {
  _impl_.service_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
}
inline void BatchEnableServicesRequest::set_service_ids(int index, std::string&& value) {
  _impl_.service_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
}
inline void BatchEnableServicesRequest::set_service_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.service_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
}
inline void BatchEnableServicesRequest::set_service_ids(int index, const char* value, size_t size) {
  _impl_.service_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
}
inline std::string* BatchEnableServicesRequest::_internal_add_service_ids() {
  return _impl_.service_ids_.Add();
}
inline void BatchEnableServicesRequest::add_service_ids(const std::string& value) {
  _impl_.service_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
}
inline void BatchEnableServicesRequest::add_service_ids(std::string&& value) {
  _impl_.service_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
}
inline void BatchEnableServicesRequest::add_service_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.service_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
}
inline void BatchEnableServicesRequest::add_service_ids(const char* value, size_t size) {
  _impl_.service_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchEnableServicesRequest::service_ids() const {
  // @@protoc_insertion_point(field_list:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
  return _impl_.service_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchEnableServicesRequest::mutable_service_ids() {
  // @@protoc_insertion_point(field_mutable_list:google.api.serviceusage.v1.BatchEnableServicesRequest.service_ids)
  return &_impl_.service_ids_;
}

// -------------------------------------------------------------------

// BatchEnableServicesResponse_EnableFailure

// string service_id = 1;
inline void BatchEnableServicesResponse_EnableFailure::clear_service_id() {
  _impl_.service_id_.ClearToEmpty();
}
inline const std::string& BatchEnableServicesResponse_EnableFailure::service_id() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.service_id)
  return _internal_service_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchEnableServicesResponse_EnableFailure::set_service_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.service_id)
}
inline std::string* BatchEnableServicesResponse_EnableFailure::mutable_service_id() {
  std::string* _s = _internal_mutable_service_id();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.service_id)
  return _s;
}
inline const std::string& BatchEnableServicesResponse_EnableFailure::_internal_service_id() const {
  return _impl_.service_id_.Get();
}
inline void BatchEnableServicesResponse_EnableFailure::_internal_set_service_id(const std::string& value) {
  
  _impl_.service_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchEnableServicesResponse_EnableFailure::_internal_mutable_service_id() {
  
  return _impl_.service_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BatchEnableServicesResponse_EnableFailure::release_service_id() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.service_id)
  return _impl_.service_id_.Release();
}
inline void BatchEnableServicesResponse_EnableFailure::set_allocated_service_id(std::string* service_id) {
  if (service_id != nullptr) {
    
  } else {
    
  }
  _impl_.service_id_.SetAllocated(service_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_id_.IsDefault()) {
    _impl_.service_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.service_id)
}

// string error_message = 2;
inline void BatchEnableServicesResponse_EnableFailure::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& BatchEnableServicesResponse_EnableFailure::error_message() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchEnableServicesResponse_EnableFailure::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.error_message)
}
inline std::string* BatchEnableServicesResponse_EnableFailure::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.error_message)
  return _s;
}
inline const std::string& BatchEnableServicesResponse_EnableFailure::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void BatchEnableServicesResponse_EnableFailure::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchEnableServicesResponse_EnableFailure::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* BatchEnableServicesResponse_EnableFailure::release_error_message() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.error_message)
  return _impl_.error_message_.Release();
}
inline void BatchEnableServicesResponse_EnableFailure::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure.error_message)
}

// -------------------------------------------------------------------

// BatchEnableServicesResponse

// repeated .google.api.serviceusage.v1.Service services = 1;
inline int BatchEnableServicesResponse::_internal_services_size() const {
  return _impl_.services_.size();
}
inline int BatchEnableServicesResponse::services_size() const {
  return _internal_services_size();
}
inline ::google::api::serviceusage::v1::Service* BatchEnableServicesResponse::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.BatchEnableServicesResponse.services)
  return _impl_.services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >*
BatchEnableServicesResponse::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:google.api.serviceusage.v1.BatchEnableServicesResponse.services)
  return &_impl_.services_;
}
inline const ::google::api::serviceusage::v1::Service& BatchEnableServicesResponse::_internal_services(int index) const {
  return _impl_.services_.Get(index);
}
inline const ::google::api::serviceusage::v1::Service& BatchEnableServicesResponse::services(int index) const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.BatchEnableServicesResponse.services)
  return _internal_services(index);
}
inline ::google::api::serviceusage::v1::Service* BatchEnableServicesResponse::_internal_add_services() {
  return _impl_.services_.Add();
}
inline ::google::api::serviceusage::v1::Service* BatchEnableServicesResponse::add_services() {
  ::google::api::serviceusage::v1::Service* _add = _internal_add_services();
  // @@protoc_insertion_point(field_add:google.api.serviceusage.v1.BatchEnableServicesResponse.services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >&
BatchEnableServicesResponse::services() const {
  // @@protoc_insertion_point(field_list:google.api.serviceusage.v1.BatchEnableServicesResponse.services)
  return _impl_.services_;
}

// repeated .google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure failures = 2;
inline int BatchEnableServicesResponse::_internal_failures_size() const {
  return _impl_.failures_.size();
}
inline int BatchEnableServicesResponse::failures_size() const {
  return _internal_failures_size();
}
inline void BatchEnableServicesResponse::clear_failures() {
  _impl_.failures_.Clear();
}
inline ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure* BatchEnableServicesResponse::mutable_failures(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.BatchEnableServicesResponse.failures)
  return _impl_.failures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure >*
BatchEnableServicesResponse::mutable_failures() {
  // @@protoc_insertion_point(field_mutable_list:google.api.serviceusage.v1.BatchEnableServicesResponse.failures)
  return &_impl_.failures_;
}
inline const ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure& BatchEnableServicesResponse::_internal_failures(int index) const {
  return _impl_.failures_.Get(index);
}
inline const ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure& BatchEnableServicesResponse::failures(int index) const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.BatchEnableServicesResponse.failures)
  return _internal_failures(index);
}
inline ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure* BatchEnableServicesResponse::_internal_add_failures() {
  return _impl_.failures_.Add();
}
inline ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure* BatchEnableServicesResponse::add_failures() {
  ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure* _add = _internal_add_failures();
  // @@protoc_insertion_point(field_add:google.api.serviceusage.v1.BatchEnableServicesResponse.failures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::BatchEnableServicesResponse_EnableFailure >&
BatchEnableServicesResponse::failures() const {
  // @@protoc_insertion_point(field_list:google.api.serviceusage.v1.BatchEnableServicesResponse.failures)
  return _impl_.failures_;
}

// -------------------------------------------------------------------

// BatchGetServicesRequest

// string parent = 1;
inline void BatchGetServicesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& BatchGetServicesRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.BatchGetServicesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchGetServicesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.BatchGetServicesRequest.parent)
}
inline std::string* BatchGetServicesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.BatchGetServicesRequest.parent)
  return _s;
}
inline const std::string& BatchGetServicesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void BatchGetServicesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchGetServicesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* BatchGetServicesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.api.serviceusage.v1.BatchGetServicesRequest.parent)
  return _impl_.parent_.Release();
}
inline void BatchGetServicesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.serviceusage.v1.BatchGetServicesRequest.parent)
}

// repeated string names = 2;
inline int BatchGetServicesRequest::_internal_names_size() const {
  return _impl_.names_.size();
}
inline int BatchGetServicesRequest::names_size() const {
  return _internal_names_size();
}
inline void BatchGetServicesRequest::clear_names() {
  _impl_.names_.Clear();
}
inline std::string* BatchGetServicesRequest::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:google.api.serviceusage.v1.BatchGetServicesRequest.names)
  return _s;
}
inline const std::string& BatchGetServicesRequest::_internal_names(int index) const {
  return _impl_.names_.Get(index);
}
inline const std::string& BatchGetServicesRequest::names(int index) const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.BatchGetServicesRequest.names)
  return _internal_names(index);
}
inline std::string* BatchGetServicesRequest::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.BatchGetServicesRequest.names)
  return _impl_.names_.Mutable(index);
}
inline void BatchGetServicesRequest::set_names(int index, const std::string& value) {
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.BatchGetServicesRequest.names)
}
inline void BatchGetServicesRequest::set_names(int index, std::string&& value) {
  _impl_.names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.api.serviceusage.v1.BatchGetServicesRequest.names)
}
inline void BatchGetServicesRequest::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.api.serviceusage.v1.BatchGetServicesRequest.names)
}
inline void BatchGetServicesRequest::set_names(int index, const char* value, size_t size) {
  _impl_.names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.api.serviceusage.v1.BatchGetServicesRequest.names)
}
inline std::string* BatchGetServicesRequest::_internal_add_names() {
  return _impl_.names_.Add();
}
inline void BatchGetServicesRequest::add_names(const std::string& value) {
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.api.serviceusage.v1.BatchGetServicesRequest.names)
}
inline void BatchGetServicesRequest::add_names(std::string&& value) {
  _impl_.names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.api.serviceusage.v1.BatchGetServicesRequest.names)
}
inline void BatchGetServicesRequest::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.api.serviceusage.v1.BatchGetServicesRequest.names)
}
inline void BatchGetServicesRequest::add_names(const char* value, size_t size) {
  _impl_.names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.api.serviceusage.v1.BatchGetServicesRequest.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchGetServicesRequest::names() const {
  // @@protoc_insertion_point(field_list:google.api.serviceusage.v1.BatchGetServicesRequest.names)
  return _impl_.names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchGetServicesRequest::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:google.api.serviceusage.v1.BatchGetServicesRequest.names)
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// BatchGetServicesResponse

// repeated .google.api.serviceusage.v1.Service services = 1;
inline int BatchGetServicesResponse::_internal_services_size() const {
  return _impl_.services_.size();
}
inline int BatchGetServicesResponse::services_size() const {
  return _internal_services_size();
}
inline ::google::api::serviceusage::v1::Service* BatchGetServicesResponse::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.serviceusage.v1.BatchGetServicesResponse.services)
  return _impl_.services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >*
BatchGetServicesResponse::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:google.api.serviceusage.v1.BatchGetServicesResponse.services)
  return &_impl_.services_;
}
inline const ::google::api::serviceusage::v1::Service& BatchGetServicesResponse::_internal_services(int index) const {
  return _impl_.services_.Get(index);
}
inline const ::google::api::serviceusage::v1::Service& BatchGetServicesResponse::services(int index) const {
  // @@protoc_insertion_point(field_get:google.api.serviceusage.v1.BatchGetServicesResponse.services)
  return _internal_services(index);
}
inline ::google::api::serviceusage::v1::Service* BatchGetServicesResponse::_internal_add_services() {
  return _impl_.services_.Add();
}
inline ::google::api::serviceusage::v1::Service* BatchGetServicesResponse::add_services() {
  ::google::api::serviceusage::v1::Service* _add = _internal_add_services();
  // @@protoc_insertion_point(field_add:google.api.serviceusage.v1.BatchGetServicesResponse.services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::serviceusage::v1::Service >&
BatchGetServicesResponse::services() const {
  // @@protoc_insertion_point(field_list:google.api.serviceusage.v1.BatchGetServicesResponse.services)
  return _impl_.services_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace serviceusage
}  // namespace api
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage>() {
  return ::google::api::serviceusage::v1::DisableServiceRequest_CheckIfServiceHasUsage_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fapi_2fserviceusage_2fv1_2fserviceusage_2eproto
