// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/api/servicemanagement/v1/servicemanager.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/service.pb.h"
#include "google/api/servicemanagement/v1/resources.pb.h"
#include "google/longrunning/operations.pb.h"
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
namespace google {
namespace api {
namespace servicemanagement {
namespace v1 {
class CreateServiceConfigRequest;
struct CreateServiceConfigRequestDefaultTypeInternal;
extern CreateServiceConfigRequestDefaultTypeInternal _CreateServiceConfigRequest_default_instance_;
class CreateServiceRequest;
struct CreateServiceRequestDefaultTypeInternal;
extern CreateServiceRequestDefaultTypeInternal _CreateServiceRequest_default_instance_;
class CreateServiceRolloutRequest;
struct CreateServiceRolloutRequestDefaultTypeInternal;
extern CreateServiceRolloutRequestDefaultTypeInternal _CreateServiceRolloutRequest_default_instance_;
class DeleteServiceRequest;
struct DeleteServiceRequestDefaultTypeInternal;
extern DeleteServiceRequestDefaultTypeInternal _DeleteServiceRequest_default_instance_;
class GenerateConfigReportRequest;
struct GenerateConfigReportRequestDefaultTypeInternal;
extern GenerateConfigReportRequestDefaultTypeInternal _GenerateConfigReportRequest_default_instance_;
class GenerateConfigReportResponse;
struct GenerateConfigReportResponseDefaultTypeInternal;
extern GenerateConfigReportResponseDefaultTypeInternal _GenerateConfigReportResponse_default_instance_;
class GetServiceConfigRequest;
struct GetServiceConfigRequestDefaultTypeInternal;
extern GetServiceConfigRequestDefaultTypeInternal _GetServiceConfigRequest_default_instance_;
class GetServiceRequest;
struct GetServiceRequestDefaultTypeInternal;
extern GetServiceRequestDefaultTypeInternal _GetServiceRequest_default_instance_;
class GetServiceRolloutRequest;
struct GetServiceRolloutRequestDefaultTypeInternal;
extern GetServiceRolloutRequestDefaultTypeInternal _GetServiceRolloutRequest_default_instance_;
class ListServiceConfigsRequest;
struct ListServiceConfigsRequestDefaultTypeInternal;
extern ListServiceConfigsRequestDefaultTypeInternal _ListServiceConfigsRequest_default_instance_;
class ListServiceConfigsResponse;
struct ListServiceConfigsResponseDefaultTypeInternal;
extern ListServiceConfigsResponseDefaultTypeInternal _ListServiceConfigsResponse_default_instance_;
class ListServiceRolloutsRequest;
struct ListServiceRolloutsRequestDefaultTypeInternal;
extern ListServiceRolloutsRequestDefaultTypeInternal _ListServiceRolloutsRequest_default_instance_;
class ListServiceRolloutsResponse;
struct ListServiceRolloutsResponseDefaultTypeInternal;
extern ListServiceRolloutsResponseDefaultTypeInternal _ListServiceRolloutsResponse_default_instance_;
class ListServicesRequest;
struct ListServicesRequestDefaultTypeInternal;
extern ListServicesRequestDefaultTypeInternal _ListServicesRequest_default_instance_;
class ListServicesResponse;
struct ListServicesResponseDefaultTypeInternal;
extern ListServicesResponseDefaultTypeInternal _ListServicesResponse_default_instance_;
class SubmitConfigSourceRequest;
struct SubmitConfigSourceRequestDefaultTypeInternal;
extern SubmitConfigSourceRequestDefaultTypeInternal _SubmitConfigSourceRequest_default_instance_;
class SubmitConfigSourceResponse;
struct SubmitConfigSourceResponseDefaultTypeInternal;
extern SubmitConfigSourceResponseDefaultTypeInternal _SubmitConfigSourceResponse_default_instance_;
class UndeleteServiceRequest;
struct UndeleteServiceRequestDefaultTypeInternal;
extern UndeleteServiceRequestDefaultTypeInternal _UndeleteServiceRequest_default_instance_;
class UndeleteServiceResponse;
struct UndeleteServiceResponseDefaultTypeInternal;
extern UndeleteServiceResponseDefaultTypeInternal _UndeleteServiceResponse_default_instance_;
}  // namespace v1
}  // namespace servicemanagement
}  // namespace api
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::api::servicemanagement::v1::CreateServiceConfigRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::CreateServiceConfigRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::CreateServiceRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::CreateServiceRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::CreateServiceRolloutRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::CreateServiceRolloutRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::DeleteServiceRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::DeleteServiceRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::GenerateConfigReportRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::GenerateConfigReportRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::GenerateConfigReportResponse* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::GenerateConfigReportResponse>(Arena*);
template<> ::google::api::servicemanagement::v1::GetServiceConfigRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::GetServiceConfigRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::GetServiceRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::GetServiceRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::GetServiceRolloutRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::GetServiceRolloutRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::ListServiceConfigsRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ListServiceConfigsRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::ListServiceConfigsResponse* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ListServiceConfigsResponse>(Arena*);
template<> ::google::api::servicemanagement::v1::ListServiceRolloutsRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ListServiceRolloutsRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::ListServiceRolloutsResponse* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ListServiceRolloutsResponse>(Arena*);
template<> ::google::api::servicemanagement::v1::ListServicesRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ListServicesRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::ListServicesResponse* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ListServicesResponse>(Arena*);
template<> ::google::api::servicemanagement::v1::SubmitConfigSourceRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::SubmitConfigSourceRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::SubmitConfigSourceResponse* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::SubmitConfigSourceResponse>(Arena*);
template<> ::google::api::servicemanagement::v1::UndeleteServiceRequest* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::UndeleteServiceRequest>(Arena*);
template<> ::google::api::servicemanagement::v1::UndeleteServiceResponse* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::UndeleteServiceResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace api {
namespace servicemanagement {
namespace v1 {

enum GetServiceConfigRequest_ConfigView : int {
  GetServiceConfigRequest_ConfigView_BASIC = 0,
  GetServiceConfigRequest_ConfigView_FULL = 1,
  GetServiceConfigRequest_ConfigView_GetServiceConfigRequest_ConfigView_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GetServiceConfigRequest_ConfigView_GetServiceConfigRequest_ConfigView_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GetServiceConfigRequest_ConfigView_IsValid(int value);
constexpr GetServiceConfigRequest_ConfigView GetServiceConfigRequest_ConfigView_ConfigView_MIN = GetServiceConfigRequest_ConfigView_BASIC;
constexpr GetServiceConfigRequest_ConfigView GetServiceConfigRequest_ConfigView_ConfigView_MAX = GetServiceConfigRequest_ConfigView_FULL;
constexpr int GetServiceConfigRequest_ConfigView_ConfigView_ARRAYSIZE = GetServiceConfigRequest_ConfigView_ConfigView_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetServiceConfigRequest_ConfigView_descriptor();
template<typename T>
inline const std::string& GetServiceConfigRequest_ConfigView_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetServiceConfigRequest_ConfigView>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetServiceConfigRequest_ConfigView_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetServiceConfigRequest_ConfigView_descriptor(), enum_t_value);
}
inline bool GetServiceConfigRequest_ConfigView_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetServiceConfigRequest_ConfigView* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetServiceConfigRequest_ConfigView>(
    GetServiceConfigRequest_ConfigView_descriptor(), name, value);
}
// ===================================================================

class ListServicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ListServicesRequest) */ {
 public:
  inline ListServicesRequest() : ListServicesRequest(nullptr) {}
  ~ListServicesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListServicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServicesRequest(const ListServicesRequest& from);
  ListServicesRequest(ListServicesRequest&& from) noexcept
    : ListServicesRequest() {
    *this = ::std::move(from);
  }

  inline ListServicesRequest& operator=(const ListServicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServicesRequest& operator=(ListServicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListServicesRequest*>(
               &_ListServicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListServicesRequest& a, ListServicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServicesRequest& from) {
    ListServicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ListServicesRequest";
  }
  protected:
  explicit ListServicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProducerProjectIdFieldNumber = 1,
    kPageTokenFieldNumber = 6,
    kConsumerIdFieldNumber = 7,
    kPageSizeFieldNumber = 5,
  };
  // string producer_project_id = 1;
  void clear_producer_project_id();
  const std::string& producer_project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_producer_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_producer_project_id();
  PROTOBUF_NODISCARD std::string* release_producer_project_id();
  void set_allocated_producer_project_id(std::string* producer_project_id);
  private:
  const std::string& _internal_producer_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_project_id(const std::string& value);
  std::string* _internal_mutable_producer_project_id();
  public:

  // string page_token = 6;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // string consumer_id = 7 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_consumer_id();
  PROTOBUF_DEPRECATED const std::string& consumer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_consumer_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_consumer_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_consumer_id();
  PROTOBUF_DEPRECATED void set_allocated_consumer_id(std::string* consumer_id);
  private:
  const std::string& _internal_consumer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumer_id(const std::string& value);
  std::string* _internal_mutable_consumer_id();
  public:

  // int32 page_size = 5;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ListServicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr producer_project_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consumer_id_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class ListServicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ListServicesResponse) */ {
 public:
  inline ListServicesResponse() : ListServicesResponse(nullptr) {}
  ~ListServicesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListServicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServicesResponse(const ListServicesResponse& from);
  ListServicesResponse(ListServicesResponse&& from) noexcept
    : ListServicesResponse() {
    *this = ::std::move(from);
  }

  inline ListServicesResponse& operator=(const ListServicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServicesResponse& operator=(ListServicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListServicesResponse*>(
               &_ListServicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListServicesResponse& a, ListServicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServicesResponse& from) {
    ListServicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ListServicesResponse";
  }
  protected:
  explicit ListServicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.api.servicemanagement.v1.ManagedService services = 1;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::google::api::servicemanagement::v1::ManagedService* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ManagedService >*
      mutable_services();
  private:
  const ::google::api::servicemanagement::v1::ManagedService& _internal_services(int index) const;
  ::google::api::servicemanagement::v1::ManagedService* _internal_add_services();
  public:
  const ::google::api::servicemanagement::v1::ManagedService& services(int index) const;
  ::google::api::servicemanagement::v1::ManagedService* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ManagedService >&
      services() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ListServicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ManagedService > services_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class GetServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.GetServiceRequest) */ {
 public:
  inline GetServiceRequest() : GetServiceRequest(nullptr) {}
  ~GetServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR GetServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceRequest(const GetServiceRequest& from);
  GetServiceRequest(GetServiceRequest&& from) noexcept
    : GetServiceRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceRequest& operator=(const GetServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceRequest& operator=(GetServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceRequest*>(
               &_GetServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetServiceRequest& a, GetServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceRequest& from) {
    GetServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.GetServiceRequest";
  }
  protected:
  explicit GetServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.GetServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class CreateServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.CreateServiceRequest) */ {
 public:
  inline CreateServiceRequest() : CreateServiceRequest(nullptr) {}
  ~CreateServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateServiceRequest(const CreateServiceRequest& from);
  CreateServiceRequest(CreateServiceRequest&& from) noexcept
    : CreateServiceRequest() {
    *this = ::std::move(from);
  }

  inline CreateServiceRequest& operator=(const CreateServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateServiceRequest& operator=(CreateServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateServiceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateServiceRequest*>(
               &_CreateServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateServiceRequest& a, CreateServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateServiceRequest& from) {
    CreateServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.CreateServiceRequest";
  }
  protected:
  explicit CreateServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
  };
  // .google.api.servicemanagement.v1.ManagedService service = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::google::api::servicemanagement::v1::ManagedService& service() const;
  PROTOBUF_NODISCARD ::google::api::servicemanagement::v1::ManagedService* release_service();
  ::google::api::servicemanagement::v1::ManagedService* mutable_service();
  void set_allocated_service(::google::api::servicemanagement::v1::ManagedService* service);
  private:
  const ::google::api::servicemanagement::v1::ManagedService& _internal_service() const;
  ::google::api::servicemanagement::v1::ManagedService* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::google::api::servicemanagement::v1::ManagedService* service);
  ::google::api::servicemanagement::v1::ManagedService* unsafe_arena_release_service();

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.CreateServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::api::servicemanagement::v1::ManagedService* service_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class DeleteServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.DeleteServiceRequest) */ {
 public:
  inline DeleteServiceRequest() : DeleteServiceRequest(nullptr) {}
  ~DeleteServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteServiceRequest(const DeleteServiceRequest& from);
  DeleteServiceRequest(DeleteServiceRequest&& from) noexcept
    : DeleteServiceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteServiceRequest& operator=(const DeleteServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteServiceRequest& operator=(DeleteServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteServiceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteServiceRequest*>(
               &_DeleteServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteServiceRequest& a, DeleteServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteServiceRequest& from) {
    DeleteServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.DeleteServiceRequest";
  }
  protected:
  explicit DeleteServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.DeleteServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class UndeleteServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.UndeleteServiceRequest) */ {
 public:
  inline UndeleteServiceRequest() : UndeleteServiceRequest(nullptr) {}
  ~UndeleteServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR UndeleteServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndeleteServiceRequest(const UndeleteServiceRequest& from);
  UndeleteServiceRequest(UndeleteServiceRequest&& from) noexcept
    : UndeleteServiceRequest() {
    *this = ::std::move(from);
  }

  inline UndeleteServiceRequest& operator=(const UndeleteServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndeleteServiceRequest& operator=(UndeleteServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndeleteServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndeleteServiceRequest* internal_default_instance() {
    return reinterpret_cast<const UndeleteServiceRequest*>(
               &_UndeleteServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UndeleteServiceRequest& a, UndeleteServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UndeleteServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndeleteServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndeleteServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndeleteServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndeleteServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UndeleteServiceRequest& from) {
    UndeleteServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndeleteServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.UndeleteServiceRequest";
  }
  protected:
  explicit UndeleteServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.UndeleteServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class UndeleteServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.UndeleteServiceResponse) */ {
 public:
  inline UndeleteServiceResponse() : UndeleteServiceResponse(nullptr) {}
  ~UndeleteServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR UndeleteServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndeleteServiceResponse(const UndeleteServiceResponse& from);
  UndeleteServiceResponse(UndeleteServiceResponse&& from) noexcept
    : UndeleteServiceResponse() {
    *this = ::std::move(from);
  }

  inline UndeleteServiceResponse& operator=(const UndeleteServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndeleteServiceResponse& operator=(UndeleteServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndeleteServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndeleteServiceResponse* internal_default_instance() {
    return reinterpret_cast<const UndeleteServiceResponse*>(
               &_UndeleteServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UndeleteServiceResponse& a, UndeleteServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UndeleteServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndeleteServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndeleteServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndeleteServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndeleteServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UndeleteServiceResponse& from) {
    UndeleteServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndeleteServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.UndeleteServiceResponse";
  }
  protected:
  explicit UndeleteServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
  };
  // .google.api.servicemanagement.v1.ManagedService service = 1;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::google::api::servicemanagement::v1::ManagedService& service() const;
  PROTOBUF_NODISCARD ::google::api::servicemanagement::v1::ManagedService* release_service();
  ::google::api::servicemanagement::v1::ManagedService* mutable_service();
  void set_allocated_service(::google::api::servicemanagement::v1::ManagedService* service);
  private:
  const ::google::api::servicemanagement::v1::ManagedService& _internal_service() const;
  ::google::api::servicemanagement::v1::ManagedService* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::google::api::servicemanagement::v1::ManagedService* service);
  ::google::api::servicemanagement::v1::ManagedService* unsafe_arena_release_service();

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.UndeleteServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::api::servicemanagement::v1::ManagedService* service_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class GetServiceConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.GetServiceConfigRequest) */ {
 public:
  inline GetServiceConfigRequest() : GetServiceConfigRequest(nullptr) {}
  ~GetServiceConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR GetServiceConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceConfigRequest(const GetServiceConfigRequest& from);
  GetServiceConfigRequest(GetServiceConfigRequest&& from) noexcept
    : GetServiceConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceConfigRequest& operator=(const GetServiceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceConfigRequest& operator=(GetServiceConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceConfigRequest*>(
               &_GetServiceConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetServiceConfigRequest& a, GetServiceConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceConfigRequest& from) {
    GetServiceConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.GetServiceConfigRequest";
  }
  protected:
  explicit GetServiceConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetServiceConfigRequest_ConfigView ConfigView;
  static constexpr ConfigView BASIC =
    GetServiceConfigRequest_ConfigView_BASIC;
  static constexpr ConfigView FULL =
    GetServiceConfigRequest_ConfigView_FULL;
  static inline bool ConfigView_IsValid(int value) {
    return GetServiceConfigRequest_ConfigView_IsValid(value);
  }
  static constexpr ConfigView ConfigView_MIN =
    GetServiceConfigRequest_ConfigView_ConfigView_MIN;
  static constexpr ConfigView ConfigView_MAX =
    GetServiceConfigRequest_ConfigView_ConfigView_MAX;
  static constexpr int ConfigView_ARRAYSIZE =
    GetServiceConfigRequest_ConfigView_ConfigView_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConfigView_descriptor() {
    return GetServiceConfigRequest_ConfigView_descriptor();
  }
  template<typename T>
  static inline const std::string& ConfigView_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConfigView>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConfigView_Name.");
    return GetServiceConfigRequest_ConfigView_Name(enum_t_value);
  }
  static inline bool ConfigView_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConfigView* value) {
    return GetServiceConfigRequest_ConfigView_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kConfigIdFieldNumber = 2,
    kViewFieldNumber = 3,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string config_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_config_id();
  const std::string& config_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_id();
  PROTOBUF_NODISCARD std::string* release_config_id();
  void set_allocated_config_id(std::string* config_id);
  private:
  const std::string& _internal_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_id(const std::string& value);
  std::string* _internal_mutable_config_id();
  public:

  // .google.api.servicemanagement.v1.GetServiceConfigRequest.ConfigView view = 3;
  void clear_view();
  ::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView view() const;
  void set_view(::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView value);
  private:
  ::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView _internal_view() const;
  void _internal_set_view(::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.GetServiceConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_id_;
    int view_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class ListServiceConfigsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ListServiceConfigsRequest) */ {
 public:
  inline ListServiceConfigsRequest() : ListServiceConfigsRequest(nullptr) {}
  ~ListServiceConfigsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListServiceConfigsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceConfigsRequest(const ListServiceConfigsRequest& from);
  ListServiceConfigsRequest(ListServiceConfigsRequest&& from) noexcept
    : ListServiceConfigsRequest() {
    *this = ::std::move(from);
  }

  inline ListServiceConfigsRequest& operator=(const ListServiceConfigsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceConfigsRequest& operator=(ListServiceConfigsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceConfigsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceConfigsRequest* internal_default_instance() {
    return reinterpret_cast<const ListServiceConfigsRequest*>(
               &_ListServiceConfigsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListServiceConfigsRequest& a, ListServiceConfigsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceConfigsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceConfigsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceConfigsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceConfigsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceConfigsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServiceConfigsRequest& from) {
    ListServiceConfigsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceConfigsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ListServiceConfigsRequest";
  }
  protected:
  explicit ListServiceConfigsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string page_token = 2;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ListServiceConfigsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class ListServiceConfigsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ListServiceConfigsResponse) */ {
 public:
  inline ListServiceConfigsResponse() : ListServiceConfigsResponse(nullptr) {}
  ~ListServiceConfigsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListServiceConfigsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceConfigsResponse(const ListServiceConfigsResponse& from);
  ListServiceConfigsResponse(ListServiceConfigsResponse&& from) noexcept
    : ListServiceConfigsResponse() {
    *this = ::std::move(from);
  }

  inline ListServiceConfigsResponse& operator=(const ListServiceConfigsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceConfigsResponse& operator=(ListServiceConfigsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceConfigsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceConfigsResponse* internal_default_instance() {
    return reinterpret_cast<const ListServiceConfigsResponse*>(
               &_ListServiceConfigsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListServiceConfigsResponse& a, ListServiceConfigsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceConfigsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceConfigsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceConfigsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceConfigsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceConfigsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServiceConfigsResponse& from) {
    ListServiceConfigsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceConfigsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ListServiceConfigsResponse";
  }
  protected:
  explicit ListServiceConfigsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceConfigsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.api.Service service_configs = 1;
  int service_configs_size() const;
  private:
  int _internal_service_configs_size() const;
  public:
  void clear_service_configs();
  ::google::api::Service* mutable_service_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::Service >*
      mutable_service_configs();
  private:
  const ::google::api::Service& _internal_service_configs(int index) const;
  ::google::api::Service* _internal_add_service_configs();
  public:
  const ::google::api::Service& service_configs(int index) const;
  ::google::api::Service* add_service_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::Service >&
      service_configs() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ListServiceConfigsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::Service > service_configs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class CreateServiceConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.CreateServiceConfigRequest) */ {
 public:
  inline CreateServiceConfigRequest() : CreateServiceConfigRequest(nullptr) {}
  ~CreateServiceConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateServiceConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateServiceConfigRequest(const CreateServiceConfigRequest& from);
  CreateServiceConfigRequest(CreateServiceConfigRequest&& from) noexcept
    : CreateServiceConfigRequest() {
    *this = ::std::move(from);
  }

  inline CreateServiceConfigRequest& operator=(const CreateServiceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateServiceConfigRequest& operator=(CreateServiceConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateServiceConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateServiceConfigRequest* internal_default_instance() {
    return reinterpret_cast<const CreateServiceConfigRequest*>(
               &_CreateServiceConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateServiceConfigRequest& a, CreateServiceConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateServiceConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateServiceConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateServiceConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateServiceConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateServiceConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateServiceConfigRequest& from) {
    CreateServiceConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateServiceConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.CreateServiceConfigRequest";
  }
  protected:
  explicit CreateServiceConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kServiceConfigFieldNumber = 2,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // .google.api.Service service_config = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_service_config() const;
  private:
  bool _internal_has_service_config() const;
  public:
  void clear_service_config();
  const ::google::api::Service& service_config() const;
  PROTOBUF_NODISCARD ::google::api::Service* release_service_config();
  ::google::api::Service* mutable_service_config();
  void set_allocated_service_config(::google::api::Service* service_config);
  private:
  const ::google::api::Service& _internal_service_config() const;
  ::google::api::Service* _internal_mutable_service_config();
  public:
  void unsafe_arena_set_allocated_service_config(
      ::google::api::Service* service_config);
  ::google::api::Service* unsafe_arena_release_service_config();

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.CreateServiceConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::google::api::Service* service_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class SubmitConfigSourceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.SubmitConfigSourceRequest) */ {
 public:
  inline SubmitConfigSourceRequest() : SubmitConfigSourceRequest(nullptr) {}
  ~SubmitConfigSourceRequest() override;
  explicit PROTOBUF_CONSTEXPR SubmitConfigSourceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitConfigSourceRequest(const SubmitConfigSourceRequest& from);
  SubmitConfigSourceRequest(SubmitConfigSourceRequest&& from) noexcept
    : SubmitConfigSourceRequest() {
    *this = ::std::move(from);
  }

  inline SubmitConfigSourceRequest& operator=(const SubmitConfigSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitConfigSourceRequest& operator=(SubmitConfigSourceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitConfigSourceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitConfigSourceRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitConfigSourceRequest*>(
               &_SubmitConfigSourceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SubmitConfigSourceRequest& a, SubmitConfigSourceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitConfigSourceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitConfigSourceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitConfigSourceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitConfigSourceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitConfigSourceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitConfigSourceRequest& from) {
    SubmitConfigSourceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitConfigSourceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.SubmitConfigSourceRequest";
  }
  protected:
  explicit SubmitConfigSourceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kConfigSourceFieldNumber = 2,
    kValidateOnlyFieldNumber = 3,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // .google.api.servicemanagement.v1.ConfigSource config_source = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_config_source() const;
  private:
  bool _internal_has_config_source() const;
  public:
  void clear_config_source();
  const ::google::api::servicemanagement::v1::ConfigSource& config_source() const;
  PROTOBUF_NODISCARD ::google::api::servicemanagement::v1::ConfigSource* release_config_source();
  ::google::api::servicemanagement::v1::ConfigSource* mutable_config_source();
  void set_allocated_config_source(::google::api::servicemanagement::v1::ConfigSource* config_source);
  private:
  const ::google::api::servicemanagement::v1::ConfigSource& _internal_config_source() const;
  ::google::api::servicemanagement::v1::ConfigSource* _internal_mutable_config_source();
  public:
  void unsafe_arena_set_allocated_config_source(
      ::google::api::servicemanagement::v1::ConfigSource* config_source);
  ::google::api::servicemanagement::v1::ConfigSource* unsafe_arena_release_config_source();

  // bool validate_only = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_validate_only();
  bool validate_only() const;
  void set_validate_only(bool value);
  private:
  bool _internal_validate_only() const;
  void _internal_set_validate_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.SubmitConfigSourceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::google::api::servicemanagement::v1::ConfigSource* config_source_;
    bool validate_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class SubmitConfigSourceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.SubmitConfigSourceResponse) */ {
 public:
  inline SubmitConfigSourceResponse() : SubmitConfigSourceResponse(nullptr) {}
  ~SubmitConfigSourceResponse() override;
  explicit PROTOBUF_CONSTEXPR SubmitConfigSourceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubmitConfigSourceResponse(const SubmitConfigSourceResponse& from);
  SubmitConfigSourceResponse(SubmitConfigSourceResponse&& from) noexcept
    : SubmitConfigSourceResponse() {
    *this = ::std::move(from);
  }

  inline SubmitConfigSourceResponse& operator=(const SubmitConfigSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitConfigSourceResponse& operator=(SubmitConfigSourceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitConfigSourceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitConfigSourceResponse* internal_default_instance() {
    return reinterpret_cast<const SubmitConfigSourceResponse*>(
               &_SubmitConfigSourceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SubmitConfigSourceResponse& a, SubmitConfigSourceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmitConfigSourceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitConfigSourceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitConfigSourceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubmitConfigSourceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubmitConfigSourceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubmitConfigSourceResponse& from) {
    SubmitConfigSourceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmitConfigSourceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.SubmitConfigSourceResponse";
  }
  protected:
  explicit SubmitConfigSourceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceConfigFieldNumber = 1,
  };
  // .google.api.Service service_config = 1;
  bool has_service_config() const;
  private:
  bool _internal_has_service_config() const;
  public:
  void clear_service_config();
  const ::google::api::Service& service_config() const;
  PROTOBUF_NODISCARD ::google::api::Service* release_service_config();
  ::google::api::Service* mutable_service_config();
  void set_allocated_service_config(::google::api::Service* service_config);
  private:
  const ::google::api::Service& _internal_service_config() const;
  ::google::api::Service* _internal_mutable_service_config();
  public:
  void unsafe_arena_set_allocated_service_config(
      ::google::api::Service* service_config);
  ::google::api::Service* unsafe_arena_release_service_config();

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.SubmitConfigSourceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::api::Service* service_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class CreateServiceRolloutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.CreateServiceRolloutRequest) */ {
 public:
  inline CreateServiceRolloutRequest() : CreateServiceRolloutRequest(nullptr) {}
  ~CreateServiceRolloutRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateServiceRolloutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateServiceRolloutRequest(const CreateServiceRolloutRequest& from);
  CreateServiceRolloutRequest(CreateServiceRolloutRequest&& from) noexcept
    : CreateServiceRolloutRequest() {
    *this = ::std::move(from);
  }

  inline CreateServiceRolloutRequest& operator=(const CreateServiceRolloutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateServiceRolloutRequest& operator=(CreateServiceRolloutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateServiceRolloutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateServiceRolloutRequest* internal_default_instance() {
    return reinterpret_cast<const CreateServiceRolloutRequest*>(
               &_CreateServiceRolloutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CreateServiceRolloutRequest& a, CreateServiceRolloutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateServiceRolloutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateServiceRolloutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateServiceRolloutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateServiceRolloutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateServiceRolloutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateServiceRolloutRequest& from) {
    CreateServiceRolloutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateServiceRolloutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.CreateServiceRolloutRequest";
  }
  protected:
  explicit CreateServiceRolloutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kRolloutFieldNumber = 2,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // .google.api.servicemanagement.v1.Rollout rollout = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_rollout() const;
  private:
  bool _internal_has_rollout() const;
  public:
  void clear_rollout();
  const ::google::api::servicemanagement::v1::Rollout& rollout() const;
  PROTOBUF_NODISCARD ::google::api::servicemanagement::v1::Rollout* release_rollout();
  ::google::api::servicemanagement::v1::Rollout* mutable_rollout();
  void set_allocated_rollout(::google::api::servicemanagement::v1::Rollout* rollout);
  private:
  const ::google::api::servicemanagement::v1::Rollout& _internal_rollout() const;
  ::google::api::servicemanagement::v1::Rollout* _internal_mutable_rollout();
  public:
  void unsafe_arena_set_allocated_rollout(
      ::google::api::servicemanagement::v1::Rollout* rollout);
  ::google::api::servicemanagement::v1::Rollout* unsafe_arena_release_rollout();

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.CreateServiceRolloutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::google::api::servicemanagement::v1::Rollout* rollout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class ListServiceRolloutsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ListServiceRolloutsRequest) */ {
 public:
  inline ListServiceRolloutsRequest() : ListServiceRolloutsRequest(nullptr) {}
  ~ListServiceRolloutsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListServiceRolloutsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceRolloutsRequest(const ListServiceRolloutsRequest& from);
  ListServiceRolloutsRequest(ListServiceRolloutsRequest&& from) noexcept
    : ListServiceRolloutsRequest() {
    *this = ::std::move(from);
  }

  inline ListServiceRolloutsRequest& operator=(const ListServiceRolloutsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceRolloutsRequest& operator=(ListServiceRolloutsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceRolloutsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceRolloutsRequest* internal_default_instance() {
    return reinterpret_cast<const ListServiceRolloutsRequest*>(
               &_ListServiceRolloutsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListServiceRolloutsRequest& a, ListServiceRolloutsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceRolloutsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceRolloutsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceRolloutsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceRolloutsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceRolloutsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServiceRolloutsRequest& from) {
    ListServiceRolloutsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceRolloutsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ListServiceRolloutsRequest";
  }
  protected:
  explicit ListServiceRolloutsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kPageTokenFieldNumber = 2,
    kFilterFieldNumber = 4,
    kPageSizeFieldNumber = 3,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string page_token = 2;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // string filter = 4 [(.google.api.field_behavior) = REQUIRED];
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ListServiceRolloutsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class ListServiceRolloutsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ListServiceRolloutsResponse) */ {
 public:
  inline ListServiceRolloutsResponse() : ListServiceRolloutsResponse(nullptr) {}
  ~ListServiceRolloutsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListServiceRolloutsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceRolloutsResponse(const ListServiceRolloutsResponse& from);
  ListServiceRolloutsResponse(ListServiceRolloutsResponse&& from) noexcept
    : ListServiceRolloutsResponse() {
    *this = ::std::move(from);
  }

  inline ListServiceRolloutsResponse& operator=(const ListServiceRolloutsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceRolloutsResponse& operator=(ListServiceRolloutsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceRolloutsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceRolloutsResponse* internal_default_instance() {
    return reinterpret_cast<const ListServiceRolloutsResponse*>(
               &_ListServiceRolloutsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListServiceRolloutsResponse& a, ListServiceRolloutsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceRolloutsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceRolloutsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceRolloutsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceRolloutsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceRolloutsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServiceRolloutsResponse& from) {
    ListServiceRolloutsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceRolloutsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ListServiceRolloutsResponse";
  }
  protected:
  explicit ListServiceRolloutsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolloutsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.api.servicemanagement.v1.Rollout rollouts = 1;
  int rollouts_size() const;
  private:
  int _internal_rollouts_size() const;
  public:
  void clear_rollouts();
  ::google::api::servicemanagement::v1::Rollout* mutable_rollouts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Rollout >*
      mutable_rollouts();
  private:
  const ::google::api::servicemanagement::v1::Rollout& _internal_rollouts(int index) const;
  ::google::api::servicemanagement::v1::Rollout* _internal_add_rollouts();
  public:
  const ::google::api::servicemanagement::v1::Rollout& rollouts(int index) const;
  ::google::api::servicemanagement::v1::Rollout* add_rollouts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Rollout >&
      rollouts() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ListServiceRolloutsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Rollout > rollouts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class GetServiceRolloutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.GetServiceRolloutRequest) */ {
 public:
  inline GetServiceRolloutRequest() : GetServiceRolloutRequest(nullptr) {}
  ~GetServiceRolloutRequest() override;
  explicit PROTOBUF_CONSTEXPR GetServiceRolloutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceRolloutRequest(const GetServiceRolloutRequest& from);
  GetServiceRolloutRequest(GetServiceRolloutRequest&& from) noexcept
    : GetServiceRolloutRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceRolloutRequest& operator=(const GetServiceRolloutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceRolloutRequest& operator=(GetServiceRolloutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceRolloutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceRolloutRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceRolloutRequest*>(
               &_GetServiceRolloutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetServiceRolloutRequest& a, GetServiceRolloutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceRolloutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceRolloutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceRolloutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceRolloutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceRolloutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceRolloutRequest& from) {
    GetServiceRolloutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceRolloutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.GetServiceRolloutRequest";
  }
  protected:
  explicit GetServiceRolloutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kRolloutIdFieldNumber = 2,
  };
  // string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string rollout_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_rollout_id();
  const std::string& rollout_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rollout_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rollout_id();
  PROTOBUF_NODISCARD std::string* release_rollout_id();
  void set_allocated_rollout_id(std::string* rollout_id);
  private:
  const std::string& _internal_rollout_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rollout_id(const std::string& value);
  std::string* _internal_mutable_rollout_id();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.GetServiceRolloutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rollout_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class GenerateConfigReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.GenerateConfigReportRequest) */ {
 public:
  inline GenerateConfigReportRequest() : GenerateConfigReportRequest(nullptr) {}
  ~GenerateConfigReportRequest() override;
  explicit PROTOBUF_CONSTEXPR GenerateConfigReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateConfigReportRequest(const GenerateConfigReportRequest& from);
  GenerateConfigReportRequest(GenerateConfigReportRequest&& from) noexcept
    : GenerateConfigReportRequest() {
    *this = ::std::move(from);
  }

  inline GenerateConfigReportRequest& operator=(const GenerateConfigReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateConfigReportRequest& operator=(GenerateConfigReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateConfigReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateConfigReportRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateConfigReportRequest*>(
               &_GenerateConfigReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GenerateConfigReportRequest& a, GenerateConfigReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateConfigReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateConfigReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateConfigReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateConfigReportRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateConfigReportRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenerateConfigReportRequest& from) {
    GenerateConfigReportRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateConfigReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.GenerateConfigReportRequest";
  }
  protected:
  explicit GenerateConfigReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewConfigFieldNumber = 1,
    kOldConfigFieldNumber = 2,
  };
  // .google.protobuf.Any new_config = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_new_config() const;
  private:
  bool _internal_has_new_config() const;
  public:
  void clear_new_config();
  const ::PROTOBUF_NAMESPACE_ID::Any& new_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_new_config();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_new_config();
  void set_allocated_new_config(::PROTOBUF_NAMESPACE_ID::Any* new_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_new_config() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_new_config();
  public:
  void unsafe_arena_set_allocated_new_config(
      ::PROTOBUF_NAMESPACE_ID::Any* new_config);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_new_config();

  // .google.protobuf.Any old_config = 2 [(.google.api.field_behavior) = OPTIONAL];
  bool has_old_config() const;
  private:
  bool _internal_has_old_config() const;
  public:
  void clear_old_config();
  const ::PROTOBUF_NAMESPACE_ID::Any& old_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_old_config();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_old_config();
  void set_allocated_old_config(::PROTOBUF_NAMESPACE_ID::Any* old_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_old_config() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_old_config();
  public:
  void unsafe_arena_set_allocated_old_config(
      ::PROTOBUF_NAMESPACE_ID::Any* old_config);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_old_config();

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.GenerateConfigReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Any* new_config_;
    ::PROTOBUF_NAMESPACE_ID::Any* old_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// -------------------------------------------------------------------

class GenerateConfigReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.GenerateConfigReportResponse) */ {
 public:
  inline GenerateConfigReportResponse() : GenerateConfigReportResponse(nullptr) {}
  ~GenerateConfigReportResponse() override;
  explicit PROTOBUF_CONSTEXPR GenerateConfigReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateConfigReportResponse(const GenerateConfigReportResponse& from);
  GenerateConfigReportResponse(GenerateConfigReportResponse&& from) noexcept
    : GenerateConfigReportResponse() {
    *this = ::std::move(from);
  }

  inline GenerateConfigReportResponse& operator=(const GenerateConfigReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateConfigReportResponse& operator=(GenerateConfigReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateConfigReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateConfigReportResponse* internal_default_instance() {
    return reinterpret_cast<const GenerateConfigReportResponse*>(
               &_GenerateConfigReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GenerateConfigReportResponse& a, GenerateConfigReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateConfigReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateConfigReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateConfigReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateConfigReportResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateConfigReportResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenerateConfigReportResponse& from) {
    GenerateConfigReportResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateConfigReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.GenerateConfigReportResponse";
  }
  protected:
  explicit GenerateConfigReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeReportsFieldNumber = 3,
    kDiagnosticsFieldNumber = 4,
    kServiceNameFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // repeated .google.api.servicemanagement.v1.ChangeReport change_reports = 3;
  int change_reports_size() const;
  private:
  int _internal_change_reports_size() const;
  public:
  void clear_change_reports();
  ::google::api::servicemanagement::v1::ChangeReport* mutable_change_reports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ChangeReport >*
      mutable_change_reports();
  private:
  const ::google::api::servicemanagement::v1::ChangeReport& _internal_change_reports(int index) const;
  ::google::api::servicemanagement::v1::ChangeReport* _internal_add_change_reports();
  public:
  const ::google::api::servicemanagement::v1::ChangeReport& change_reports(int index) const;
  ::google::api::servicemanagement::v1::ChangeReport* add_change_reports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ChangeReport >&
      change_reports() const;

  // repeated .google.api.servicemanagement.v1.Diagnostic diagnostics = 4;
  int diagnostics_size() const;
  private:
  int _internal_diagnostics_size() const;
  public:
  void clear_diagnostics();
  ::google::api::servicemanagement::v1::Diagnostic* mutable_diagnostics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Diagnostic >*
      mutable_diagnostics();
  private:
  const ::google::api::servicemanagement::v1::Diagnostic& _internal_diagnostics(int index) const;
  ::google::api::servicemanagement::v1::Diagnostic* _internal_add_diagnostics();
  public:
  const ::google::api::servicemanagement::v1::Diagnostic& diagnostics(int index) const;
  ::google::api::servicemanagement::v1::Diagnostic* add_diagnostics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Diagnostic >&
      diagnostics() const;

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.GenerateConfigReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ChangeReport > change_reports_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Diagnostic > diagnostics_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ListServicesRequest

// string producer_project_id = 1;
inline void ListServicesRequest::clear_producer_project_id() {
  _impl_.producer_project_id_.ClearToEmpty();
}
inline const std::string& ListServicesRequest::producer_project_id() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServicesRequest.producer_project_id)
  return _internal_producer_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServicesRequest::set_producer_project_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.producer_project_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServicesRequest.producer_project_id)
}
inline std::string* ListServicesRequest::mutable_producer_project_id() {
  std::string* _s = _internal_mutable_producer_project_id();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServicesRequest.producer_project_id)
  return _s;
}
inline const std::string& ListServicesRequest::_internal_producer_project_id() const {
  return _impl_.producer_project_id_.Get();
}
inline void ListServicesRequest::_internal_set_producer_project_id(const std::string& value) {
  
  _impl_.producer_project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServicesRequest::_internal_mutable_producer_project_id() {
  
  return _impl_.producer_project_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServicesRequest::release_producer_project_id() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServicesRequest.producer_project_id)
  return _impl_.producer_project_id_.Release();
}
inline void ListServicesRequest::set_allocated_producer_project_id(std::string* producer_project_id) {
  if (producer_project_id != nullptr) {
    
  } else {
    
  }
  _impl_.producer_project_id_.SetAllocated(producer_project_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.producer_project_id_.IsDefault()) {
    _impl_.producer_project_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServicesRequest.producer_project_id)
}

// int32 page_size = 5;
inline void ListServicesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListServicesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListServicesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServicesRequest.page_size)
  return _internal_page_size();
}
inline void ListServicesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListServicesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServicesRequest.page_size)
}

// string page_token = 6;
inline void ListServicesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListServicesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServicesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServicesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServicesRequest.page_token)
}
inline std::string* ListServicesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServicesRequest.page_token)
  return _s;
}
inline const std::string& ListServicesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListServicesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServicesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServicesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServicesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListServicesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServicesRequest.page_token)
}

// string consumer_id = 7 [deprecated = true];
inline void ListServicesRequest::clear_consumer_id() {
  _impl_.consumer_id_.ClearToEmpty();
}
inline const std::string& ListServicesRequest::consumer_id() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServicesRequest.consumer_id)
  return _internal_consumer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServicesRequest::set_consumer_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.consumer_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServicesRequest.consumer_id)
}
inline std::string* ListServicesRequest::mutable_consumer_id() {
  std::string* _s = _internal_mutable_consumer_id();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServicesRequest.consumer_id)
  return _s;
}
inline const std::string& ListServicesRequest::_internal_consumer_id() const {
  return _impl_.consumer_id_.Get();
}
inline void ListServicesRequest::_internal_set_consumer_id(const std::string& value) {
  
  _impl_.consumer_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServicesRequest::_internal_mutable_consumer_id() {
  
  return _impl_.consumer_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServicesRequest::release_consumer_id() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServicesRequest.consumer_id)
  return _impl_.consumer_id_.Release();
}
inline void ListServicesRequest::set_allocated_consumer_id(std::string* consumer_id) {
  if (consumer_id != nullptr) {
    
  } else {
    
  }
  _impl_.consumer_id_.SetAllocated(consumer_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.consumer_id_.IsDefault()) {
    _impl_.consumer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServicesRequest.consumer_id)
}

// -------------------------------------------------------------------

// ListServicesResponse

// repeated .google.api.servicemanagement.v1.ManagedService services = 1;
inline int ListServicesResponse::_internal_services_size() const {
  return _impl_.services_.size();
}
inline int ListServicesResponse::services_size() const {
  return _internal_services_size();
}
inline ::google::api::servicemanagement::v1::ManagedService* ListServicesResponse::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServicesResponse.services)
  return _impl_.services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ManagedService >*
ListServicesResponse::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:google.api.servicemanagement.v1.ListServicesResponse.services)
  return &_impl_.services_;
}
inline const ::google::api::servicemanagement::v1::ManagedService& ListServicesResponse::_internal_services(int index) const {
  return _impl_.services_.Get(index);
}
inline const ::google::api::servicemanagement::v1::ManagedService& ListServicesResponse::services(int index) const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServicesResponse.services)
  return _internal_services(index);
}
inline ::google::api::servicemanagement::v1::ManagedService* ListServicesResponse::_internal_add_services() {
  return _impl_.services_.Add();
}
inline ::google::api::servicemanagement::v1::ManagedService* ListServicesResponse::add_services() {
  ::google::api::servicemanagement::v1::ManagedService* _add = _internal_add_services();
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.ListServicesResponse.services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ManagedService >&
ListServicesResponse::services() const {
  // @@protoc_insertion_point(field_list:google.api.servicemanagement.v1.ListServicesResponse.services)
  return _impl_.services_;
}

// string next_page_token = 2;
inline void ListServicesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListServicesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServicesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServicesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServicesResponse.next_page_token)
}
inline std::string* ListServicesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServicesResponse.next_page_token)
  return _s;
}
inline const std::string& ListServicesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListServicesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServicesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServicesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServicesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListServicesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServicesResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetServiceRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetServiceRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& GetServiceRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GetServiceRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.GetServiceRequest.service_name)
}
inline std::string* GetServiceRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GetServiceRequest.service_name)
  return _s;
}
inline const std::string& GetServiceRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void GetServiceRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.GetServiceRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void GetServiceRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.GetServiceRequest.service_name)
}

// -------------------------------------------------------------------

// CreateServiceRequest

// .google.api.servicemanagement.v1.ManagedService service = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateServiceRequest::_internal_has_service() const {
  return this != internal_default_instance() && _impl_.service_ != nullptr;
}
inline bool CreateServiceRequest::has_service() const {
  return _internal_has_service();
}
inline const ::google::api::servicemanagement::v1::ManagedService& CreateServiceRequest::_internal_service() const {
  const ::google::api::servicemanagement::v1::ManagedService* p = _impl_.service_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::api::servicemanagement::v1::ManagedService&>(
      ::google::api::servicemanagement::v1::_ManagedService_default_instance_);
}
inline const ::google::api::servicemanagement::v1::ManagedService& CreateServiceRequest::service() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.CreateServiceRequest.service)
  return _internal_service();
}
inline void CreateServiceRequest::unsafe_arena_set_allocated_service(
    ::google::api::servicemanagement::v1::ManagedService* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_);
  }
  _impl_.service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.CreateServiceRequest.service)
}
inline ::google::api::servicemanagement::v1::ManagedService* CreateServiceRequest::release_service() {
  
  ::google::api::servicemanagement::v1::ManagedService* temp = _impl_.service_;
  _impl_.service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::api::servicemanagement::v1::ManagedService* CreateServiceRequest::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.CreateServiceRequest.service)
  
  ::google::api::servicemanagement::v1::ManagedService* temp = _impl_.service_;
  _impl_.service_ = nullptr;
  return temp;
}
inline ::google::api::servicemanagement::v1::ManagedService* CreateServiceRequest::_internal_mutable_service() {
  
  if (_impl_.service_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::api::servicemanagement::v1::ManagedService>(GetArenaForAllocation());
    _impl_.service_ = p;
  }
  return _impl_.service_;
}
inline ::google::api::servicemanagement::v1::ManagedService* CreateServiceRequest::mutable_service() {
  ::google::api::servicemanagement::v1::ManagedService* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.CreateServiceRequest.service)
  return _msg;
}
inline void CreateServiceRequest::set_allocated_service(::google::api::servicemanagement::v1::ManagedService* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_ = service;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.CreateServiceRequest.service)
}

// -------------------------------------------------------------------

// DeleteServiceRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void DeleteServiceRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& DeleteServiceRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.DeleteServiceRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteServiceRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.DeleteServiceRequest.service_name)
}
inline std::string* DeleteServiceRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.DeleteServiceRequest.service_name)
  return _s;
}
inline const std::string& DeleteServiceRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void DeleteServiceRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteServiceRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteServiceRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.DeleteServiceRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void DeleteServiceRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.DeleteServiceRequest.service_name)
}

// -------------------------------------------------------------------

// UndeleteServiceRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void UndeleteServiceRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& UndeleteServiceRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.UndeleteServiceRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UndeleteServiceRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.UndeleteServiceRequest.service_name)
}
inline std::string* UndeleteServiceRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.UndeleteServiceRequest.service_name)
  return _s;
}
inline const std::string& UndeleteServiceRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void UndeleteServiceRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UndeleteServiceRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UndeleteServiceRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.UndeleteServiceRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void UndeleteServiceRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.UndeleteServiceRequest.service_name)
}

// -------------------------------------------------------------------

// UndeleteServiceResponse

// .google.api.servicemanagement.v1.ManagedService service = 1;
inline bool UndeleteServiceResponse::_internal_has_service() const {
  return this != internal_default_instance() && _impl_.service_ != nullptr;
}
inline bool UndeleteServiceResponse::has_service() const {
  return _internal_has_service();
}
inline const ::google::api::servicemanagement::v1::ManagedService& UndeleteServiceResponse::_internal_service() const {
  const ::google::api::servicemanagement::v1::ManagedService* p = _impl_.service_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::api::servicemanagement::v1::ManagedService&>(
      ::google::api::servicemanagement::v1::_ManagedService_default_instance_);
}
inline const ::google::api::servicemanagement::v1::ManagedService& UndeleteServiceResponse::service() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.UndeleteServiceResponse.service)
  return _internal_service();
}
inline void UndeleteServiceResponse::unsafe_arena_set_allocated_service(
    ::google::api::servicemanagement::v1::ManagedService* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_);
  }
  _impl_.service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.UndeleteServiceResponse.service)
}
inline ::google::api::servicemanagement::v1::ManagedService* UndeleteServiceResponse::release_service() {
  
  ::google::api::servicemanagement::v1::ManagedService* temp = _impl_.service_;
  _impl_.service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::api::servicemanagement::v1::ManagedService* UndeleteServiceResponse::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.UndeleteServiceResponse.service)
  
  ::google::api::servicemanagement::v1::ManagedService* temp = _impl_.service_;
  _impl_.service_ = nullptr;
  return temp;
}
inline ::google::api::servicemanagement::v1::ManagedService* UndeleteServiceResponse::_internal_mutable_service() {
  
  if (_impl_.service_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::api::servicemanagement::v1::ManagedService>(GetArenaForAllocation());
    _impl_.service_ = p;
  }
  return _impl_.service_;
}
inline ::google::api::servicemanagement::v1::ManagedService* UndeleteServiceResponse::mutable_service() {
  ::google::api::servicemanagement::v1::ManagedService* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.UndeleteServiceResponse.service)
  return _msg;
}
inline void UndeleteServiceResponse::set_allocated_service(::google::api::servicemanagement::v1::ManagedService* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_ = service;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.UndeleteServiceResponse.service)
}

// -------------------------------------------------------------------

// GetServiceConfigRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetServiceConfigRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& GetServiceConfigRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GetServiceConfigRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceConfigRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.GetServiceConfigRequest.service_name)
}
inline std::string* GetServiceConfigRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GetServiceConfigRequest.service_name)
  return _s;
}
inline const std::string& GetServiceConfigRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void GetServiceConfigRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceConfigRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceConfigRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.GetServiceConfigRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void GetServiceConfigRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.GetServiceConfigRequest.service_name)
}

// string config_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void GetServiceConfigRequest::clear_config_id() {
  _impl_.config_id_.ClearToEmpty();
}
inline const std::string& GetServiceConfigRequest::config_id() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GetServiceConfigRequest.config_id)
  return _internal_config_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceConfigRequest::set_config_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.config_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.GetServiceConfigRequest.config_id)
}
inline std::string* GetServiceConfigRequest::mutable_config_id() {
  std::string* _s = _internal_mutable_config_id();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GetServiceConfigRequest.config_id)
  return _s;
}
inline const std::string& GetServiceConfigRequest::_internal_config_id() const {
  return _impl_.config_id_.Get();
}
inline void GetServiceConfigRequest::_internal_set_config_id(const std::string& value) {
  
  _impl_.config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceConfigRequest::_internal_mutable_config_id() {
  
  return _impl_.config_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceConfigRequest::release_config_id() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.GetServiceConfigRequest.config_id)
  return _impl_.config_id_.Release();
}
inline void GetServiceConfigRequest::set_allocated_config_id(std::string* config_id) {
  if (config_id != nullptr) {
    
  } else {
    
  }
  _impl_.config_id_.SetAllocated(config_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_id_.IsDefault()) {
    _impl_.config_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.GetServiceConfigRequest.config_id)
}

// .google.api.servicemanagement.v1.GetServiceConfigRequest.ConfigView view = 3;
inline void GetServiceConfigRequest::clear_view() {
  _impl_.view_ = 0;
}
inline ::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView GetServiceConfigRequest::_internal_view() const {
  return static_cast< ::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView >(_impl_.view_);
}
inline ::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView GetServiceConfigRequest::view() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GetServiceConfigRequest.view)
  return _internal_view();
}
inline void GetServiceConfigRequest::_internal_set_view(::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView value) {
  
  _impl_.view_ = value;
}
inline void GetServiceConfigRequest::set_view(::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.GetServiceConfigRequest.view)
}

// -------------------------------------------------------------------

// ListServiceConfigsRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void ListServiceConfigsRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ListServiceConfigsRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceConfigsRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceConfigsRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServiceConfigsRequest.service_name)
}
inline std::string* ListServiceConfigsRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServiceConfigsRequest.service_name)
  return _s;
}
inline const std::string& ListServiceConfigsRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ListServiceConfigsRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceConfigsRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceConfigsRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServiceConfigsRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void ListServiceConfigsRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServiceConfigsRequest.service_name)
}

// string page_token = 2;
inline void ListServiceConfigsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListServiceConfigsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceConfigsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceConfigsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServiceConfigsRequest.page_token)
}
inline std::string* ListServiceConfigsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServiceConfigsRequest.page_token)
  return _s;
}
inline const std::string& ListServiceConfigsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListServiceConfigsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceConfigsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceConfigsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServiceConfigsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListServiceConfigsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServiceConfigsRequest.page_token)
}

// int32 page_size = 3;
inline void ListServiceConfigsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListServiceConfigsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListServiceConfigsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceConfigsRequest.page_size)
  return _internal_page_size();
}
inline void ListServiceConfigsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListServiceConfigsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServiceConfigsRequest.page_size)
}

// -------------------------------------------------------------------

// ListServiceConfigsResponse

// repeated .google.api.Service service_configs = 1;
inline int ListServiceConfigsResponse::_internal_service_configs_size() const {
  return _impl_.service_configs_.size();
}
inline int ListServiceConfigsResponse::service_configs_size() const {
  return _internal_service_configs_size();
}
inline ::google::api::Service* ListServiceConfigsResponse::mutable_service_configs(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServiceConfigsResponse.service_configs)
  return _impl_.service_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::Service >*
ListServiceConfigsResponse::mutable_service_configs() {
  // @@protoc_insertion_point(field_mutable_list:google.api.servicemanagement.v1.ListServiceConfigsResponse.service_configs)
  return &_impl_.service_configs_;
}
inline const ::google::api::Service& ListServiceConfigsResponse::_internal_service_configs(int index) const {
  return _impl_.service_configs_.Get(index);
}
inline const ::google::api::Service& ListServiceConfigsResponse::service_configs(int index) const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceConfigsResponse.service_configs)
  return _internal_service_configs(index);
}
inline ::google::api::Service* ListServiceConfigsResponse::_internal_add_service_configs() {
  return _impl_.service_configs_.Add();
}
inline ::google::api::Service* ListServiceConfigsResponse::add_service_configs() {
  ::google::api::Service* _add = _internal_add_service_configs();
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.ListServiceConfigsResponse.service_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::Service >&
ListServiceConfigsResponse::service_configs() const {
  // @@protoc_insertion_point(field_list:google.api.servicemanagement.v1.ListServiceConfigsResponse.service_configs)
  return _impl_.service_configs_;
}

// string next_page_token = 2;
inline void ListServiceConfigsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListServiceConfigsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceConfigsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceConfigsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServiceConfigsResponse.next_page_token)
}
inline std::string* ListServiceConfigsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServiceConfigsResponse.next_page_token)
  return _s;
}
inline const std::string& ListServiceConfigsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListServiceConfigsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceConfigsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceConfigsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServiceConfigsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListServiceConfigsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServiceConfigsResponse.next_page_token)
}

// -------------------------------------------------------------------

// CreateServiceConfigRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void CreateServiceConfigRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& CreateServiceConfigRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateServiceConfigRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_name)
}
inline std::string* CreateServiceConfigRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_name)
  return _s;
}
inline const std::string& CreateServiceConfigRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void CreateServiceConfigRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateServiceConfigRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateServiceConfigRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void CreateServiceConfigRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_name)
}

// .google.api.Service service_config = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateServiceConfigRequest::_internal_has_service_config() const {
  return this != internal_default_instance() && _impl_.service_config_ != nullptr;
}
inline bool CreateServiceConfigRequest::has_service_config() const {
  return _internal_has_service_config();
}
inline const ::google::api::Service& CreateServiceConfigRequest::_internal_service_config() const {
  const ::google::api::Service* p = _impl_.service_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::api::Service&>(
      ::google::api::_Service_default_instance_);
}
inline const ::google::api::Service& CreateServiceConfigRequest::service_config() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_config)
  return _internal_service_config();
}
inline void CreateServiceConfigRequest::unsafe_arena_set_allocated_service_config(
    ::google::api::Service* service_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_config_);
  }
  _impl_.service_config_ = service_config;
  if (service_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_config)
}
inline ::google::api::Service* CreateServiceConfigRequest::release_service_config() {
  
  ::google::api::Service* temp = _impl_.service_config_;
  _impl_.service_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::api::Service* CreateServiceConfigRequest::unsafe_arena_release_service_config() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_config)
  
  ::google::api::Service* temp = _impl_.service_config_;
  _impl_.service_config_ = nullptr;
  return temp;
}
inline ::google::api::Service* CreateServiceConfigRequest::_internal_mutable_service_config() {
  
  if (_impl_.service_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::api::Service>(GetArenaForAllocation());
    _impl_.service_config_ = p;
  }
  return _impl_.service_config_;
}
inline ::google::api::Service* CreateServiceConfigRequest::mutable_service_config() {
  ::google::api::Service* _msg = _internal_mutable_service_config();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_config)
  return _msg;
}
inline void CreateServiceConfigRequest::set_allocated_service_config(::google::api::Service* service_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_config_);
  }
  if (service_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_config));
    if (message_arena != submessage_arena) {
      service_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_config_ = service_config;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.CreateServiceConfigRequest.service_config)
}

// -------------------------------------------------------------------

// SubmitConfigSourceRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void SubmitConfigSourceRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& SubmitConfigSourceRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.SubmitConfigSourceRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubmitConfigSourceRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.SubmitConfigSourceRequest.service_name)
}
inline std::string* SubmitConfigSourceRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.SubmitConfigSourceRequest.service_name)
  return _s;
}
inline const std::string& SubmitConfigSourceRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void SubmitConfigSourceRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SubmitConfigSourceRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SubmitConfigSourceRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.SubmitConfigSourceRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void SubmitConfigSourceRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.SubmitConfigSourceRequest.service_name)
}

// .google.api.servicemanagement.v1.ConfigSource config_source = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool SubmitConfigSourceRequest::_internal_has_config_source() const {
  return this != internal_default_instance() && _impl_.config_source_ != nullptr;
}
inline bool SubmitConfigSourceRequest::has_config_source() const {
  return _internal_has_config_source();
}
inline const ::google::api::servicemanagement::v1::ConfigSource& SubmitConfigSourceRequest::_internal_config_source() const {
  const ::google::api::servicemanagement::v1::ConfigSource* p = _impl_.config_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::api::servicemanagement::v1::ConfigSource&>(
      ::google::api::servicemanagement::v1::_ConfigSource_default_instance_);
}
inline const ::google::api::servicemanagement::v1::ConfigSource& SubmitConfigSourceRequest::config_source() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.SubmitConfigSourceRequest.config_source)
  return _internal_config_source();
}
inline void SubmitConfigSourceRequest::unsafe_arena_set_allocated_config_source(
    ::google::api::servicemanagement::v1::ConfigSource* config_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_source_);
  }
  _impl_.config_source_ = config_source;
  if (config_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.SubmitConfigSourceRequest.config_source)
}
inline ::google::api::servicemanagement::v1::ConfigSource* SubmitConfigSourceRequest::release_config_source() {
  
  ::google::api::servicemanagement::v1::ConfigSource* temp = _impl_.config_source_;
  _impl_.config_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::api::servicemanagement::v1::ConfigSource* SubmitConfigSourceRequest::unsafe_arena_release_config_source() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.SubmitConfigSourceRequest.config_source)
  
  ::google::api::servicemanagement::v1::ConfigSource* temp = _impl_.config_source_;
  _impl_.config_source_ = nullptr;
  return temp;
}
inline ::google::api::servicemanagement::v1::ConfigSource* SubmitConfigSourceRequest::_internal_mutable_config_source() {
  
  if (_impl_.config_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::api::servicemanagement::v1::ConfigSource>(GetArenaForAllocation());
    _impl_.config_source_ = p;
  }
  return _impl_.config_source_;
}
inline ::google::api::servicemanagement::v1::ConfigSource* SubmitConfigSourceRequest::mutable_config_source() {
  ::google::api::servicemanagement::v1::ConfigSource* _msg = _internal_mutable_config_source();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.SubmitConfigSourceRequest.config_source)
  return _msg;
}
inline void SubmitConfigSourceRequest::set_allocated_config_source(::google::api::servicemanagement::v1::ConfigSource* config_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_source_);
  }
  if (config_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_source));
    if (message_arena != submessage_arena) {
      config_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_source_ = config_source;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.SubmitConfigSourceRequest.config_source)
}

// bool validate_only = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void SubmitConfigSourceRequest::clear_validate_only() {
  _impl_.validate_only_ = false;
}
inline bool SubmitConfigSourceRequest::_internal_validate_only() const {
  return _impl_.validate_only_;
}
inline bool SubmitConfigSourceRequest::validate_only() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.SubmitConfigSourceRequest.validate_only)
  return _internal_validate_only();
}
inline void SubmitConfigSourceRequest::_internal_set_validate_only(bool value) {
  
  _impl_.validate_only_ = value;
}
inline void SubmitConfigSourceRequest::set_validate_only(bool value) {
  _internal_set_validate_only(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.SubmitConfigSourceRequest.validate_only)
}

// -------------------------------------------------------------------

// SubmitConfigSourceResponse

// .google.api.Service service_config = 1;
inline bool SubmitConfigSourceResponse::_internal_has_service_config() const {
  return this != internal_default_instance() && _impl_.service_config_ != nullptr;
}
inline bool SubmitConfigSourceResponse::has_service_config() const {
  return _internal_has_service_config();
}
inline const ::google::api::Service& SubmitConfigSourceResponse::_internal_service_config() const {
  const ::google::api::Service* p = _impl_.service_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::api::Service&>(
      ::google::api::_Service_default_instance_);
}
inline const ::google::api::Service& SubmitConfigSourceResponse::service_config() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.SubmitConfigSourceResponse.service_config)
  return _internal_service_config();
}
inline void SubmitConfigSourceResponse::unsafe_arena_set_allocated_service_config(
    ::google::api::Service* service_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_config_);
  }
  _impl_.service_config_ = service_config;
  if (service_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.SubmitConfigSourceResponse.service_config)
}
inline ::google::api::Service* SubmitConfigSourceResponse::release_service_config() {
  
  ::google::api::Service* temp = _impl_.service_config_;
  _impl_.service_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::api::Service* SubmitConfigSourceResponse::unsafe_arena_release_service_config() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.SubmitConfigSourceResponse.service_config)
  
  ::google::api::Service* temp = _impl_.service_config_;
  _impl_.service_config_ = nullptr;
  return temp;
}
inline ::google::api::Service* SubmitConfigSourceResponse::_internal_mutable_service_config() {
  
  if (_impl_.service_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::api::Service>(GetArenaForAllocation());
    _impl_.service_config_ = p;
  }
  return _impl_.service_config_;
}
inline ::google::api::Service* SubmitConfigSourceResponse::mutable_service_config() {
  ::google::api::Service* _msg = _internal_mutable_service_config();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.SubmitConfigSourceResponse.service_config)
  return _msg;
}
inline void SubmitConfigSourceResponse::set_allocated_service_config(::google::api::Service* service_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_config_);
  }
  if (service_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_config));
    if (message_arena != submessage_arena) {
      service_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_config_ = service_config;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.SubmitConfigSourceResponse.service_config)
}

// -------------------------------------------------------------------

// CreateServiceRolloutRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void CreateServiceRolloutRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& CreateServiceRolloutRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.CreateServiceRolloutRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateServiceRolloutRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.CreateServiceRolloutRequest.service_name)
}
inline std::string* CreateServiceRolloutRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.CreateServiceRolloutRequest.service_name)
  return _s;
}
inline const std::string& CreateServiceRolloutRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void CreateServiceRolloutRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateServiceRolloutRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateServiceRolloutRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.CreateServiceRolloutRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void CreateServiceRolloutRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.CreateServiceRolloutRequest.service_name)
}

// .google.api.servicemanagement.v1.Rollout rollout = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateServiceRolloutRequest::_internal_has_rollout() const {
  return this != internal_default_instance() && _impl_.rollout_ != nullptr;
}
inline bool CreateServiceRolloutRequest::has_rollout() const {
  return _internal_has_rollout();
}
inline const ::google::api::servicemanagement::v1::Rollout& CreateServiceRolloutRequest::_internal_rollout() const {
  const ::google::api::servicemanagement::v1::Rollout* p = _impl_.rollout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::api::servicemanagement::v1::Rollout&>(
      ::google::api::servicemanagement::v1::_Rollout_default_instance_);
}
inline const ::google::api::servicemanagement::v1::Rollout& CreateServiceRolloutRequest::rollout() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.CreateServiceRolloutRequest.rollout)
  return _internal_rollout();
}
inline void CreateServiceRolloutRequest::unsafe_arena_set_allocated_rollout(
    ::google::api::servicemanagement::v1::Rollout* rollout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rollout_);
  }
  _impl_.rollout_ = rollout;
  if (rollout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.CreateServiceRolloutRequest.rollout)
}
inline ::google::api::servicemanagement::v1::Rollout* CreateServiceRolloutRequest::release_rollout() {
  
  ::google::api::servicemanagement::v1::Rollout* temp = _impl_.rollout_;
  _impl_.rollout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::api::servicemanagement::v1::Rollout* CreateServiceRolloutRequest::unsafe_arena_release_rollout() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.CreateServiceRolloutRequest.rollout)
  
  ::google::api::servicemanagement::v1::Rollout* temp = _impl_.rollout_;
  _impl_.rollout_ = nullptr;
  return temp;
}
inline ::google::api::servicemanagement::v1::Rollout* CreateServiceRolloutRequest::_internal_mutable_rollout() {
  
  if (_impl_.rollout_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::api::servicemanagement::v1::Rollout>(GetArenaForAllocation());
    _impl_.rollout_ = p;
  }
  return _impl_.rollout_;
}
inline ::google::api::servicemanagement::v1::Rollout* CreateServiceRolloutRequest::mutable_rollout() {
  ::google::api::servicemanagement::v1::Rollout* _msg = _internal_mutable_rollout();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.CreateServiceRolloutRequest.rollout)
  return _msg;
}
inline void CreateServiceRolloutRequest::set_allocated_rollout(::google::api::servicemanagement::v1::Rollout* rollout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rollout_);
  }
  if (rollout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rollout));
    if (message_arena != submessage_arena) {
      rollout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rollout, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rollout_ = rollout;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.CreateServiceRolloutRequest.rollout)
}

// -------------------------------------------------------------------

// ListServiceRolloutsRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void ListServiceRolloutsRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ListServiceRolloutsRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceRolloutsRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceRolloutsRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServiceRolloutsRequest.service_name)
}
inline std::string* ListServiceRolloutsRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServiceRolloutsRequest.service_name)
  return _s;
}
inline const std::string& ListServiceRolloutsRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ListServiceRolloutsRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceRolloutsRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceRolloutsRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServiceRolloutsRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void ListServiceRolloutsRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServiceRolloutsRequest.service_name)
}

// string page_token = 2;
inline void ListServiceRolloutsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListServiceRolloutsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceRolloutsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceRolloutsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServiceRolloutsRequest.page_token)
}
inline std::string* ListServiceRolloutsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServiceRolloutsRequest.page_token)
  return _s;
}
inline const std::string& ListServiceRolloutsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListServiceRolloutsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceRolloutsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceRolloutsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServiceRolloutsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListServiceRolloutsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServiceRolloutsRequest.page_token)
}

// int32 page_size = 3;
inline void ListServiceRolloutsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListServiceRolloutsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListServiceRolloutsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceRolloutsRequest.page_size)
  return _internal_page_size();
}
inline void ListServiceRolloutsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListServiceRolloutsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServiceRolloutsRequest.page_size)
}

// string filter = 4 [(.google.api.field_behavior) = REQUIRED];
inline void ListServiceRolloutsRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& ListServiceRolloutsRequest::filter() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceRolloutsRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceRolloutsRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServiceRolloutsRequest.filter)
}
inline std::string* ListServiceRolloutsRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServiceRolloutsRequest.filter)
  return _s;
}
inline const std::string& ListServiceRolloutsRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void ListServiceRolloutsRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceRolloutsRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceRolloutsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServiceRolloutsRequest.filter)
  return _impl_.filter_.Release();
}
inline void ListServiceRolloutsRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServiceRolloutsRequest.filter)
}

// -------------------------------------------------------------------

// ListServiceRolloutsResponse

// repeated .google.api.servicemanagement.v1.Rollout rollouts = 1;
inline int ListServiceRolloutsResponse::_internal_rollouts_size() const {
  return _impl_.rollouts_.size();
}
inline int ListServiceRolloutsResponse::rollouts_size() const {
  return _internal_rollouts_size();
}
inline ::google::api::servicemanagement::v1::Rollout* ListServiceRolloutsResponse::mutable_rollouts(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServiceRolloutsResponse.rollouts)
  return _impl_.rollouts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Rollout >*
ListServiceRolloutsResponse::mutable_rollouts() {
  // @@protoc_insertion_point(field_mutable_list:google.api.servicemanagement.v1.ListServiceRolloutsResponse.rollouts)
  return &_impl_.rollouts_;
}
inline const ::google::api::servicemanagement::v1::Rollout& ListServiceRolloutsResponse::_internal_rollouts(int index) const {
  return _impl_.rollouts_.Get(index);
}
inline const ::google::api::servicemanagement::v1::Rollout& ListServiceRolloutsResponse::rollouts(int index) const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceRolloutsResponse.rollouts)
  return _internal_rollouts(index);
}
inline ::google::api::servicemanagement::v1::Rollout* ListServiceRolloutsResponse::_internal_add_rollouts() {
  return _impl_.rollouts_.Add();
}
inline ::google::api::servicemanagement::v1::Rollout* ListServiceRolloutsResponse::add_rollouts() {
  ::google::api::servicemanagement::v1::Rollout* _add = _internal_add_rollouts();
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.ListServiceRolloutsResponse.rollouts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Rollout >&
ListServiceRolloutsResponse::rollouts() const {
  // @@protoc_insertion_point(field_list:google.api.servicemanagement.v1.ListServiceRolloutsResponse.rollouts)
  return _impl_.rollouts_;
}

// string next_page_token = 2;
inline void ListServiceRolloutsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListServiceRolloutsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ListServiceRolloutsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceRolloutsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ListServiceRolloutsResponse.next_page_token)
}
inline std::string* ListServiceRolloutsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ListServiceRolloutsResponse.next_page_token)
  return _s;
}
inline const std::string& ListServiceRolloutsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListServiceRolloutsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceRolloutsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceRolloutsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ListServiceRolloutsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListServiceRolloutsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ListServiceRolloutsResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetServiceRolloutRequest

// string service_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetServiceRolloutRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& GetServiceRolloutRequest::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GetServiceRolloutRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceRolloutRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.GetServiceRolloutRequest.service_name)
}
inline std::string* GetServiceRolloutRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GetServiceRolloutRequest.service_name)
  return _s;
}
inline const std::string& GetServiceRolloutRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void GetServiceRolloutRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceRolloutRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceRolloutRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.GetServiceRolloutRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void GetServiceRolloutRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.GetServiceRolloutRequest.service_name)
}

// string rollout_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void GetServiceRolloutRequest::clear_rollout_id() {
  _impl_.rollout_id_.ClearToEmpty();
}
inline const std::string& GetServiceRolloutRequest::rollout_id() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GetServiceRolloutRequest.rollout_id)
  return _internal_rollout_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceRolloutRequest::set_rollout_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rollout_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.GetServiceRolloutRequest.rollout_id)
}
inline std::string* GetServiceRolloutRequest::mutable_rollout_id() {
  std::string* _s = _internal_mutable_rollout_id();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GetServiceRolloutRequest.rollout_id)
  return _s;
}
inline const std::string& GetServiceRolloutRequest::_internal_rollout_id() const {
  return _impl_.rollout_id_.Get();
}
inline void GetServiceRolloutRequest::_internal_set_rollout_id(const std::string& value) {
  
  _impl_.rollout_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceRolloutRequest::_internal_mutable_rollout_id() {
  
  return _impl_.rollout_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceRolloutRequest::release_rollout_id() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.GetServiceRolloutRequest.rollout_id)
  return _impl_.rollout_id_.Release();
}
inline void GetServiceRolloutRequest::set_allocated_rollout_id(std::string* rollout_id) {
  if (rollout_id != nullptr) {
    
  } else {
    
  }
  _impl_.rollout_id_.SetAllocated(rollout_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rollout_id_.IsDefault()) {
    _impl_.rollout_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.GetServiceRolloutRequest.rollout_id)
}

// -------------------------------------------------------------------

// GenerateConfigReportRequest

// .google.protobuf.Any new_config = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool GenerateConfigReportRequest::_internal_has_new_config() const {
  return this != internal_default_instance() && _impl_.new_config_ != nullptr;
}
inline bool GenerateConfigReportRequest::has_new_config() const {
  return _internal_has_new_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GenerateConfigReportRequest::_internal_new_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.new_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GenerateConfigReportRequest::new_config() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GenerateConfigReportRequest.new_config)
  return _internal_new_config();
}
inline void GenerateConfigReportRequest::unsafe_arena_set_allocated_new_config(
    ::PROTOBUF_NAMESPACE_ID::Any* new_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_config_);
  }
  _impl_.new_config_ = new_config;
  if (new_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.GenerateConfigReportRequest.new_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GenerateConfigReportRequest::release_new_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.new_config_;
  _impl_.new_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GenerateConfigReportRequest::unsafe_arena_release_new_config() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.GenerateConfigReportRequest.new_config)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.new_config_;
  _impl_.new_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GenerateConfigReportRequest::_internal_mutable_new_config() {
  
  if (_impl_.new_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.new_config_ = p;
  }
  return _impl_.new_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GenerateConfigReportRequest::mutable_new_config() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_new_config();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GenerateConfigReportRequest.new_config)
  return _msg;
}
inline void GenerateConfigReportRequest::set_allocated_new_config(::PROTOBUF_NAMESPACE_ID::Any* new_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_config_);
  }
  if (new_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_config));
    if (message_arena != submessage_arena) {
      new_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.new_config_ = new_config;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.GenerateConfigReportRequest.new_config)
}

// .google.protobuf.Any old_config = 2 [(.google.api.field_behavior) = OPTIONAL];
inline bool GenerateConfigReportRequest::_internal_has_old_config() const {
  return this != internal_default_instance() && _impl_.old_config_ != nullptr;
}
inline bool GenerateConfigReportRequest::has_old_config() const {
  return _internal_has_old_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GenerateConfigReportRequest::_internal_old_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.old_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GenerateConfigReportRequest::old_config() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GenerateConfigReportRequest.old_config)
  return _internal_old_config();
}
inline void GenerateConfigReportRequest::unsafe_arena_set_allocated_old_config(
    ::PROTOBUF_NAMESPACE_ID::Any* old_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_config_);
  }
  _impl_.old_config_ = old_config;
  if (old_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.GenerateConfigReportRequest.old_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GenerateConfigReportRequest::release_old_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.old_config_;
  _impl_.old_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GenerateConfigReportRequest::unsafe_arena_release_old_config() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.GenerateConfigReportRequest.old_config)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.old_config_;
  _impl_.old_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GenerateConfigReportRequest::_internal_mutable_old_config() {
  
  if (_impl_.old_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.old_config_ = p;
  }
  return _impl_.old_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GenerateConfigReportRequest::mutable_old_config() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_old_config();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GenerateConfigReportRequest.old_config)
  return _msg;
}
inline void GenerateConfigReportRequest::set_allocated_old_config(::PROTOBUF_NAMESPACE_ID::Any* old_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_config_);
  }
  if (old_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_config));
    if (message_arena != submessage_arena) {
      old_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.old_config_ = old_config;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.GenerateConfigReportRequest.old_config)
}

// -------------------------------------------------------------------

// GenerateConfigReportResponse

// string service_name = 1;
inline void GenerateConfigReportResponse::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& GenerateConfigReportResponse::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GenerateConfigReportResponse.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateConfigReportResponse::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.GenerateConfigReportResponse.service_name)
}
inline std::string* GenerateConfigReportResponse::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GenerateConfigReportResponse.service_name)
  return _s;
}
inline const std::string& GenerateConfigReportResponse::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void GenerateConfigReportResponse::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateConfigReportResponse::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateConfigReportResponse::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.GenerateConfigReportResponse.service_name)
  return _impl_.service_name_.Release();
}
inline void GenerateConfigReportResponse::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.GenerateConfigReportResponse.service_name)
}

// string id = 2;
inline void GenerateConfigReportResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GenerateConfigReportResponse::id() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GenerateConfigReportResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateConfigReportResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.GenerateConfigReportResponse.id)
}
inline std::string* GenerateConfigReportResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GenerateConfigReportResponse.id)
  return _s;
}
inline const std::string& GenerateConfigReportResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GenerateConfigReportResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateConfigReportResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateConfigReportResponse::release_id() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.GenerateConfigReportResponse.id)
  return _impl_.id_.Release();
}
inline void GenerateConfigReportResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.GenerateConfigReportResponse.id)
}

// repeated .google.api.servicemanagement.v1.ChangeReport change_reports = 3;
inline int GenerateConfigReportResponse::_internal_change_reports_size() const {
  return _impl_.change_reports_.size();
}
inline int GenerateConfigReportResponse::change_reports_size() const {
  return _internal_change_reports_size();
}
inline ::google::api::servicemanagement::v1::ChangeReport* GenerateConfigReportResponse::mutable_change_reports(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GenerateConfigReportResponse.change_reports)
  return _impl_.change_reports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ChangeReport >*
GenerateConfigReportResponse::mutable_change_reports() {
  // @@protoc_insertion_point(field_mutable_list:google.api.servicemanagement.v1.GenerateConfigReportResponse.change_reports)
  return &_impl_.change_reports_;
}
inline const ::google::api::servicemanagement::v1::ChangeReport& GenerateConfigReportResponse::_internal_change_reports(int index) const {
  return _impl_.change_reports_.Get(index);
}
inline const ::google::api::servicemanagement::v1::ChangeReport& GenerateConfigReportResponse::change_reports(int index) const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GenerateConfigReportResponse.change_reports)
  return _internal_change_reports(index);
}
inline ::google::api::servicemanagement::v1::ChangeReport* GenerateConfigReportResponse::_internal_add_change_reports() {
  return _impl_.change_reports_.Add();
}
inline ::google::api::servicemanagement::v1::ChangeReport* GenerateConfigReportResponse::add_change_reports() {
  ::google::api::servicemanagement::v1::ChangeReport* _add = _internal_add_change_reports();
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.GenerateConfigReportResponse.change_reports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ChangeReport >&
GenerateConfigReportResponse::change_reports() const {
  // @@protoc_insertion_point(field_list:google.api.servicemanagement.v1.GenerateConfigReportResponse.change_reports)
  return _impl_.change_reports_;
}

// repeated .google.api.servicemanagement.v1.Diagnostic diagnostics = 4;
inline int GenerateConfigReportResponse::_internal_diagnostics_size() const {
  return _impl_.diagnostics_.size();
}
inline int GenerateConfigReportResponse::diagnostics_size() const {
  return _internal_diagnostics_size();
}
inline ::google::api::servicemanagement::v1::Diagnostic* GenerateConfigReportResponse::mutable_diagnostics(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.GenerateConfigReportResponse.diagnostics)
  return _impl_.diagnostics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Diagnostic >*
GenerateConfigReportResponse::mutable_diagnostics() {
  // @@protoc_insertion_point(field_mutable_list:google.api.servicemanagement.v1.GenerateConfigReportResponse.diagnostics)
  return &_impl_.diagnostics_;
}
inline const ::google::api::servicemanagement::v1::Diagnostic& GenerateConfigReportResponse::_internal_diagnostics(int index) const {
  return _impl_.diagnostics_.Get(index);
}
inline const ::google::api::servicemanagement::v1::Diagnostic& GenerateConfigReportResponse::diagnostics(int index) const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.GenerateConfigReportResponse.diagnostics)
  return _internal_diagnostics(index);
}
inline ::google::api::servicemanagement::v1::Diagnostic* GenerateConfigReportResponse::_internal_add_diagnostics() {
  return _impl_.diagnostics_.Add();
}
inline ::google::api::servicemanagement::v1::Diagnostic* GenerateConfigReportResponse::add_diagnostics() {
  ::google::api::servicemanagement::v1::Diagnostic* _add = _internal_add_diagnostics();
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.GenerateConfigReportResponse.diagnostics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::Diagnostic >&
GenerateConfigReportResponse::diagnostics() const {
  // @@protoc_insertion_point(field_list:google.api.servicemanagement.v1.GenerateConfigReportResponse.diagnostics)
  return _impl_.diagnostics_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace servicemanagement
}  // namespace api
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView>() {
  return ::google::api::servicemanagement::v1::GetServiceConfigRequest_ConfigView_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fapi_2fservicemanagement_2fv1_2fservicemanager_2eproto
