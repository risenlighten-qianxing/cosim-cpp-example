// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/api/servicemanagement/v1/resources.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/config_change.pb.h"
#include "google/api/field_behavior.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
namespace google {
namespace api {
namespace servicemanagement {
namespace v1 {
class ChangeReport;
struct ChangeReportDefaultTypeInternal;
extern ChangeReportDefaultTypeInternal _ChangeReport_default_instance_;
class ConfigFile;
struct ConfigFileDefaultTypeInternal;
extern ConfigFileDefaultTypeInternal _ConfigFile_default_instance_;
class ConfigRef;
struct ConfigRefDefaultTypeInternal;
extern ConfigRefDefaultTypeInternal _ConfigRef_default_instance_;
class ConfigSource;
struct ConfigSourceDefaultTypeInternal;
extern ConfigSourceDefaultTypeInternal _ConfigSource_default_instance_;
class Diagnostic;
struct DiagnosticDefaultTypeInternal;
extern DiagnosticDefaultTypeInternal _Diagnostic_default_instance_;
class ManagedService;
struct ManagedServiceDefaultTypeInternal;
extern ManagedServiceDefaultTypeInternal _ManagedService_default_instance_;
class OperationMetadata;
struct OperationMetadataDefaultTypeInternal;
extern OperationMetadataDefaultTypeInternal _OperationMetadata_default_instance_;
class OperationMetadata_Step;
struct OperationMetadata_StepDefaultTypeInternal;
extern OperationMetadata_StepDefaultTypeInternal _OperationMetadata_Step_default_instance_;
class Rollout;
struct RolloutDefaultTypeInternal;
extern RolloutDefaultTypeInternal _Rollout_default_instance_;
class Rollout_DeleteServiceStrategy;
struct Rollout_DeleteServiceStrategyDefaultTypeInternal;
extern Rollout_DeleteServiceStrategyDefaultTypeInternal _Rollout_DeleteServiceStrategy_default_instance_;
class Rollout_TrafficPercentStrategy;
struct Rollout_TrafficPercentStrategyDefaultTypeInternal;
extern Rollout_TrafficPercentStrategyDefaultTypeInternal _Rollout_TrafficPercentStrategy_default_instance_;
class Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse;
struct Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUseDefaultTypeInternal;
extern Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUseDefaultTypeInternal _Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace servicemanagement
}  // namespace api
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::api::servicemanagement::v1::ChangeReport* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ChangeReport>(Arena*);
template<> ::google::api::servicemanagement::v1::ConfigFile* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ConfigFile>(Arena*);
template<> ::google::api::servicemanagement::v1::ConfigRef* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ConfigRef>(Arena*);
template<> ::google::api::servicemanagement::v1::ConfigSource* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ConfigSource>(Arena*);
template<> ::google::api::servicemanagement::v1::Diagnostic* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::Diagnostic>(Arena*);
template<> ::google::api::servicemanagement::v1::ManagedService* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::ManagedService>(Arena*);
template<> ::google::api::servicemanagement::v1::OperationMetadata* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::OperationMetadata>(Arena*);
template<> ::google::api::servicemanagement::v1::OperationMetadata_Step* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::OperationMetadata_Step>(Arena*);
template<> ::google::api::servicemanagement::v1::Rollout* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::Rollout>(Arena*);
template<> ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy>(Arena*);
template<> ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy>(Arena*);
template<> ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse* Arena::CreateMaybeMessage<::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace api {
namespace servicemanagement {
namespace v1 {

enum OperationMetadata_Status : int {
  OperationMetadata_Status_STATUS_UNSPECIFIED = 0,
  OperationMetadata_Status_DONE = 1,
  OperationMetadata_Status_NOT_STARTED = 2,
  OperationMetadata_Status_IN_PROGRESS = 3,
  OperationMetadata_Status_FAILED = 4,
  OperationMetadata_Status_CANCELLED = 5,
  OperationMetadata_Status_OperationMetadata_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OperationMetadata_Status_OperationMetadata_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OperationMetadata_Status_IsValid(int value);
constexpr OperationMetadata_Status OperationMetadata_Status_Status_MIN = OperationMetadata_Status_STATUS_UNSPECIFIED;
constexpr OperationMetadata_Status OperationMetadata_Status_Status_MAX = OperationMetadata_Status_CANCELLED;
constexpr int OperationMetadata_Status_Status_ARRAYSIZE = OperationMetadata_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationMetadata_Status_descriptor();
template<typename T>
inline const std::string& OperationMetadata_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationMetadata_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationMetadata_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperationMetadata_Status_descriptor(), enum_t_value);
}
inline bool OperationMetadata_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperationMetadata_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperationMetadata_Status>(
    OperationMetadata_Status_descriptor(), name, value);
}
enum Diagnostic_Kind : int {
  Diagnostic_Kind_WARNING = 0,
  Diagnostic_Kind_ERROR = 1,
  Diagnostic_Kind_Diagnostic_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Diagnostic_Kind_Diagnostic_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Diagnostic_Kind_IsValid(int value);
constexpr Diagnostic_Kind Diagnostic_Kind_Kind_MIN = Diagnostic_Kind_WARNING;
constexpr Diagnostic_Kind Diagnostic_Kind_Kind_MAX = Diagnostic_Kind_ERROR;
constexpr int Diagnostic_Kind_Kind_ARRAYSIZE = Diagnostic_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Diagnostic_Kind_descriptor();
template<typename T>
inline const std::string& Diagnostic_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Diagnostic_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Diagnostic_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Diagnostic_Kind_descriptor(), enum_t_value);
}
inline bool Diagnostic_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Diagnostic_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Diagnostic_Kind>(
    Diagnostic_Kind_descriptor(), name, value);
}
enum ConfigFile_FileType : int {
  ConfigFile_FileType_FILE_TYPE_UNSPECIFIED = 0,
  ConfigFile_FileType_SERVICE_CONFIG_YAML = 1,
  ConfigFile_FileType_OPEN_API_JSON = 2,
  ConfigFile_FileType_OPEN_API_YAML = 3,
  ConfigFile_FileType_FILE_DESCRIPTOR_SET_PROTO = 4,
  ConfigFile_FileType_PROTO_FILE = 6,
  ConfigFile_FileType_ConfigFile_FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConfigFile_FileType_ConfigFile_FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConfigFile_FileType_IsValid(int value);
constexpr ConfigFile_FileType ConfigFile_FileType_FileType_MIN = ConfigFile_FileType_FILE_TYPE_UNSPECIFIED;
constexpr ConfigFile_FileType ConfigFile_FileType_FileType_MAX = ConfigFile_FileType_PROTO_FILE;
constexpr int ConfigFile_FileType_FileType_ARRAYSIZE = ConfigFile_FileType_FileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConfigFile_FileType_descriptor();
template<typename T>
inline const std::string& ConfigFile_FileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConfigFile_FileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConfigFile_FileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConfigFile_FileType_descriptor(), enum_t_value);
}
inline bool ConfigFile_FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigFile_FileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConfigFile_FileType>(
    ConfigFile_FileType_descriptor(), name, value);
}
enum Rollout_RolloutStatus : int {
  Rollout_RolloutStatus_ROLLOUT_STATUS_UNSPECIFIED = 0,
  Rollout_RolloutStatus_IN_PROGRESS = 1,
  Rollout_RolloutStatus_SUCCESS = 2,
  Rollout_RolloutStatus_CANCELLED = 3,
  Rollout_RolloutStatus_FAILED = 4,
  Rollout_RolloutStatus_PENDING = 5,
  Rollout_RolloutStatus_FAILED_ROLLED_BACK = 6,
  Rollout_RolloutStatus_Rollout_RolloutStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Rollout_RolloutStatus_Rollout_RolloutStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Rollout_RolloutStatus_IsValid(int value);
constexpr Rollout_RolloutStatus Rollout_RolloutStatus_RolloutStatus_MIN = Rollout_RolloutStatus_ROLLOUT_STATUS_UNSPECIFIED;
constexpr Rollout_RolloutStatus Rollout_RolloutStatus_RolloutStatus_MAX = Rollout_RolloutStatus_FAILED_ROLLED_BACK;
constexpr int Rollout_RolloutStatus_RolloutStatus_ARRAYSIZE = Rollout_RolloutStatus_RolloutStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Rollout_RolloutStatus_descriptor();
template<typename T>
inline const std::string& Rollout_RolloutStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Rollout_RolloutStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Rollout_RolloutStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Rollout_RolloutStatus_descriptor(), enum_t_value);
}
inline bool Rollout_RolloutStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Rollout_RolloutStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Rollout_RolloutStatus>(
    Rollout_RolloutStatus_descriptor(), name, value);
}
// ===================================================================

class ManagedService final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ManagedService) */ {
 public:
  inline ManagedService() : ManagedService(nullptr) {}
  ~ManagedService() override;
  explicit PROTOBUF_CONSTEXPR ManagedService(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManagedService(const ManagedService& from);
  ManagedService(ManagedService&& from) noexcept
    : ManagedService() {
    *this = ::std::move(from);
  }

  inline ManagedService& operator=(const ManagedService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManagedService& operator=(ManagedService&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManagedService& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManagedService* internal_default_instance() {
    return reinterpret_cast<const ManagedService*>(
               &_ManagedService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ManagedService& a, ManagedService& b) {
    a.Swap(&b);
  }
  inline void Swap(ManagedService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManagedService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManagedService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManagedService>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManagedService& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManagedService& from) {
    ManagedService::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManagedService* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ManagedService";
  }
  protected:
  explicit ManagedService(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 2,
    kProducerProjectIdFieldNumber = 3,
  };
  // string service_name = 2;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string producer_project_id = 3;
  void clear_producer_project_id();
  const std::string& producer_project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_producer_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_producer_project_id();
  PROTOBUF_NODISCARD std::string* release_producer_project_id();
  void set_allocated_producer_project_id(std::string* producer_project_id);
  private:
  const std::string& _internal_producer_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_project_id(const std::string& value);
  std::string* _internal_mutable_producer_project_id();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ManagedService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr producer_project_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class OperationMetadata_Step final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.OperationMetadata.Step) */ {
 public:
  inline OperationMetadata_Step() : OperationMetadata_Step(nullptr) {}
  ~OperationMetadata_Step() override;
  explicit PROTOBUF_CONSTEXPR OperationMetadata_Step(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationMetadata_Step(const OperationMetadata_Step& from);
  OperationMetadata_Step(OperationMetadata_Step&& from) noexcept
    : OperationMetadata_Step() {
    *this = ::std::move(from);
  }

  inline OperationMetadata_Step& operator=(const OperationMetadata_Step& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationMetadata_Step& operator=(OperationMetadata_Step&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationMetadata_Step& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationMetadata_Step* internal_default_instance() {
    return reinterpret_cast<const OperationMetadata_Step*>(
               &_OperationMetadata_Step_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OperationMetadata_Step& a, OperationMetadata_Step& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationMetadata_Step* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationMetadata_Step* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationMetadata_Step* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationMetadata_Step>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationMetadata_Step& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationMetadata_Step& from) {
    OperationMetadata_Step::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationMetadata_Step* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.OperationMetadata.Step";
  }
  protected:
  explicit OperationMetadata_Step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kStatusFieldNumber = 4,
  };
  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.api.servicemanagement.v1.OperationMetadata.Status status = 4;
  void clear_status();
  ::google::api::servicemanagement::v1::OperationMetadata_Status status() const;
  void set_status(::google::api::servicemanagement::v1::OperationMetadata_Status value);
  private:
  ::google::api::servicemanagement::v1::OperationMetadata_Status _internal_status() const;
  void _internal_set_status(::google::api::servicemanagement::v1::OperationMetadata_Status value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.OperationMetadata.Step)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class OperationMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.OperationMetadata) */ {
 public:
  inline OperationMetadata() : OperationMetadata(nullptr) {}
  ~OperationMetadata() override;
  explicit PROTOBUF_CONSTEXPR OperationMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationMetadata(const OperationMetadata& from);
  OperationMetadata(OperationMetadata&& from) noexcept
    : OperationMetadata() {
    *this = ::std::move(from);
  }

  inline OperationMetadata& operator=(const OperationMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationMetadata& operator=(OperationMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationMetadata* internal_default_instance() {
    return reinterpret_cast<const OperationMetadata*>(
               &_OperationMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OperationMetadata& a, OperationMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationMetadata& from) {
    OperationMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.OperationMetadata";
  }
  protected:
  explicit OperationMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OperationMetadata_Step Step;

  typedef OperationMetadata_Status Status;
  static constexpr Status STATUS_UNSPECIFIED =
    OperationMetadata_Status_STATUS_UNSPECIFIED;
  static constexpr Status DONE =
    OperationMetadata_Status_DONE;
  static constexpr Status NOT_STARTED =
    OperationMetadata_Status_NOT_STARTED;
  static constexpr Status IN_PROGRESS =
    OperationMetadata_Status_IN_PROGRESS;
  static constexpr Status FAILED =
    OperationMetadata_Status_FAILED;
  static constexpr Status CANCELLED =
    OperationMetadata_Status_CANCELLED;
  static inline bool Status_IsValid(int value) {
    return OperationMetadata_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    OperationMetadata_Status_Status_MIN;
  static constexpr Status Status_MAX =
    OperationMetadata_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    OperationMetadata_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return OperationMetadata_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return OperationMetadata_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return OperationMetadata_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResourceNamesFieldNumber = 1,
    kStepsFieldNumber = 2,
    kStartTimeFieldNumber = 4,
    kProgressPercentageFieldNumber = 3,
  };
  // repeated string resource_names = 1;
  int resource_names_size() const;
  private:
  int _internal_resource_names_size() const;
  public:
  void clear_resource_names();
  const std::string& resource_names(int index) const;
  std::string* mutable_resource_names(int index);
  void set_resource_names(int index, const std::string& value);
  void set_resource_names(int index, std::string&& value);
  void set_resource_names(int index, const char* value);
  void set_resource_names(int index, const char* value, size_t size);
  std::string* add_resource_names();
  void add_resource_names(const std::string& value);
  void add_resource_names(std::string&& value);
  void add_resource_names(const char* value);
  void add_resource_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& resource_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_resource_names();
  private:
  const std::string& _internal_resource_names(int index) const;
  std::string* _internal_add_resource_names();
  public:

  // repeated .google.api.servicemanagement.v1.OperationMetadata.Step steps = 2;
  int steps_size() const;
  private:
  int _internal_steps_size() const;
  public:
  void clear_steps();
  ::google::api::servicemanagement::v1::OperationMetadata_Step* mutable_steps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::OperationMetadata_Step >*
      mutable_steps();
  private:
  const ::google::api::servicemanagement::v1::OperationMetadata_Step& _internal_steps(int index) const;
  ::google::api::servicemanagement::v1::OperationMetadata_Step* _internal_add_steps();
  public:
  const ::google::api::servicemanagement::v1::OperationMetadata_Step& steps(int index) const;
  ::google::api::servicemanagement::v1::OperationMetadata_Step* add_steps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::OperationMetadata_Step >&
      steps() const;

  // .google.protobuf.Timestamp start_time = 4;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // int32 progress_percentage = 3;
  void clear_progress_percentage();
  int32_t progress_percentage() const;
  void set_progress_percentage(int32_t value);
  private:
  int32_t _internal_progress_percentage() const;
  void _internal_set_progress_percentage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.OperationMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> resource_names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::OperationMetadata_Step > steps_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    int32_t progress_percentage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Diagnostic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.Diagnostic) */ {
 public:
  inline Diagnostic() : Diagnostic(nullptr) {}
  ~Diagnostic() override;
  explicit PROTOBUF_CONSTEXPR Diagnostic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Diagnostic(const Diagnostic& from);
  Diagnostic(Diagnostic&& from) noexcept
    : Diagnostic() {
    *this = ::std::move(from);
  }

  inline Diagnostic& operator=(const Diagnostic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Diagnostic& operator=(Diagnostic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Diagnostic& default_instance() {
    return *internal_default_instance();
  }
  static inline const Diagnostic* internal_default_instance() {
    return reinterpret_cast<const Diagnostic*>(
               &_Diagnostic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Diagnostic& a, Diagnostic& b) {
    a.Swap(&b);
  }
  inline void Swap(Diagnostic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Diagnostic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Diagnostic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Diagnostic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Diagnostic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Diagnostic& from) {
    Diagnostic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Diagnostic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.Diagnostic";
  }
  protected:
  explicit Diagnostic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Diagnostic_Kind Kind;
  static constexpr Kind WARNING =
    Diagnostic_Kind_WARNING;
  static constexpr Kind ERROR =
    Diagnostic_Kind_ERROR;
  static inline bool Kind_IsValid(int value) {
    return Diagnostic_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    Diagnostic_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    Diagnostic_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    Diagnostic_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return Diagnostic_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return Diagnostic_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return Diagnostic_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kMessageFieldNumber = 3,
    kKindFieldNumber = 2,
  };
  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.api.servicemanagement.v1.Diagnostic.Kind kind = 2;
  void clear_kind();
  ::google::api::servicemanagement::v1::Diagnostic_Kind kind() const;
  void set_kind(::google::api::servicemanagement::v1::Diagnostic_Kind value);
  private:
  ::google::api::servicemanagement::v1::Diagnostic_Kind _internal_kind() const;
  void _internal_set_kind(::google::api::servicemanagement::v1::Diagnostic_Kind value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.Diagnostic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConfigSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ConfigSource) */ {
 public:
  inline ConfigSource() : ConfigSource(nullptr) {}
  ~ConfigSource() override;
  explicit PROTOBUF_CONSTEXPR ConfigSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigSource(const ConfigSource& from);
  ConfigSource(ConfigSource&& from) noexcept
    : ConfigSource() {
    *this = ::std::move(from);
  }

  inline ConfigSource& operator=(const ConfigSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigSource& operator=(ConfigSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigSource* internal_default_instance() {
    return reinterpret_cast<const ConfigSource*>(
               &_ConfigSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConfigSource& a, ConfigSource& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigSource& from) {
    ConfigSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ConfigSource";
  }
  protected:
  explicit ConfigSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 2,
    kIdFieldNumber = 5,
  };
  // repeated .google.api.servicemanagement.v1.ConfigFile files = 2;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::google::api::servicemanagement::v1::ConfigFile* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ConfigFile >*
      mutable_files();
  private:
  const ::google::api::servicemanagement::v1::ConfigFile& _internal_files(int index) const;
  ::google::api::servicemanagement::v1::ConfigFile* _internal_add_files();
  public:
  const ::google::api::servicemanagement::v1::ConfigFile& files(int index) const;
  ::google::api::servicemanagement::v1::ConfigFile* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ConfigFile >&
      files() const;

  // string id = 5;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ConfigSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ConfigFile > files_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConfigFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ConfigFile) */ {
 public:
  inline ConfigFile() : ConfigFile(nullptr) {}
  ~ConfigFile() override;
  explicit PROTOBUF_CONSTEXPR ConfigFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigFile(const ConfigFile& from);
  ConfigFile(ConfigFile&& from) noexcept
    : ConfigFile() {
    *this = ::std::move(from);
  }

  inline ConfigFile& operator=(const ConfigFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigFile& operator=(ConfigFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigFile* internal_default_instance() {
    return reinterpret_cast<const ConfigFile*>(
               &_ConfigFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConfigFile& a, ConfigFile& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigFile& from) {
    ConfigFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ConfigFile";
  }
  protected:
  explicit ConfigFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConfigFile_FileType FileType;
  static constexpr FileType FILE_TYPE_UNSPECIFIED =
    ConfigFile_FileType_FILE_TYPE_UNSPECIFIED;
  static constexpr FileType SERVICE_CONFIG_YAML =
    ConfigFile_FileType_SERVICE_CONFIG_YAML;
  static constexpr FileType OPEN_API_JSON =
    ConfigFile_FileType_OPEN_API_JSON;
  static constexpr FileType OPEN_API_YAML =
    ConfigFile_FileType_OPEN_API_YAML;
  static constexpr FileType FILE_DESCRIPTOR_SET_PROTO =
    ConfigFile_FileType_FILE_DESCRIPTOR_SET_PROTO;
  static constexpr FileType PROTO_FILE =
    ConfigFile_FileType_PROTO_FILE;
  static inline bool FileType_IsValid(int value) {
    return ConfigFile_FileType_IsValid(value);
  }
  static constexpr FileType FileType_MIN =
    ConfigFile_FileType_FileType_MIN;
  static constexpr FileType FileType_MAX =
    ConfigFile_FileType_FileType_MAX;
  static constexpr int FileType_ARRAYSIZE =
    ConfigFile_FileType_FileType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FileType_descriptor() {
    return ConfigFile_FileType_descriptor();
  }
  template<typename T>
  static inline const std::string& FileType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FileType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FileType_Name.");
    return ConfigFile_FileType_Name(enum_t_value);
  }
  static inline bool FileType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FileType* value) {
    return ConfigFile_FileType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
    kFileContentsFieldNumber = 3,
    kFileTypeFieldNumber = 4,
  };
  // string file_path = 1;
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // bytes file_contents = 3;
  void clear_file_contents();
  const std::string& file_contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_contents();
  PROTOBUF_NODISCARD std::string* release_file_contents();
  void set_allocated_file_contents(std::string* file_contents);
  private:
  const std::string& _internal_file_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_contents(const std::string& value);
  std::string* _internal_mutable_file_contents();
  public:

  // .google.api.servicemanagement.v1.ConfigFile.FileType file_type = 4;
  void clear_file_type();
  ::google::api::servicemanagement::v1::ConfigFile_FileType file_type() const;
  void set_file_type(::google::api::servicemanagement::v1::ConfigFile_FileType value);
  private:
  ::google::api::servicemanagement::v1::ConfigFile_FileType _internal_file_type() const;
  void _internal_set_file_type(::google::api::servicemanagement::v1::ConfigFile_FileType value);
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ConfigFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_contents_;
    int file_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ConfigRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ConfigRef) */ {
 public:
  inline ConfigRef() : ConfigRef(nullptr) {}
  ~ConfigRef() override;
  explicit PROTOBUF_CONSTEXPR ConfigRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigRef(const ConfigRef& from);
  ConfigRef(ConfigRef&& from) noexcept
    : ConfigRef() {
    *this = ::std::move(from);
  }

  inline ConfigRef& operator=(const ConfigRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigRef& operator=(ConfigRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigRef* internal_default_instance() {
    return reinterpret_cast<const ConfigRef*>(
               &_ConfigRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConfigRef& a, ConfigRef& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigRef& from) {
    ConfigRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ConfigRef";
  }
  protected:
  explicit ConfigRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ConfigRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class ChangeReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.ChangeReport) */ {
 public:
  inline ChangeReport() : ChangeReport(nullptr) {}
  ~ChangeReport() override;
  explicit PROTOBUF_CONSTEXPR ChangeReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeReport(const ChangeReport& from);
  ChangeReport(ChangeReport&& from) noexcept
    : ChangeReport() {
    *this = ::std::move(from);
  }

  inline ChangeReport& operator=(const ChangeReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeReport& operator=(ChangeReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeReport* internal_default_instance() {
    return reinterpret_cast<const ChangeReport*>(
               &_ChangeReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChangeReport& a, ChangeReport& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeReport& from) {
    ChangeReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.ChangeReport";
  }
  protected:
  explicit ChangeReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigChangesFieldNumber = 1,
  };
  // repeated .google.api.ConfigChange config_changes = 1;
  int config_changes_size() const;
  private:
  int _internal_config_changes_size() const;
  public:
  void clear_config_changes();
  ::google::api::ConfigChange* mutable_config_changes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::ConfigChange >*
      mutable_config_changes();
  private:
  const ::google::api::ConfigChange& _internal_config_changes(int index) const;
  ::google::api::ConfigChange* _internal_add_config_changes();
  public:
  const ::google::api::ConfigChange& config_changes(int index) const;
  ::google::api::ConfigChange* add_config_changes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::ConfigChange >&
      config_changes() const;

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.ChangeReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::ConfigChange > config_changes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse& other);
  static const Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse*>(&_Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy.PercentagesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};

// -------------------------------------------------------------------

class Rollout_TrafficPercentStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy) */ {
 public:
  inline Rollout_TrafficPercentStrategy() : Rollout_TrafficPercentStrategy(nullptr) {}
  ~Rollout_TrafficPercentStrategy() override;
  explicit PROTOBUF_CONSTEXPR Rollout_TrafficPercentStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rollout_TrafficPercentStrategy(const Rollout_TrafficPercentStrategy& from);
  Rollout_TrafficPercentStrategy(Rollout_TrafficPercentStrategy&& from) noexcept
    : Rollout_TrafficPercentStrategy() {
    *this = ::std::move(from);
  }

  inline Rollout_TrafficPercentStrategy& operator=(const Rollout_TrafficPercentStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rollout_TrafficPercentStrategy& operator=(Rollout_TrafficPercentStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rollout_TrafficPercentStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rollout_TrafficPercentStrategy* internal_default_instance() {
    return reinterpret_cast<const Rollout_TrafficPercentStrategy*>(
               &_Rollout_TrafficPercentStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Rollout_TrafficPercentStrategy& a, Rollout_TrafficPercentStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(Rollout_TrafficPercentStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rollout_TrafficPercentStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rollout_TrafficPercentStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rollout_TrafficPercentStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rollout_TrafficPercentStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rollout_TrafficPercentStrategy& from) {
    Rollout_TrafficPercentStrategy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rollout_TrafficPercentStrategy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy";
  }
  protected:
  explicit Rollout_TrafficPercentStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPercentagesFieldNumber = 1,
  };
  // map<string, double> percentages = 1;
  int percentages_size() const;
  private:
  int _internal_percentages_size() const;
  public:
  void clear_percentages();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_percentages() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_percentages();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      percentages() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_percentages();

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Rollout_TrafficPercentStrategy_PercentagesEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> percentages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Rollout_DeleteServiceStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy) */ {
 public:
  inline Rollout_DeleteServiceStrategy() : Rollout_DeleteServiceStrategy(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Rollout_DeleteServiceStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rollout_DeleteServiceStrategy(const Rollout_DeleteServiceStrategy& from);
  Rollout_DeleteServiceStrategy(Rollout_DeleteServiceStrategy&& from) noexcept
    : Rollout_DeleteServiceStrategy() {
    *this = ::std::move(from);
  }

  inline Rollout_DeleteServiceStrategy& operator=(const Rollout_DeleteServiceStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rollout_DeleteServiceStrategy& operator=(Rollout_DeleteServiceStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rollout_DeleteServiceStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rollout_DeleteServiceStrategy* internal_default_instance() {
    return reinterpret_cast<const Rollout_DeleteServiceStrategy*>(
               &_Rollout_DeleteServiceStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Rollout_DeleteServiceStrategy& a, Rollout_DeleteServiceStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(Rollout_DeleteServiceStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rollout_DeleteServiceStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rollout_DeleteServiceStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rollout_DeleteServiceStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Rollout_DeleteServiceStrategy& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Rollout_DeleteServiceStrategy& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy";
  }
  protected:
  explicit Rollout_DeleteServiceStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// -------------------------------------------------------------------

class Rollout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.api.servicemanagement.v1.Rollout) */ {
 public:
  inline Rollout() : Rollout(nullptr) {}
  ~Rollout() override;
  explicit PROTOBUF_CONSTEXPR Rollout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rollout(const Rollout& from);
  Rollout(Rollout&& from) noexcept
    : Rollout() {
    *this = ::std::move(from);
  }

  inline Rollout& operator=(const Rollout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rollout& operator=(Rollout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rollout& default_instance() {
    return *internal_default_instance();
  }
  enum StrategyCase {
    kTrafficPercentStrategy = 5,
    kDeleteServiceStrategy = 200,
    STRATEGY_NOT_SET = 0,
  };

  static inline const Rollout* internal_default_instance() {
    return reinterpret_cast<const Rollout*>(
               &_Rollout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Rollout& a, Rollout& b) {
    a.Swap(&b);
  }
  inline void Swap(Rollout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rollout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rollout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rollout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rollout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rollout& from) {
    Rollout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rollout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.api.servicemanagement.v1.Rollout";
  }
  protected:
  explicit Rollout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Rollout_TrafficPercentStrategy TrafficPercentStrategy;
  typedef Rollout_DeleteServiceStrategy DeleteServiceStrategy;

  typedef Rollout_RolloutStatus RolloutStatus;
  static constexpr RolloutStatus ROLLOUT_STATUS_UNSPECIFIED =
    Rollout_RolloutStatus_ROLLOUT_STATUS_UNSPECIFIED;
  static constexpr RolloutStatus IN_PROGRESS =
    Rollout_RolloutStatus_IN_PROGRESS;
  static constexpr RolloutStatus SUCCESS =
    Rollout_RolloutStatus_SUCCESS;
  static constexpr RolloutStatus CANCELLED =
    Rollout_RolloutStatus_CANCELLED;
  static constexpr RolloutStatus FAILED =
    Rollout_RolloutStatus_FAILED;
  static constexpr RolloutStatus PENDING =
    Rollout_RolloutStatus_PENDING;
  static constexpr RolloutStatus FAILED_ROLLED_BACK =
    Rollout_RolloutStatus_FAILED_ROLLED_BACK;
  static inline bool RolloutStatus_IsValid(int value) {
    return Rollout_RolloutStatus_IsValid(value);
  }
  static constexpr RolloutStatus RolloutStatus_MIN =
    Rollout_RolloutStatus_RolloutStatus_MIN;
  static constexpr RolloutStatus RolloutStatus_MAX =
    Rollout_RolloutStatus_RolloutStatus_MAX;
  static constexpr int RolloutStatus_ARRAYSIZE =
    Rollout_RolloutStatus_RolloutStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RolloutStatus_descriptor() {
    return Rollout_RolloutStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& RolloutStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RolloutStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RolloutStatus_Name.");
    return Rollout_RolloutStatus_Name(enum_t_value);
  }
  static inline bool RolloutStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RolloutStatus* value) {
    return Rollout_RolloutStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRolloutIdFieldNumber = 1,
    kCreatedByFieldNumber = 3,
    kServiceNameFieldNumber = 8,
    kCreateTimeFieldNumber = 2,
    kStatusFieldNumber = 4,
    kTrafficPercentStrategyFieldNumber = 5,
    kDeleteServiceStrategyFieldNumber = 200,
  };
  // string rollout_id = 1 [(.google.api.field_behavior) = OPTIONAL];
  void clear_rollout_id();
  const std::string& rollout_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rollout_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rollout_id();
  PROTOBUF_NODISCARD std::string* release_rollout_id();
  void set_allocated_rollout_id(std::string* rollout_id);
  private:
  const std::string& _internal_rollout_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rollout_id(const std::string& value);
  std::string* _internal_mutable_rollout_id();
  public:

  // string created_by = 3;
  void clear_created_by();
  const std::string& created_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* created_by);
  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(const std::string& value);
  std::string* _internal_mutable_created_by();
  public:

  // string service_name = 8;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // .google.protobuf.Timestamp create_time = 2;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.api.servicemanagement.v1.Rollout.RolloutStatus status = 4;
  void clear_status();
  ::google::api::servicemanagement::v1::Rollout_RolloutStatus status() const;
  void set_status(::google::api::servicemanagement::v1::Rollout_RolloutStatus value);
  private:
  ::google::api::servicemanagement::v1::Rollout_RolloutStatus _internal_status() const;
  void _internal_set_status(::google::api::servicemanagement::v1::Rollout_RolloutStatus value);
  public:

  // .google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy traffic_percent_strategy = 5;
  bool has_traffic_percent_strategy() const;
  private:
  bool _internal_has_traffic_percent_strategy() const;
  public:
  void clear_traffic_percent_strategy();
  const ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy& traffic_percent_strategy() const;
  PROTOBUF_NODISCARD ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* release_traffic_percent_strategy();
  ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* mutable_traffic_percent_strategy();
  void set_allocated_traffic_percent_strategy(::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* traffic_percent_strategy);
  private:
  const ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy& _internal_traffic_percent_strategy() const;
  ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* _internal_mutable_traffic_percent_strategy();
  public:
  void unsafe_arena_set_allocated_traffic_percent_strategy(
      ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* traffic_percent_strategy);
  ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* unsafe_arena_release_traffic_percent_strategy();

  // .google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy delete_service_strategy = 200;
  bool has_delete_service_strategy() const;
  private:
  bool _internal_has_delete_service_strategy() const;
  public:
  void clear_delete_service_strategy();
  const ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy& delete_service_strategy() const;
  PROTOBUF_NODISCARD ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* release_delete_service_strategy();
  ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* mutable_delete_service_strategy();
  void set_allocated_delete_service_strategy(::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* delete_service_strategy);
  private:
  const ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy& _internal_delete_service_strategy() const;
  ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* _internal_mutable_delete_service_strategy();
  public:
  void unsafe_arena_set_allocated_delete_service_strategy(
      ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* delete_service_strategy);
  ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* unsafe_arena_release_delete_service_strategy();

  void clear_strategy();
  StrategyCase strategy_case() const;
  // @@protoc_insertion_point(class_scope:google.api.servicemanagement.v1.Rollout)
 private:
  class _Internal;
  void set_has_traffic_percent_strategy();
  void set_has_delete_service_strategy();

  inline bool has_strategy() const;
  inline void clear_has_strategy();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rollout_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    int status_;
    union StrategyUnion {
      constexpr StrategyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* traffic_percent_strategy_;
      ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* delete_service_strategy_;
    } strategy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ManagedService

// string service_name = 2;
inline void ManagedService::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ManagedService::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ManagedService.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManagedService::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ManagedService.service_name)
}
inline std::string* ManagedService::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ManagedService.service_name)
  return _s;
}
inline const std::string& ManagedService::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ManagedService::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ManagedService::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ManagedService::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ManagedService.service_name)
  return _impl_.service_name_.Release();
}
inline void ManagedService::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ManagedService.service_name)
}

// string producer_project_id = 3;
inline void ManagedService::clear_producer_project_id() {
  _impl_.producer_project_id_.ClearToEmpty();
}
inline const std::string& ManagedService::producer_project_id() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ManagedService.producer_project_id)
  return _internal_producer_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManagedService::set_producer_project_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.producer_project_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ManagedService.producer_project_id)
}
inline std::string* ManagedService::mutable_producer_project_id() {
  std::string* _s = _internal_mutable_producer_project_id();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ManagedService.producer_project_id)
  return _s;
}
inline const std::string& ManagedService::_internal_producer_project_id() const {
  return _impl_.producer_project_id_.Get();
}
inline void ManagedService::_internal_set_producer_project_id(const std::string& value) {
  
  _impl_.producer_project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ManagedService::_internal_mutable_producer_project_id() {
  
  return _impl_.producer_project_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ManagedService::release_producer_project_id() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ManagedService.producer_project_id)
  return _impl_.producer_project_id_.Release();
}
inline void ManagedService::set_allocated_producer_project_id(std::string* producer_project_id) {
  if (producer_project_id != nullptr) {
    
  } else {
    
  }
  _impl_.producer_project_id_.SetAllocated(producer_project_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.producer_project_id_.IsDefault()) {
    _impl_.producer_project_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ManagedService.producer_project_id)
}

// -------------------------------------------------------------------

// OperationMetadata_Step

// string description = 2;
inline void OperationMetadata_Step::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& OperationMetadata_Step::description() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.OperationMetadata.Step.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationMetadata_Step::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.OperationMetadata.Step.description)
}
inline std::string* OperationMetadata_Step::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.OperationMetadata.Step.description)
  return _s;
}
inline const std::string& OperationMetadata_Step::_internal_description() const {
  return _impl_.description_.Get();
}
inline void OperationMetadata_Step::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* OperationMetadata_Step::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* OperationMetadata_Step::release_description() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.OperationMetadata.Step.description)
  return _impl_.description_.Release();
}
inline void OperationMetadata_Step::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.OperationMetadata.Step.description)
}

// .google.api.servicemanagement.v1.OperationMetadata.Status status = 4;
inline void OperationMetadata_Step::clear_status() {
  _impl_.status_ = 0;
}
inline ::google::api::servicemanagement::v1::OperationMetadata_Status OperationMetadata_Step::_internal_status() const {
  return static_cast< ::google::api::servicemanagement::v1::OperationMetadata_Status >(_impl_.status_);
}
inline ::google::api::servicemanagement::v1::OperationMetadata_Status OperationMetadata_Step::status() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.OperationMetadata.Step.status)
  return _internal_status();
}
inline void OperationMetadata_Step::_internal_set_status(::google::api::servicemanagement::v1::OperationMetadata_Status value) {
  
  _impl_.status_ = value;
}
inline void OperationMetadata_Step::set_status(::google::api::servicemanagement::v1::OperationMetadata_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.OperationMetadata.Step.status)
}

// -------------------------------------------------------------------

// OperationMetadata

// repeated string resource_names = 1;
inline int OperationMetadata::_internal_resource_names_size() const {
  return _impl_.resource_names_.size();
}
inline int OperationMetadata::resource_names_size() const {
  return _internal_resource_names_size();
}
inline void OperationMetadata::clear_resource_names() {
  _impl_.resource_names_.Clear();
}
inline std::string* OperationMetadata::add_resource_names() {
  std::string* _s = _internal_add_resource_names();
  // @@protoc_insertion_point(field_add_mutable:google.api.servicemanagement.v1.OperationMetadata.resource_names)
  return _s;
}
inline const std::string& OperationMetadata::_internal_resource_names(int index) const {
  return _impl_.resource_names_.Get(index);
}
inline const std::string& OperationMetadata::resource_names(int index) const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.OperationMetadata.resource_names)
  return _internal_resource_names(index);
}
inline std::string* OperationMetadata::mutable_resource_names(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.OperationMetadata.resource_names)
  return _impl_.resource_names_.Mutable(index);
}
inline void OperationMetadata::set_resource_names(int index, const std::string& value) {
  _impl_.resource_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.OperationMetadata.resource_names)
}
inline void OperationMetadata::set_resource_names(int index, std::string&& value) {
  _impl_.resource_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.OperationMetadata.resource_names)
}
inline void OperationMetadata::set_resource_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.resource_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.api.servicemanagement.v1.OperationMetadata.resource_names)
}
inline void OperationMetadata::set_resource_names(int index, const char* value, size_t size) {
  _impl_.resource_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.api.servicemanagement.v1.OperationMetadata.resource_names)
}
inline std::string* OperationMetadata::_internal_add_resource_names() {
  return _impl_.resource_names_.Add();
}
inline void OperationMetadata::add_resource_names(const std::string& value) {
  _impl_.resource_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.OperationMetadata.resource_names)
}
inline void OperationMetadata::add_resource_names(std::string&& value) {
  _impl_.resource_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.OperationMetadata.resource_names)
}
inline void OperationMetadata::add_resource_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.resource_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.api.servicemanagement.v1.OperationMetadata.resource_names)
}
inline void OperationMetadata::add_resource_names(const char* value, size_t size) {
  _impl_.resource_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.api.servicemanagement.v1.OperationMetadata.resource_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OperationMetadata::resource_names() const {
  // @@protoc_insertion_point(field_list:google.api.servicemanagement.v1.OperationMetadata.resource_names)
  return _impl_.resource_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OperationMetadata::mutable_resource_names() {
  // @@protoc_insertion_point(field_mutable_list:google.api.servicemanagement.v1.OperationMetadata.resource_names)
  return &_impl_.resource_names_;
}

// repeated .google.api.servicemanagement.v1.OperationMetadata.Step steps = 2;
inline int OperationMetadata::_internal_steps_size() const {
  return _impl_.steps_.size();
}
inline int OperationMetadata::steps_size() const {
  return _internal_steps_size();
}
inline void OperationMetadata::clear_steps() {
  _impl_.steps_.Clear();
}
inline ::google::api::servicemanagement::v1::OperationMetadata_Step* OperationMetadata::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.OperationMetadata.steps)
  return _impl_.steps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::OperationMetadata_Step >*
OperationMetadata::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:google.api.servicemanagement.v1.OperationMetadata.steps)
  return &_impl_.steps_;
}
inline const ::google::api::servicemanagement::v1::OperationMetadata_Step& OperationMetadata::_internal_steps(int index) const {
  return _impl_.steps_.Get(index);
}
inline const ::google::api::servicemanagement::v1::OperationMetadata_Step& OperationMetadata::steps(int index) const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.OperationMetadata.steps)
  return _internal_steps(index);
}
inline ::google::api::servicemanagement::v1::OperationMetadata_Step* OperationMetadata::_internal_add_steps() {
  return _impl_.steps_.Add();
}
inline ::google::api::servicemanagement::v1::OperationMetadata_Step* OperationMetadata::add_steps() {
  ::google::api::servicemanagement::v1::OperationMetadata_Step* _add = _internal_add_steps();
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.OperationMetadata.steps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::OperationMetadata_Step >&
OperationMetadata::steps() const {
  // @@protoc_insertion_point(field_list:google.api.servicemanagement.v1.OperationMetadata.steps)
  return _impl_.steps_;
}

// int32 progress_percentage = 3;
inline void OperationMetadata::clear_progress_percentage() {
  _impl_.progress_percentage_ = 0;
}
inline int32_t OperationMetadata::_internal_progress_percentage() const {
  return _impl_.progress_percentage_;
}
inline int32_t OperationMetadata::progress_percentage() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.OperationMetadata.progress_percentage)
  return _internal_progress_percentage();
}
inline void OperationMetadata::_internal_set_progress_percentage(int32_t value) {
  
  _impl_.progress_percentage_ = value;
}
inline void OperationMetadata::set_progress_percentage(int32_t value) {
  _internal_set_progress_percentage(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.OperationMetadata.progress_percentage)
}

// .google.protobuf.Timestamp start_time = 4;
inline bool OperationMetadata::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool OperationMetadata::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationMetadata::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& OperationMetadata::start_time() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.OperationMetadata.start_time)
  return _internal_start_time();
}
inline void OperationMetadata::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.OperationMetadata.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationMetadata::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationMetadata::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.OperationMetadata.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationMetadata::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* OperationMetadata::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.OperationMetadata.start_time)
  return _msg;
}
inline void OperationMetadata::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.OperationMetadata.start_time)
}

// -------------------------------------------------------------------

// Diagnostic

// string location = 1;
inline void Diagnostic::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& Diagnostic::location() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Diagnostic.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Diagnostic::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.Diagnostic.location)
}
inline std::string* Diagnostic::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.Diagnostic.location)
  return _s;
}
inline const std::string& Diagnostic::_internal_location() const {
  return _impl_.location_.Get();
}
inline void Diagnostic::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* Diagnostic::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* Diagnostic::release_location() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.Diagnostic.location)
  return _impl_.location_.Release();
}
inline void Diagnostic::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.Diagnostic.location)
}

// .google.api.servicemanagement.v1.Diagnostic.Kind kind = 2;
inline void Diagnostic::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::google::api::servicemanagement::v1::Diagnostic_Kind Diagnostic::_internal_kind() const {
  return static_cast< ::google::api::servicemanagement::v1::Diagnostic_Kind >(_impl_.kind_);
}
inline ::google::api::servicemanagement::v1::Diagnostic_Kind Diagnostic::kind() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Diagnostic.kind)
  return _internal_kind();
}
inline void Diagnostic::_internal_set_kind(::google::api::servicemanagement::v1::Diagnostic_Kind value) {
  
  _impl_.kind_ = value;
}
inline void Diagnostic::set_kind(::google::api::servicemanagement::v1::Diagnostic_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.Diagnostic.kind)
}

// string message = 3;
inline void Diagnostic::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Diagnostic::message() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Diagnostic.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Diagnostic::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.Diagnostic.message)
}
inline std::string* Diagnostic::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.Diagnostic.message)
  return _s;
}
inline const std::string& Diagnostic::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Diagnostic::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Diagnostic::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Diagnostic::release_message() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.Diagnostic.message)
  return _impl_.message_.Release();
}
inline void Diagnostic::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.Diagnostic.message)
}

// -------------------------------------------------------------------

// ConfigSource

// string id = 5;
inline void ConfigSource::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConfigSource::id() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ConfigSource.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSource::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ConfigSource.id)
}
inline std::string* ConfigSource::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ConfigSource.id)
  return _s;
}
inline const std::string& ConfigSource::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ConfigSource::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigSource::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigSource::release_id() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ConfigSource.id)
  return _impl_.id_.Release();
}
inline void ConfigSource::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ConfigSource.id)
}

// repeated .google.api.servicemanagement.v1.ConfigFile files = 2;
inline int ConfigSource::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int ConfigSource::files_size() const {
  return _internal_files_size();
}
inline void ConfigSource::clear_files() {
  _impl_.files_.Clear();
}
inline ::google::api::servicemanagement::v1::ConfigFile* ConfigSource::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ConfigSource.files)
  return _impl_.files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ConfigFile >*
ConfigSource::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:google.api.servicemanagement.v1.ConfigSource.files)
  return &_impl_.files_;
}
inline const ::google::api::servicemanagement::v1::ConfigFile& ConfigSource::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const ::google::api::servicemanagement::v1::ConfigFile& ConfigSource::files(int index) const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ConfigSource.files)
  return _internal_files(index);
}
inline ::google::api::servicemanagement::v1::ConfigFile* ConfigSource::_internal_add_files() {
  return _impl_.files_.Add();
}
inline ::google::api::servicemanagement::v1::ConfigFile* ConfigSource::add_files() {
  ::google::api::servicemanagement::v1::ConfigFile* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.ConfigSource.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::servicemanagement::v1::ConfigFile >&
ConfigSource::files() const {
  // @@protoc_insertion_point(field_list:google.api.servicemanagement.v1.ConfigSource.files)
  return _impl_.files_;
}

// -------------------------------------------------------------------

// ConfigFile

// string file_path = 1;
inline void ConfigFile::clear_file_path() {
  _impl_.file_path_.ClearToEmpty();
}
inline const std::string& ConfigFile::file_path() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ConfigFile.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_file_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ConfigFile.file_path)
}
inline std::string* ConfigFile::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ConfigFile.file_path)
  return _s;
}
inline const std::string& ConfigFile::_internal_file_path() const {
  return _impl_.file_path_.Get();
}
inline void ConfigFile::_internal_set_file_path(const std::string& value) {
  
  _impl_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_file_path() {
  
  return _impl_.file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigFile::release_file_path() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ConfigFile.file_path)
  return _impl_.file_path_.Release();
}
inline void ConfigFile::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  _impl_.file_path_.SetAllocated(file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_path_.IsDefault()) {
    _impl_.file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ConfigFile.file_path)
}

// bytes file_contents = 3;
inline void ConfigFile::clear_file_contents() {
  _impl_.file_contents_.ClearToEmpty();
}
inline const std::string& ConfigFile::file_contents() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ConfigFile.file_contents)
  return _internal_file_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_file_contents(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_contents_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ConfigFile.file_contents)
}
inline std::string* ConfigFile::mutable_file_contents() {
  std::string* _s = _internal_mutable_file_contents();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ConfigFile.file_contents)
  return _s;
}
inline const std::string& ConfigFile::_internal_file_contents() const {
  return _impl_.file_contents_.Get();
}
inline void ConfigFile::_internal_set_file_contents(const std::string& value) {
  
  _impl_.file_contents_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_file_contents() {
  
  return _impl_.file_contents_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigFile::release_file_contents() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ConfigFile.file_contents)
  return _impl_.file_contents_.Release();
}
inline void ConfigFile::set_allocated_file_contents(std::string* file_contents) {
  if (file_contents != nullptr) {
    
  } else {
    
  }
  _impl_.file_contents_.SetAllocated(file_contents, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_contents_.IsDefault()) {
    _impl_.file_contents_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ConfigFile.file_contents)
}

// .google.api.servicemanagement.v1.ConfigFile.FileType file_type = 4;
inline void ConfigFile::clear_file_type() {
  _impl_.file_type_ = 0;
}
inline ::google::api::servicemanagement::v1::ConfigFile_FileType ConfigFile::_internal_file_type() const {
  return static_cast< ::google::api::servicemanagement::v1::ConfigFile_FileType >(_impl_.file_type_);
}
inline ::google::api::servicemanagement::v1::ConfigFile_FileType ConfigFile::file_type() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ConfigFile.file_type)
  return _internal_file_type();
}
inline void ConfigFile::_internal_set_file_type(::google::api::servicemanagement::v1::ConfigFile_FileType value) {
  
  _impl_.file_type_ = value;
}
inline void ConfigFile::set_file_type(::google::api::servicemanagement::v1::ConfigFile_FileType value) {
  _internal_set_file_type(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ConfigFile.file_type)
}

// -------------------------------------------------------------------

// ConfigRef

// string name = 1;
inline void ConfigRef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ConfigRef::name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ConfigRef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigRef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.ConfigRef.name)
}
inline std::string* ConfigRef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ConfigRef.name)
  return _s;
}
inline const std::string& ConfigRef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConfigRef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigRef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigRef::release_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.ConfigRef.name)
  return _impl_.name_.Release();
}
inline void ConfigRef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.ConfigRef.name)
}

// -------------------------------------------------------------------

// ChangeReport

// repeated .google.api.ConfigChange config_changes = 1;
inline int ChangeReport::_internal_config_changes_size() const {
  return _impl_.config_changes_.size();
}
inline int ChangeReport::config_changes_size() const {
  return _internal_config_changes_size();
}
inline ::google::api::ConfigChange* ChangeReport::mutable_config_changes(int index) {
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.ChangeReport.config_changes)
  return _impl_.config_changes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::ConfigChange >*
ChangeReport::mutable_config_changes() {
  // @@protoc_insertion_point(field_mutable_list:google.api.servicemanagement.v1.ChangeReport.config_changes)
  return &_impl_.config_changes_;
}
inline const ::google::api::ConfigChange& ChangeReport::_internal_config_changes(int index) const {
  return _impl_.config_changes_.Get(index);
}
inline const ::google::api::ConfigChange& ChangeReport::config_changes(int index) const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.ChangeReport.config_changes)
  return _internal_config_changes(index);
}
inline ::google::api::ConfigChange* ChangeReport::_internal_add_config_changes() {
  return _impl_.config_changes_.Add();
}
inline ::google::api::ConfigChange* ChangeReport::add_config_changes() {
  ::google::api::ConfigChange* _add = _internal_add_config_changes();
  // @@protoc_insertion_point(field_add:google.api.servicemanagement.v1.ChangeReport.config_changes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::api::ConfigChange >&
ChangeReport::config_changes() const {
  // @@protoc_insertion_point(field_list:google.api.servicemanagement.v1.ChangeReport.config_changes)
  return _impl_.config_changes_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Rollout_TrafficPercentStrategy

// map<string, double> percentages = 1;
inline int Rollout_TrafficPercentStrategy::_internal_percentages_size() const {
  return _impl_.percentages_.size();
}
inline int Rollout_TrafficPercentStrategy::percentages_size() const {
  return _internal_percentages_size();
}
inline void Rollout_TrafficPercentStrategy::clear_percentages() {
  _impl_.percentages_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Rollout_TrafficPercentStrategy::_internal_percentages() const {
  return _impl_.percentages_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Rollout_TrafficPercentStrategy::percentages() const {
  // @@protoc_insertion_point(field_map:google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy.percentages)
  return _internal_percentages();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Rollout_TrafficPercentStrategy::_internal_mutable_percentages() {
  return _impl_.percentages_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Rollout_TrafficPercentStrategy::mutable_percentages() {
  // @@protoc_insertion_point(field_mutable_map:google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy.percentages)
  return _internal_mutable_percentages();
}

// -------------------------------------------------------------------

// Rollout_DeleteServiceStrategy

// -------------------------------------------------------------------

// Rollout

// string rollout_id = 1 [(.google.api.field_behavior) = OPTIONAL];
inline void Rollout::clear_rollout_id() {
  _impl_.rollout_id_.ClearToEmpty();
}
inline const std::string& Rollout::rollout_id() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Rollout.rollout_id)
  return _internal_rollout_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rollout::set_rollout_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rollout_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.Rollout.rollout_id)
}
inline std::string* Rollout::mutable_rollout_id() {
  std::string* _s = _internal_mutable_rollout_id();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.Rollout.rollout_id)
  return _s;
}
inline const std::string& Rollout::_internal_rollout_id() const {
  return _impl_.rollout_id_.Get();
}
inline void Rollout::_internal_set_rollout_id(const std::string& value) {
  
  _impl_.rollout_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Rollout::_internal_mutable_rollout_id() {
  
  return _impl_.rollout_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Rollout::release_rollout_id() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.Rollout.rollout_id)
  return _impl_.rollout_id_.Release();
}
inline void Rollout::set_allocated_rollout_id(std::string* rollout_id) {
  if (rollout_id != nullptr) {
    
  } else {
    
  }
  _impl_.rollout_id_.SetAllocated(rollout_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rollout_id_.IsDefault()) {
    _impl_.rollout_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.Rollout.rollout_id)
}

// .google.protobuf.Timestamp create_time = 2;
inline bool Rollout::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool Rollout::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Rollout::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Rollout::create_time() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Rollout.create_time)
  return _internal_create_time();
}
inline void Rollout::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.Rollout.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Rollout::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Rollout::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.Rollout.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Rollout::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Rollout::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.Rollout.create_time)
  return _msg;
}
inline void Rollout::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.Rollout.create_time)
}

// string created_by = 3;
inline void Rollout::clear_created_by() {
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& Rollout::created_by() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Rollout.created_by)
  return _internal_created_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rollout::set_created_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.Rollout.created_by)
}
inline std::string* Rollout::mutable_created_by() {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.Rollout.created_by)
  return _s;
}
inline const std::string& Rollout::_internal_created_by() const {
  return _impl_.created_by_.Get();
}
inline void Rollout::_internal_set_created_by(const std::string& value) {
  
  _impl_.created_by_.Set(value, GetArenaForAllocation());
}
inline std::string* Rollout::_internal_mutable_created_by() {
  
  return _impl_.created_by_.Mutable(GetArenaForAllocation());
}
inline std::string* Rollout::release_created_by() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.Rollout.created_by)
  return _impl_.created_by_.Release();
}
inline void Rollout::set_allocated_created_by(std::string* created_by) {
  if (created_by != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_.SetAllocated(created_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.Rollout.created_by)
}

// .google.api.servicemanagement.v1.Rollout.RolloutStatus status = 4;
inline void Rollout::clear_status() {
  _impl_.status_ = 0;
}
inline ::google::api::servicemanagement::v1::Rollout_RolloutStatus Rollout::_internal_status() const {
  return static_cast< ::google::api::servicemanagement::v1::Rollout_RolloutStatus >(_impl_.status_);
}
inline ::google::api::servicemanagement::v1::Rollout_RolloutStatus Rollout::status() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Rollout.status)
  return _internal_status();
}
inline void Rollout::_internal_set_status(::google::api::servicemanagement::v1::Rollout_RolloutStatus value) {
  
  _impl_.status_ = value;
}
inline void Rollout::set_status(::google::api::servicemanagement::v1::Rollout_RolloutStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.Rollout.status)
}

// .google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy traffic_percent_strategy = 5;
inline bool Rollout::_internal_has_traffic_percent_strategy() const {
  return strategy_case() == kTrafficPercentStrategy;
}
inline bool Rollout::has_traffic_percent_strategy() const {
  return _internal_has_traffic_percent_strategy();
}
inline void Rollout::set_has_traffic_percent_strategy() {
  _impl_._oneof_case_[0] = kTrafficPercentStrategy;
}
inline void Rollout::clear_traffic_percent_strategy() {
  if (_internal_has_traffic_percent_strategy()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.strategy_.traffic_percent_strategy_;
    }
    clear_has_strategy();
  }
}
inline ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* Rollout::release_traffic_percent_strategy() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.Rollout.traffic_percent_strategy)
  if (_internal_has_traffic_percent_strategy()) {
    clear_has_strategy();
    ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* temp = _impl_.strategy_.traffic_percent_strategy_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.strategy_.traffic_percent_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy& Rollout::_internal_traffic_percent_strategy() const {
  return _internal_has_traffic_percent_strategy()
      ? *_impl_.strategy_.traffic_percent_strategy_
      : reinterpret_cast< ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy&>(::google::api::servicemanagement::v1::_Rollout_TrafficPercentStrategy_default_instance_);
}
inline const ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy& Rollout::traffic_percent_strategy() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Rollout.traffic_percent_strategy)
  return _internal_traffic_percent_strategy();
}
inline ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* Rollout::unsafe_arena_release_traffic_percent_strategy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.api.servicemanagement.v1.Rollout.traffic_percent_strategy)
  if (_internal_has_traffic_percent_strategy()) {
    clear_has_strategy();
    ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* temp = _impl_.strategy_.traffic_percent_strategy_;
    _impl_.strategy_.traffic_percent_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rollout::unsafe_arena_set_allocated_traffic_percent_strategy(::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* traffic_percent_strategy) {
  clear_strategy();
  if (traffic_percent_strategy) {
    set_has_traffic_percent_strategy();
    _impl_.strategy_.traffic_percent_strategy_ = traffic_percent_strategy;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.Rollout.traffic_percent_strategy)
}
inline ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* Rollout::_internal_mutable_traffic_percent_strategy() {
  if (!_internal_has_traffic_percent_strategy()) {
    clear_strategy();
    set_has_traffic_percent_strategy();
    _impl_.strategy_.traffic_percent_strategy_ = CreateMaybeMessage< ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy >(GetArenaForAllocation());
  }
  return _impl_.strategy_.traffic_percent_strategy_;
}
inline ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* Rollout::mutable_traffic_percent_strategy() {
  ::google::api::servicemanagement::v1::Rollout_TrafficPercentStrategy* _msg = _internal_mutable_traffic_percent_strategy();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.Rollout.traffic_percent_strategy)
  return _msg;
}

// .google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy delete_service_strategy = 200;
inline bool Rollout::_internal_has_delete_service_strategy() const {
  return strategy_case() == kDeleteServiceStrategy;
}
inline bool Rollout::has_delete_service_strategy() const {
  return _internal_has_delete_service_strategy();
}
inline void Rollout::set_has_delete_service_strategy() {
  _impl_._oneof_case_[0] = kDeleteServiceStrategy;
}
inline void Rollout::clear_delete_service_strategy() {
  if (_internal_has_delete_service_strategy()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.strategy_.delete_service_strategy_;
    }
    clear_has_strategy();
  }
}
inline ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* Rollout::release_delete_service_strategy() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.Rollout.delete_service_strategy)
  if (_internal_has_delete_service_strategy()) {
    clear_has_strategy();
    ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* temp = _impl_.strategy_.delete_service_strategy_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.strategy_.delete_service_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy& Rollout::_internal_delete_service_strategy() const {
  return _internal_has_delete_service_strategy()
      ? *_impl_.strategy_.delete_service_strategy_
      : reinterpret_cast< ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy&>(::google::api::servicemanagement::v1::_Rollout_DeleteServiceStrategy_default_instance_);
}
inline const ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy& Rollout::delete_service_strategy() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Rollout.delete_service_strategy)
  return _internal_delete_service_strategy();
}
inline ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* Rollout::unsafe_arena_release_delete_service_strategy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.api.servicemanagement.v1.Rollout.delete_service_strategy)
  if (_internal_has_delete_service_strategy()) {
    clear_has_strategy();
    ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* temp = _impl_.strategy_.delete_service_strategy_;
    _impl_.strategy_.delete_service_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rollout::unsafe_arena_set_allocated_delete_service_strategy(::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* delete_service_strategy) {
  clear_strategy();
  if (delete_service_strategy) {
    set_has_delete_service_strategy();
    _impl_.strategy_.delete_service_strategy_ = delete_service_strategy;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.api.servicemanagement.v1.Rollout.delete_service_strategy)
}
inline ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* Rollout::_internal_mutable_delete_service_strategy() {
  if (!_internal_has_delete_service_strategy()) {
    clear_strategy();
    set_has_delete_service_strategy();
    _impl_.strategy_.delete_service_strategy_ = CreateMaybeMessage< ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy >(GetArenaForAllocation());
  }
  return _impl_.strategy_.delete_service_strategy_;
}
inline ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* Rollout::mutable_delete_service_strategy() {
  ::google::api::servicemanagement::v1::Rollout_DeleteServiceStrategy* _msg = _internal_mutable_delete_service_strategy();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.Rollout.delete_service_strategy)
  return _msg;
}

// string service_name = 8;
inline void Rollout::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& Rollout::service_name() const {
  // @@protoc_insertion_point(field_get:google.api.servicemanagement.v1.Rollout.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rollout::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.api.servicemanagement.v1.Rollout.service_name)
}
inline std::string* Rollout::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.api.servicemanagement.v1.Rollout.service_name)
  return _s;
}
inline const std::string& Rollout::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void Rollout::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Rollout::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Rollout::release_service_name() {
  // @@protoc_insertion_point(field_release:google.api.servicemanagement.v1.Rollout.service_name)
  return _impl_.service_name_.Release();
}
inline void Rollout::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.api.servicemanagement.v1.Rollout.service_name)
}

inline bool Rollout::has_strategy() const {
  return strategy_case() != STRATEGY_NOT_SET;
}
inline void Rollout::clear_has_strategy() {
  _impl_._oneof_case_[0] = STRATEGY_NOT_SET;
}
inline Rollout::StrategyCase Rollout::strategy_case() const {
  return Rollout::StrategyCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace servicemanagement
}  // namespace api
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::api::servicemanagement::v1::OperationMetadata_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::api::servicemanagement::v1::OperationMetadata_Status>() {
  return ::google::api::servicemanagement::v1::OperationMetadata_Status_descriptor();
}
template <> struct is_proto_enum< ::google::api::servicemanagement::v1::Diagnostic_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::api::servicemanagement::v1::Diagnostic_Kind>() {
  return ::google::api::servicemanagement::v1::Diagnostic_Kind_descriptor();
}
template <> struct is_proto_enum< ::google::api::servicemanagement::v1::ConfigFile_FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::api::servicemanagement::v1::ConfigFile_FileType>() {
  return ::google::api::servicemanagement::v1::ConfigFile_FileType_descriptor();
}
template <> struct is_proto_enum< ::google::api::servicemanagement::v1::Rollout_RolloutStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::api::servicemanagement::v1::Rollout_RolloutStatus>() {
  return ::google::api::servicemanagement::v1::Rollout_RolloutStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fapi_2fservicemanagement_2fv1_2fresources_2eproto
