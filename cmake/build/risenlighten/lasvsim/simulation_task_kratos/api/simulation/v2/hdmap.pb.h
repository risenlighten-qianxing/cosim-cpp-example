// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: risenlighten/lasvsim/simulation_task_kratos/api/simulation/v2/hdmap.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
namespace risenlighten {
namespace lasvsim {
namespace simulation_task_kratos {
namespace api {
namespace simulation {
namespace v2 {
class Crosswalk;
struct CrosswalkDefaultTypeInternal;
extern CrosswalkDefaultTypeInternal _Crosswalk_default_instance_;
class Hdtrafficmap;
struct HdtrafficmapDefaultTypeInternal;
extern HdtrafficmapDefaultTypeInternal _Hdtrafficmap_default_instance_;
class Junction;
struct JunctionDefaultTypeInternal;
extern JunctionDefaultTypeInternal _Junction_default_instance_;
class Lane;
struct LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class Link;
struct LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Segment;
struct SegmentDefaultTypeInternal;
extern SegmentDefaultTypeInternal _Segment_default_instance_;
class Sign;
struct SignDefaultTypeInternal;
extern SignDefaultTypeInternal _Sign_default_instance_;
class Stopline;
struct StoplineDefaultTypeInternal;
extern StoplineDefaultTypeInternal _Stopline_default_instance_;
}  // namespace v2
}  // namespace simulation
}  // namespace api
}  // namespace simulation_task_kratos
}  // namespace lasvsim
}  // namespace risenlighten
PROTOBUF_NAMESPACE_OPEN
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Hdtrafficmap* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Hdtrafficmap>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace risenlighten {
namespace lasvsim {
namespace simulation_task_kratos {
namespace api {
namespace simulation {
namespace v2 {

// ===================================================================

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
};
// -------------------------------------------------------------------

class Junction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction) */ {
 public:
  inline Junction() : Junction(nullptr) {}
  ~Junction() override;
  explicit PROTOBUF_CONSTEXPR Junction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Junction(const Junction& from);
  Junction(Junction&& from) noexcept
    : Junction() {
    *this = ::std::move(from);
  }

  inline Junction& operator=(const Junction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Junction& operator=(Junction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Junction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Junction* internal_default_instance() {
    return reinterpret_cast<const Junction*>(
               &_Junction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Junction& a, Junction& b) {
    a.Swap(&b);
  }
  inline void Swap(Junction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Junction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Junction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Junction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Junction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Junction& from) {
    Junction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Junction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction";
  }
  protected:
  explicit Junction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJunctionLinkIdsFieldNumber = 2,
    kShapeFieldNumber = 3,
    kJunctionIdFieldNumber = 1,
  };
  // repeated string junction_link_ids = 2;
  int junction_link_ids_size() const;
  private:
  int _internal_junction_link_ids_size() const;
  public:
  void clear_junction_link_ids();
  const std::string& junction_link_ids(int index) const;
  std::string* mutable_junction_link_ids(int index);
  void set_junction_link_ids(int index, const std::string& value);
  void set_junction_link_ids(int index, std::string&& value);
  void set_junction_link_ids(int index, const char* value);
  void set_junction_link_ids(int index, const char* value, size_t size);
  std::string* add_junction_link_ids();
  void add_junction_link_ids(const std::string& value);
  void add_junction_link_ids(std::string&& value);
  void add_junction_link_ids(const char* value);
  void add_junction_link_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& junction_link_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_junction_link_ids();
  private:
  const std::string& _internal_junction_link_ids(int index) const;
  std::string* _internal_add_junction_link_ids();
  public:

  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* mutable_shape(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
      mutable_shape();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& _internal_shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _internal_add_shape();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* add_shape();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
      shape() const;

  // string junction_id = 1;
  void clear_junction_id();
  const std::string& junction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_junction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_junction_id();
  PROTOBUF_NODISCARD std::string* release_junction_id();
  void set_allocated_junction_id(std::string* junction_id);
  private:
  const std::string& _internal_junction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_junction_id(const std::string& value);
  std::string* _internal_mutable_junction_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> junction_link_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point > shape_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr junction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
};
// -------------------------------------------------------------------

class Segment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment) */ {
 public:
  inline Segment() : Segment(nullptr) {}
  ~Segment() override;
  explicit PROTOBUF_CONSTEXPR Segment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Segment(const Segment& from);
  Segment(Segment&& from) noexcept
    : Segment() {
    *this = ::std::move(from);
  }

  inline Segment& operator=(const Segment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Segment& operator=(Segment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Segment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Segment* internal_default_instance() {
    return reinterpret_cast<const Segment*>(
               &_Segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Segment& a, Segment& b) {
    a.Swap(&b);
  }
  inline void Swap(Segment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Segment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Segment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Segment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Segment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Segment& from) {
    Segment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Segment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment";
  }
  protected:
  explicit Segment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderedLinkIdsFieldNumber = 3,
    kSegmentIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kStartJunctionIdFieldNumber = 4,
    kEndJunctionIdFieldNumber = 5,
    kLengthFieldNumber = 6,
  };
  // repeated string ordered_link_ids = 3;
  int ordered_link_ids_size() const;
  private:
  int _internal_ordered_link_ids_size() const;
  public:
  void clear_ordered_link_ids();
  const std::string& ordered_link_ids(int index) const;
  std::string* mutable_ordered_link_ids(int index);
  void set_ordered_link_ids(int index, const std::string& value);
  void set_ordered_link_ids(int index, std::string&& value);
  void set_ordered_link_ids(int index, const char* value);
  void set_ordered_link_ids(int index, const char* value, size_t size);
  std::string* add_ordered_link_ids();
  void add_ordered_link_ids(const std::string& value);
  void add_ordered_link_ids(std::string&& value);
  void add_ordered_link_ids(const char* value);
  void add_ordered_link_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ordered_link_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ordered_link_ids();
  private:
  const std::string& _internal_ordered_link_ids(int index) const;
  std::string* _internal_add_ordered_link_ids();
  public:

  // string segment_id = 1;
  void clear_segment_id();
  const std::string& segment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* segment_id);
  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(const std::string& value);
  std::string* _internal_mutable_segment_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string start_junction_id = 4;
  void clear_start_junction_id();
  const std::string& start_junction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_junction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_junction_id();
  PROTOBUF_NODISCARD std::string* release_start_junction_id();
  void set_allocated_start_junction_id(std::string* start_junction_id);
  private:
  const std::string& _internal_start_junction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_junction_id(const std::string& value);
  std::string* _internal_mutable_start_junction_id();
  public:

  // string end_junction_id = 5;
  void clear_end_junction_id();
  const std::string& end_junction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_junction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_junction_id();
  PROTOBUF_NODISCARD std::string* release_end_junction_id();
  void set_allocated_end_junction_id(std::string* end_junction_id);
  private:
  const std::string& _internal_end_junction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_junction_id(const std::string& value);
  std::string* _internal_mutable_end_junction_id();
  public:

  // double length = 6;
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ordered_link_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segment_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_junction_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_junction_id_;
    double length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
};
// -------------------------------------------------------------------

class Link final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link) */ {
 public:
  inline Link() : Link(nullptr) {}
  ~Link() override;
  explicit PROTOBUF_CONSTEXPR Link(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Link(const Link& from);
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Link& operator=(Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Link* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Link>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Link& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Link& from) {
    Link::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Link* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link";
  }
  protected:
  explicit Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderedLaneIdsFieldNumber = 2,
    kShapeFieldNumber = 3,
    kRightShapeFieldNumber = 4,
    kLinkIdFieldNumber = 1,
    kSegmentIdFieldNumber = 5,
  };
  // repeated string ordered_lane_ids = 2;
  int ordered_lane_ids_size() const;
  private:
  int _internal_ordered_lane_ids_size() const;
  public:
  void clear_ordered_lane_ids();
  const std::string& ordered_lane_ids(int index) const;
  std::string* mutable_ordered_lane_ids(int index);
  void set_ordered_lane_ids(int index, const std::string& value);
  void set_ordered_lane_ids(int index, std::string&& value);
  void set_ordered_lane_ids(int index, const char* value);
  void set_ordered_lane_ids(int index, const char* value, size_t size);
  std::string* add_ordered_lane_ids();
  void add_ordered_lane_ids(const std::string& value);
  void add_ordered_lane_ids(std::string&& value);
  void add_ordered_lane_ids(const char* value);
  void add_ordered_lane_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ordered_lane_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ordered_lane_ids();
  private:
  const std::string& _internal_ordered_lane_ids(int index) const;
  std::string* _internal_add_ordered_lane_ids();
  public:

  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* mutable_shape(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
      mutable_shape();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& _internal_shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _internal_add_shape();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* add_shape();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
      shape() const;

  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point right_shape = 4;
  int right_shape_size() const;
  private:
  int _internal_right_shape_size() const;
  public:
  void clear_right_shape();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* mutable_right_shape(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
      mutable_right_shape();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& _internal_right_shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _internal_add_right_shape();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& right_shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* add_right_shape();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
      right_shape() const;

  // string link_id = 1;
  void clear_link_id();
  const std::string& link_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link_id();
  PROTOBUF_NODISCARD std::string* release_link_id();
  void set_allocated_link_id(std::string* link_id);
  private:
  const std::string& _internal_link_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_id(const std::string& value);
  std::string* _internal_mutable_link_id();
  public:

  // string segment_id = 5;
  void clear_segment_id();
  const std::string& segment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* segment_id);
  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(const std::string& value);
  std::string* _internal_mutable_segment_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ordered_lane_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point > shape_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point > right_shape_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segment_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
};
// -------------------------------------------------------------------

class Sign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign) */ {
 public:
  inline Sign() : Sign(nullptr) {}
  ~Sign() override;
  explicit PROTOBUF_CONSTEXPR Sign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sign(const Sign& from);
  Sign(Sign&& from) noexcept
    : Sign() {
    *this = ::std::move(from);
  }

  inline Sign& operator=(const Sign& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sign& operator=(Sign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sign& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sign* internal_default_instance() {
    return reinterpret_cast<const Sign*>(
               &_Sign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Sign& a, Sign& b) {
    a.Swap(&b);
  }
  inline void Swap(Sign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sign& from) {
    Sign::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign";
  }
  protected:
  explicit Sign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTurnFieldNumber = 1,
    kPositionFieldNumber = 2,
    kHeadingFieldNumber = 3,
  };
  // string turn = 1;
  void clear_turn();
  const std::string& turn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_turn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_turn();
  PROTOBUF_NODISCARD std::string* release_turn();
  void set_allocated_turn(std::string* turn);
  private:
  const std::string& _internal_turn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_turn(const std::string& value);
  std::string* _internal_mutable_turn();
  public:

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& position() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* release_position();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* mutable_position();
  void set_allocated_position(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* position);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& _internal_position() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* position);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* unsafe_arena_release_position();

  // double heading = 3;
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr turn_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* position_;
    double heading_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
};
// -------------------------------------------------------------------

class Lane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane) */ {
 public:
  inline Lane() : Lane(nullptr) {}
  ~Lane() override;
  explicit PROTOBUF_CONSTEXPR Lane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lane(const Lane& from);
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lane& operator=(Lane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }
  inline void Swap(Lane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Lane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Lane& from) {
    Lane::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane";
  }
  protected:
  explicit Lane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 5,
    kConnectLinkIdsFieldNumber = 9,
    kCenterLineFieldNumber = 10,
    kLaneIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kLineTypeFieldNumber = 3,
    kLineColorFieldNumber = 4,
    kLinkIdFieldNumber = 7,
    kSignFieldNumber = 8,
    kLaneOffsetFieldNumber = 6,
  };
  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 5;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* mutable_shape(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
      mutable_shape();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& _internal_shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _internal_add_shape();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* add_shape();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
      shape() const;

  // repeated string connect_link_ids = 9;
  int connect_link_ids_size() const;
  private:
  int _internal_connect_link_ids_size() const;
  public:
  void clear_connect_link_ids();
  const std::string& connect_link_ids(int index) const;
  std::string* mutable_connect_link_ids(int index);
  void set_connect_link_ids(int index, const std::string& value);
  void set_connect_link_ids(int index, std::string&& value);
  void set_connect_link_ids(int index, const char* value);
  void set_connect_link_ids(int index, const char* value, size_t size);
  std::string* add_connect_link_ids();
  void add_connect_link_ids(const std::string& value);
  void add_connect_link_ids(std::string&& value);
  void add_connect_link_ids(const char* value);
  void add_connect_link_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& connect_link_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_connect_link_ids();
  private:
  const std::string& _internal_connect_link_ids(int index) const;
  std::string* _internal_add_connect_link_ids();
  public:

  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point center_line = 10;
  int center_line_size() const;
  private:
  int _internal_center_line_size() const;
  public:
  void clear_center_line();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* mutable_center_line(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
      mutable_center_line();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& _internal_center_line(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _internal_add_center_line();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& center_line(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* add_center_line();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
      center_line() const;

  // string lane_id = 1;
  void clear_lane_id();
  const std::string& lane_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lane_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lane_id();
  PROTOBUF_NODISCARD std::string* release_lane_id();
  void set_allocated_lane_id(std::string* lane_id);
  private:
  const std::string& _internal_lane_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lane_id(const std::string& value);
  std::string* _internal_mutable_lane_id();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string line_type = 3;
  void clear_line_type();
  const std::string& line_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line_type();
  PROTOBUF_NODISCARD std::string* release_line_type();
  void set_allocated_line_type(std::string* line_type);
  private:
  const std::string& _internal_line_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line_type(const std::string& value);
  std::string* _internal_mutable_line_type();
  public:

  // string line_color = 4;
  void clear_line_color();
  const std::string& line_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line_color();
  PROTOBUF_NODISCARD std::string* release_line_color();
  void set_allocated_line_color(std::string* line_color);
  private:
  const std::string& _internal_line_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line_color(const std::string& value);
  std::string* _internal_mutable_line_color();
  public:

  // string link_id = 7;
  void clear_link_id();
  const std::string& link_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link_id();
  PROTOBUF_NODISCARD std::string* release_link_id();
  void set_allocated_link_id(std::string* link_id);
  private:
  const std::string& _internal_link_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_id(const std::string& value);
  std::string* _internal_mutable_link_id();
  public:

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign sign = 8;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign& sign() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* release_sign();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* mutable_sign();
  void set_allocated_sign(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* sign);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign& _internal_sign() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* sign);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* unsafe_arena_release_sign();

  // uint32 lane_offset = 6;
  void clear_lane_offset();
  uint32_t lane_offset() const;
  void set_lane_offset(uint32_t value);
  private:
  uint32_t _internal_lane_offset() const;
  void _internal_set_lane_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point > shape_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> connect_link_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point > center_line_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lane_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_color_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_id_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* sign_;
    uint32_t lane_offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
};
// -------------------------------------------------------------------

class Crosswalk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk) */ {
 public:
  inline Crosswalk() : Crosswalk(nullptr) {}
  ~Crosswalk() override;
  explicit PROTOBUF_CONSTEXPR Crosswalk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Crosswalk(const Crosswalk& from);
  Crosswalk(Crosswalk&& from) noexcept
    : Crosswalk() {
    *this = ::std::move(from);
  }

  inline Crosswalk& operator=(const Crosswalk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Crosswalk& operator=(Crosswalk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Crosswalk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Crosswalk* internal_default_instance() {
    return reinterpret_cast<const Crosswalk*>(
               &_Crosswalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Crosswalk& a, Crosswalk& b) {
    a.Swap(&b);
  }
  inline void Swap(Crosswalk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Crosswalk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Crosswalk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Crosswalk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Crosswalk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Crosswalk& from) {
    Crosswalk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Crosswalk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk";
  }
  protected:
  explicit Crosswalk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kCrosswalkIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* mutable_shape(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
      mutable_shape();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& _internal_shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _internal_add_shape();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* add_shape();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
      shape() const;

  // string crosswalk_id = 1;
  void clear_crosswalk_id();
  const std::string& crosswalk_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_crosswalk_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_crosswalk_id();
  PROTOBUF_NODISCARD std::string* release_crosswalk_id();
  void set_allocated_crosswalk_id(std::string* crosswalk_id);
  private:
  const std::string& _internal_crosswalk_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_crosswalk_id(const std::string& value);
  std::string* _internal_mutable_crosswalk_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point > shape_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crosswalk_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
};
// -------------------------------------------------------------------

class Stopline final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline) */ {
 public:
  inline Stopline() : Stopline(nullptr) {}
  ~Stopline() override;
  explicit PROTOBUF_CONSTEXPR Stopline(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stopline(const Stopline& from);
  Stopline(Stopline&& from) noexcept
    : Stopline() {
    *this = ::std::move(from);
  }

  inline Stopline& operator=(const Stopline& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stopline& operator=(Stopline&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stopline& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stopline* internal_default_instance() {
    return reinterpret_cast<const Stopline*>(
               &_Stopline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Stopline& a, Stopline& b) {
    a.Swap(&b);
  }
  inline void Swap(Stopline* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stopline* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stopline* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stopline>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stopline& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stopline& from) {
    Stopline::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stopline* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline";
  }
  protected:
  explicit Stopline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kObjIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* mutable_shape(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
      mutable_shape();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& _internal_shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _internal_add_shape();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& shape(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* add_shape();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
      shape() const;

  // string obj_id = 1;
  void clear_obj_id();
  const std::string& obj_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obj_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obj_id();
  PROTOBUF_NODISCARD std::string* release_obj_id();
  void set_allocated_obj_id(std::string* obj_id);
  private:
  const std::string& _internal_obj_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obj_id(const std::string& value);
  std::string* _internal_mutable_obj_id();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point > shape_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obj_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
};
// -------------------------------------------------------------------

class Hdtrafficmap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap) */ {
 public:
  inline Hdtrafficmap() : Hdtrafficmap(nullptr) {}
  ~Hdtrafficmap() override;
  explicit PROTOBUF_CONSTEXPR Hdtrafficmap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hdtrafficmap(const Hdtrafficmap& from);
  Hdtrafficmap(Hdtrafficmap&& from) noexcept
    : Hdtrafficmap() {
    *this = ::std::move(from);
  }

  inline Hdtrafficmap& operator=(const Hdtrafficmap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hdtrafficmap& operator=(Hdtrafficmap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hdtrafficmap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hdtrafficmap* internal_default_instance() {
    return reinterpret_cast<const Hdtrafficmap*>(
               &_Hdtrafficmap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Hdtrafficmap& a, Hdtrafficmap& b) {
    a.Swap(&b);
  }
  inline void Swap(Hdtrafficmap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hdtrafficmap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hdtrafficmap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hdtrafficmap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hdtrafficmap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hdtrafficmap& from) {
    Hdtrafficmap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hdtrafficmap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap";
  }
  protected:
  explicit Hdtrafficmap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJunctionsFieldNumber = 1,
    kSegmentsFieldNumber = 2,
    kLinksFieldNumber = 3,
    kLanesFieldNumber = 4,
    kCrosswalksFieldNumber = 5,
    kStoplinesFieldNumber = 6,
  };
  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction junctions = 1;
  int junctions_size() const;
  private:
  int _internal_junctions_size() const;
  public:
  void clear_junctions();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* mutable_junctions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >*
      mutable_junctions();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction& _internal_junctions(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* _internal_add_junctions();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction& junctions(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* add_junctions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >&
      junctions() const;

  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment segments = 2;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >*
      mutable_segments();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment& _internal_segments(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* _internal_add_segments();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment& segments(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >&
      segments() const;

  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link links = 3;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >*
      mutable_links();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link& _internal_links(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* _internal_add_links();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link& links(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >&
      links() const;

  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane lanes = 4;
  int lanes_size() const;
  private:
  int _internal_lanes_size() const;
  public:
  void clear_lanes();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* mutable_lanes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >*
      mutable_lanes();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane& _internal_lanes(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* _internal_add_lanes();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane& lanes(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* add_lanes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >&
      lanes() const;

  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk crosswalks = 5;
  int crosswalks_size() const;
  private:
  int _internal_crosswalks_size() const;
  public:
  void clear_crosswalks();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk* mutable_crosswalks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >*
      mutable_crosswalks();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk& _internal_crosswalks(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk* _internal_add_crosswalks();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk& crosswalks(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk* add_crosswalks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >&
      crosswalks() const;

  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline stoplines = 6;
  int stoplines_size() const;
  private:
  int _internal_stoplines_size() const;
  public:
  void clear_stoplines();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline* mutable_stoplines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >*
      mutable_stoplines();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline& _internal_stoplines(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline* _internal_add_stoplines();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline& stoplines(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline* add_stoplines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >&
      stoplines() const;

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction > junctions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment > segments_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link > links_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane > lanes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk > crosswalks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline > stoplines_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// double x = 1;
inline void Point::clear_x() {
  _impl_.x_ = 0;
}
inline double Point::_internal_x() const {
  return _impl_.x_;
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Point::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point.x)
}

// double y = 2;
inline void Point::clear_y() {
  _impl_.y_ = 0;
}
inline double Point::_internal_y() const {
  return _impl_.y_;
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Point::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point.y)
}

// -------------------------------------------------------------------

// Junction

// string junction_id = 1;
inline void Junction::clear_junction_id() {
  _impl_.junction_id_.ClearToEmpty();
}
inline const std::string& Junction::junction_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_id)
  return _internal_junction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Junction::set_junction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.junction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_id)
}
inline std::string* Junction::mutable_junction_id() {
  std::string* _s = _internal_mutable_junction_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_id)
  return _s;
}
inline const std::string& Junction::_internal_junction_id() const {
  return _impl_.junction_id_.Get();
}
inline void Junction::_internal_set_junction_id(const std::string& value) {
  
  _impl_.junction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Junction::_internal_mutable_junction_id() {
  
  return _impl_.junction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Junction::release_junction_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_id)
  return _impl_.junction_id_.Release();
}
inline void Junction::set_allocated_junction_id(std::string* junction_id) {
  if (junction_id != nullptr) {
    
  } else {
    
  }
  _impl_.junction_id_.SetAllocated(junction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.junction_id_.IsDefault()) {
    _impl_.junction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_id)
}

// repeated string junction_link_ids = 2;
inline int Junction::_internal_junction_link_ids_size() const {
  return _impl_.junction_link_ids_.size();
}
inline int Junction::junction_link_ids_size() const {
  return _internal_junction_link_ids_size();
}
inline void Junction::clear_junction_link_ids() {
  _impl_.junction_link_ids_.Clear();
}
inline std::string* Junction::add_junction_link_ids() {
  std::string* _s = _internal_add_junction_link_ids();
  // @@protoc_insertion_point(field_add_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
  return _s;
}
inline const std::string& Junction::_internal_junction_link_ids(int index) const {
  return _impl_.junction_link_ids_.Get(index);
}
inline const std::string& Junction::junction_link_ids(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
  return _internal_junction_link_ids(index);
}
inline std::string* Junction::mutable_junction_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
  return _impl_.junction_link_ids_.Mutable(index);
}
inline void Junction::set_junction_link_ids(int index, const std::string& value) {
  _impl_.junction_link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
}
inline void Junction::set_junction_link_ids(int index, std::string&& value) {
  _impl_.junction_link_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
}
inline void Junction::set_junction_link_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.junction_link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
}
inline void Junction::set_junction_link_ids(int index, const char* value, size_t size) {
  _impl_.junction_link_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
}
inline std::string* Junction::_internal_add_junction_link_ids() {
  return _impl_.junction_link_ids_.Add();
}
inline void Junction::add_junction_link_ids(const std::string& value) {
  _impl_.junction_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
}
inline void Junction::add_junction_link_ids(std::string&& value) {
  _impl_.junction_link_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
}
inline void Junction::add_junction_link_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.junction_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
}
inline void Junction::add_junction_link_ids(const char* value, size_t size) {
  _impl_.junction_link_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Junction::junction_link_ids() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
  return _impl_.junction_link_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Junction::mutable_junction_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.junction_link_ids)
  return &_impl_.junction_link_ids_;
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 3;
inline int Junction::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Junction::shape_size() const {
  return _internal_shape_size();
}
inline void Junction::clear_shape() {
  _impl_.shape_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Junction::mutable_shape(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.shape)
  return _impl_.shape_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
Junction::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.shape)
  return &_impl_.shape_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Junction::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Junction::shape(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.shape)
  return _internal_shape(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Junction::_internal_add_shape() {
  return _impl_.shape_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Junction::add_shape() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _add = _internal_add_shape();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.shape)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
Junction::shape() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction.shape)
  return _impl_.shape_;
}

// -------------------------------------------------------------------

// Segment

// string segment_id = 1;
inline void Segment::clear_segment_id() {
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& Segment::segment_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.segment_id)
  return _internal_segment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Segment::set_segment_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.segment_id)
}
inline std::string* Segment::mutable_segment_id() {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.segment_id)
  return _s;
}
inline const std::string& Segment::_internal_segment_id() const {
  return _impl_.segment_id_.Get();
}
inline void Segment::_internal_set_segment_id(const std::string& value) {
  
  _impl_.segment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Segment::_internal_mutable_segment_id() {
  
  return _impl_.segment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Segment::release_segment_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.segment_id)
  return _impl_.segment_id_.Release();
}
inline void Segment::set_allocated_segment_id(std::string* segment_id) {
  if (segment_id != nullptr) {
    
  } else {
    
  }
  _impl_.segment_id_.SetAllocated(segment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.segment_id)
}

// string name = 2;
inline void Segment::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Segment::name() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Segment::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.name)
}
inline std::string* Segment::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.name)
  return _s;
}
inline const std::string& Segment::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Segment::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Segment::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Segment::release_name() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.name)
  return _impl_.name_.Release();
}
inline void Segment::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.name)
}

// repeated string ordered_link_ids = 3;
inline int Segment::_internal_ordered_link_ids_size() const {
  return _impl_.ordered_link_ids_.size();
}
inline int Segment::ordered_link_ids_size() const {
  return _internal_ordered_link_ids_size();
}
inline void Segment::clear_ordered_link_ids() {
  _impl_.ordered_link_ids_.Clear();
}
inline std::string* Segment::add_ordered_link_ids() {
  std::string* _s = _internal_add_ordered_link_ids();
  // @@protoc_insertion_point(field_add_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
  return _s;
}
inline const std::string& Segment::_internal_ordered_link_ids(int index) const {
  return _impl_.ordered_link_ids_.Get(index);
}
inline const std::string& Segment::ordered_link_ids(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
  return _internal_ordered_link_ids(index);
}
inline std::string* Segment::mutable_ordered_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
  return _impl_.ordered_link_ids_.Mutable(index);
}
inline void Segment::set_ordered_link_ids(int index, const std::string& value) {
  _impl_.ordered_link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
}
inline void Segment::set_ordered_link_ids(int index, std::string&& value) {
  _impl_.ordered_link_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
}
inline void Segment::set_ordered_link_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ordered_link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
}
inline void Segment::set_ordered_link_ids(int index, const char* value, size_t size) {
  _impl_.ordered_link_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
}
inline std::string* Segment::_internal_add_ordered_link_ids() {
  return _impl_.ordered_link_ids_.Add();
}
inline void Segment::add_ordered_link_ids(const std::string& value) {
  _impl_.ordered_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
}
inline void Segment::add_ordered_link_ids(std::string&& value) {
  _impl_.ordered_link_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
}
inline void Segment::add_ordered_link_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ordered_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
}
inline void Segment::add_ordered_link_ids(const char* value, size_t size) {
  _impl_.ordered_link_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Segment::ordered_link_ids() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
  return _impl_.ordered_link_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Segment::mutable_ordered_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.ordered_link_ids)
  return &_impl_.ordered_link_ids_;
}

// string start_junction_id = 4;
inline void Segment::clear_start_junction_id() {
  _impl_.start_junction_id_.ClearToEmpty();
}
inline const std::string& Segment::start_junction_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.start_junction_id)
  return _internal_start_junction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Segment::set_start_junction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_junction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.start_junction_id)
}
inline std::string* Segment::mutable_start_junction_id() {
  std::string* _s = _internal_mutable_start_junction_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.start_junction_id)
  return _s;
}
inline const std::string& Segment::_internal_start_junction_id() const {
  return _impl_.start_junction_id_.Get();
}
inline void Segment::_internal_set_start_junction_id(const std::string& value) {
  
  _impl_.start_junction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Segment::_internal_mutable_start_junction_id() {
  
  return _impl_.start_junction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Segment::release_start_junction_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.start_junction_id)
  return _impl_.start_junction_id_.Release();
}
inline void Segment::set_allocated_start_junction_id(std::string* start_junction_id) {
  if (start_junction_id != nullptr) {
    
  } else {
    
  }
  _impl_.start_junction_id_.SetAllocated(start_junction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_junction_id_.IsDefault()) {
    _impl_.start_junction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.start_junction_id)
}

// string end_junction_id = 5;
inline void Segment::clear_end_junction_id() {
  _impl_.end_junction_id_.ClearToEmpty();
}
inline const std::string& Segment::end_junction_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.end_junction_id)
  return _internal_end_junction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Segment::set_end_junction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.end_junction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.end_junction_id)
}
inline std::string* Segment::mutable_end_junction_id() {
  std::string* _s = _internal_mutable_end_junction_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.end_junction_id)
  return _s;
}
inline const std::string& Segment::_internal_end_junction_id() const {
  return _impl_.end_junction_id_.Get();
}
inline void Segment::_internal_set_end_junction_id(const std::string& value) {
  
  _impl_.end_junction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Segment::_internal_mutable_end_junction_id() {
  
  return _impl_.end_junction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Segment::release_end_junction_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.end_junction_id)
  return _impl_.end_junction_id_.Release();
}
inline void Segment::set_allocated_end_junction_id(std::string* end_junction_id) {
  if (end_junction_id != nullptr) {
    
  } else {
    
  }
  _impl_.end_junction_id_.SetAllocated(end_junction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_junction_id_.IsDefault()) {
    _impl_.end_junction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.end_junction_id)
}

// double length = 6;
inline void Segment::clear_length() {
  _impl_.length_ = 0;
}
inline double Segment::_internal_length() const {
  return _impl_.length_;
}
inline double Segment::length() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.length)
  return _internal_length();
}
inline void Segment::_internal_set_length(double value) {
  
  _impl_.length_ = value;
}
inline void Segment::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment.length)
}

// -------------------------------------------------------------------

// Link

// string link_id = 1;
inline void Link::clear_link_id() {
  _impl_.link_id_.ClearToEmpty();
}
inline const std::string& Link::link_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.link_id)
  return _internal_link_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_link_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.link_id)
}
inline std::string* Link::mutable_link_id() {
  std::string* _s = _internal_mutable_link_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.link_id)
  return _s;
}
inline const std::string& Link::_internal_link_id() const {
  return _impl_.link_id_.Get();
}
inline void Link::_internal_set_link_id(const std::string& value) {
  
  _impl_.link_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_link_id() {
  
  return _impl_.link_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_link_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.link_id)
  return _impl_.link_id_.Release();
}
inline void Link::set_allocated_link_id(std::string* link_id) {
  if (link_id != nullptr) {
    
  } else {
    
  }
  _impl_.link_id_.SetAllocated(link_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_id_.IsDefault()) {
    _impl_.link_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.link_id)
}

// repeated string ordered_lane_ids = 2;
inline int Link::_internal_ordered_lane_ids_size() const {
  return _impl_.ordered_lane_ids_.size();
}
inline int Link::ordered_lane_ids_size() const {
  return _internal_ordered_lane_ids_size();
}
inline void Link::clear_ordered_lane_ids() {
  _impl_.ordered_lane_ids_.Clear();
}
inline std::string* Link::add_ordered_lane_ids() {
  std::string* _s = _internal_add_ordered_lane_ids();
  // @@protoc_insertion_point(field_add_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
  return _s;
}
inline const std::string& Link::_internal_ordered_lane_ids(int index) const {
  return _impl_.ordered_lane_ids_.Get(index);
}
inline const std::string& Link::ordered_lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
  return _internal_ordered_lane_ids(index);
}
inline std::string* Link::mutable_ordered_lane_ids(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
  return _impl_.ordered_lane_ids_.Mutable(index);
}
inline void Link::set_ordered_lane_ids(int index, const std::string& value) {
  _impl_.ordered_lane_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
}
inline void Link::set_ordered_lane_ids(int index, std::string&& value) {
  _impl_.ordered_lane_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
}
inline void Link::set_ordered_lane_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ordered_lane_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
}
inline void Link::set_ordered_lane_ids(int index, const char* value, size_t size) {
  _impl_.ordered_lane_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
}
inline std::string* Link::_internal_add_ordered_lane_ids() {
  return _impl_.ordered_lane_ids_.Add();
}
inline void Link::add_ordered_lane_ids(const std::string& value) {
  _impl_.ordered_lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
}
inline void Link::add_ordered_lane_ids(std::string&& value) {
  _impl_.ordered_lane_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
}
inline void Link::add_ordered_lane_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ordered_lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
}
inline void Link::add_ordered_lane_ids(const char* value, size_t size) {
  _impl_.ordered_lane_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Link::ordered_lane_ids() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
  return _impl_.ordered_lane_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Link::mutable_ordered_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.ordered_lane_ids)
  return &_impl_.ordered_lane_ids_;
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 3;
inline int Link::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Link::shape_size() const {
  return _internal_shape_size();
}
inline void Link::clear_shape() {
  _impl_.shape_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Link::mutable_shape(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.shape)
  return _impl_.shape_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
Link::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.shape)
  return &_impl_.shape_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Link::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Link::shape(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.shape)
  return _internal_shape(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Link::_internal_add_shape() {
  return _impl_.shape_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Link::add_shape() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _add = _internal_add_shape();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.shape)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
Link::shape() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.shape)
  return _impl_.shape_;
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point right_shape = 4;
inline int Link::_internal_right_shape_size() const {
  return _impl_.right_shape_.size();
}
inline int Link::right_shape_size() const {
  return _internal_right_shape_size();
}
inline void Link::clear_right_shape() {
  _impl_.right_shape_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Link::mutable_right_shape(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.right_shape)
  return _impl_.right_shape_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
Link::mutable_right_shape() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.right_shape)
  return &_impl_.right_shape_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Link::_internal_right_shape(int index) const {
  return _impl_.right_shape_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Link::right_shape(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.right_shape)
  return _internal_right_shape(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Link::_internal_add_right_shape() {
  return _impl_.right_shape_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Link::add_right_shape() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _add = _internal_add_right_shape();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.right_shape)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
Link::right_shape() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.right_shape)
  return _impl_.right_shape_;
}

// string segment_id = 5;
inline void Link::clear_segment_id() {
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& Link::segment_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.segment_id)
  return _internal_segment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_segment_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.segment_id)
}
inline std::string* Link::mutable_segment_id() {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.segment_id)
  return _s;
}
inline const std::string& Link::_internal_segment_id() const {
  return _impl_.segment_id_.Get();
}
inline void Link::_internal_set_segment_id(const std::string& value) {
  
  _impl_.segment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_segment_id() {
  
  return _impl_.segment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_segment_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.segment_id)
  return _impl_.segment_id_.Release();
}
inline void Link::set_allocated_segment_id(std::string* segment_id) {
  if (segment_id != nullptr) {
    
  } else {
    
  }
  _impl_.segment_id_.SetAllocated(segment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link.segment_id)
}

// -------------------------------------------------------------------

// Sign

// string turn = 1;
inline void Sign::clear_turn() {
  _impl_.turn_.ClearToEmpty();
}
inline const std::string& Sign::turn() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.turn)
  return _internal_turn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sign::set_turn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.turn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.turn)
}
inline std::string* Sign::mutable_turn() {
  std::string* _s = _internal_mutable_turn();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.turn)
  return _s;
}
inline const std::string& Sign::_internal_turn() const {
  return _impl_.turn_.Get();
}
inline void Sign::_internal_set_turn(const std::string& value) {
  
  _impl_.turn_.Set(value, GetArenaForAllocation());
}
inline std::string* Sign::_internal_mutable_turn() {
  
  return _impl_.turn_.Mutable(GetArenaForAllocation());
}
inline std::string* Sign::release_turn() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.turn)
  return _impl_.turn_.Release();
}
inline void Sign::set_allocated_turn(std::string* turn) {
  if (turn != nullptr) {
    
  } else {
    
  }
  _impl_.turn_.SetAllocated(turn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.turn_.IsDefault()) {
    _impl_.turn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.turn)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point position = 2;
inline bool Sign::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Sign::has_position() const {
  return _internal_has_position();
}
inline void Sign::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Sign::_internal_position() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Point_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Sign::position() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.position)
  return _internal_position();
}
inline void Sign::unsafe_arena_set_allocated_position(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.position)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Sign::release_position() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Sign::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.position)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Sign::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Sign::mutable_position() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.position)
  return _msg;
}
inline void Sign::set_allocated_position(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.position)
}

// double heading = 3;
inline void Sign::clear_heading() {
  _impl_.heading_ = 0;
}
inline double Sign::_internal_heading() const {
  return _impl_.heading_;
}
inline double Sign::heading() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.heading)
  return _internal_heading();
}
inline void Sign::_internal_set_heading(double value) {
  
  _impl_.heading_ = value;
}
inline void Sign::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign.heading)
}

// -------------------------------------------------------------------

// Lane

// string lane_id = 1;
inline void Lane::clear_lane_id() {
  _impl_.lane_id_.ClearToEmpty();
}
inline const std::string& Lane::lane_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.lane_id)
  return _internal_lane_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lane::set_lane_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lane_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.lane_id)
}
inline std::string* Lane::mutable_lane_id() {
  std::string* _s = _internal_mutable_lane_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.lane_id)
  return _s;
}
inline const std::string& Lane::_internal_lane_id() const {
  return _impl_.lane_id_.Get();
}
inline void Lane::_internal_set_lane_id(const std::string& value) {
  
  _impl_.lane_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Lane::_internal_mutable_lane_id() {
  
  return _impl_.lane_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Lane::release_lane_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.lane_id)
  return _impl_.lane_id_.Release();
}
inline void Lane::set_allocated_lane_id(std::string* lane_id) {
  if (lane_id != nullptr) {
    
  } else {
    
  }
  _impl_.lane_id_.SetAllocated(lane_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lane_id_.IsDefault()) {
    _impl_.lane_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.lane_id)
}

// string type = 2;
inline void Lane::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Lane::type() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lane::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.type)
}
inline std::string* Lane::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.type)
  return _s;
}
inline const std::string& Lane::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Lane::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Lane::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Lane::release_type() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.type)
  return _impl_.type_.Release();
}
inline void Lane::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.type)
}

// string line_type = 3;
inline void Lane::clear_line_type() {
  _impl_.line_type_.ClearToEmpty();
}
inline const std::string& Lane::line_type() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_type)
  return _internal_line_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lane::set_line_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.line_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_type)
}
inline std::string* Lane::mutable_line_type() {
  std::string* _s = _internal_mutable_line_type();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_type)
  return _s;
}
inline const std::string& Lane::_internal_line_type() const {
  return _impl_.line_type_.Get();
}
inline void Lane::_internal_set_line_type(const std::string& value) {
  
  _impl_.line_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Lane::_internal_mutable_line_type() {
  
  return _impl_.line_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Lane::release_line_type() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_type)
  return _impl_.line_type_.Release();
}
inline void Lane::set_allocated_line_type(std::string* line_type) {
  if (line_type != nullptr) {
    
  } else {
    
  }
  _impl_.line_type_.SetAllocated(line_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.line_type_.IsDefault()) {
    _impl_.line_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_type)
}

// string line_color = 4;
inline void Lane::clear_line_color() {
  _impl_.line_color_.ClearToEmpty();
}
inline const std::string& Lane::line_color() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_color)
  return _internal_line_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lane::set_line_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.line_color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_color)
}
inline std::string* Lane::mutable_line_color() {
  std::string* _s = _internal_mutable_line_color();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_color)
  return _s;
}
inline const std::string& Lane::_internal_line_color() const {
  return _impl_.line_color_.Get();
}
inline void Lane::_internal_set_line_color(const std::string& value) {
  
  _impl_.line_color_.Set(value, GetArenaForAllocation());
}
inline std::string* Lane::_internal_mutable_line_color() {
  
  return _impl_.line_color_.Mutable(GetArenaForAllocation());
}
inline std::string* Lane::release_line_color() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_color)
  return _impl_.line_color_.Release();
}
inline void Lane::set_allocated_line_color(std::string* line_color) {
  if (line_color != nullptr) {
    
  } else {
    
  }
  _impl_.line_color_.SetAllocated(line_color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.line_color_.IsDefault()) {
    _impl_.line_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.line_color)
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 5;
inline int Lane::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Lane::shape_size() const {
  return _internal_shape_size();
}
inline void Lane::clear_shape() {
  _impl_.shape_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Lane::mutable_shape(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.shape)
  return _impl_.shape_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
Lane::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.shape)
  return &_impl_.shape_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Lane::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Lane::shape(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.shape)
  return _internal_shape(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Lane::_internal_add_shape() {
  return _impl_.shape_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Lane::add_shape() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _add = _internal_add_shape();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.shape)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
Lane::shape() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.shape)
  return _impl_.shape_;
}

// uint32 lane_offset = 6;
inline void Lane::clear_lane_offset() {
  _impl_.lane_offset_ = 0u;
}
inline uint32_t Lane::_internal_lane_offset() const {
  return _impl_.lane_offset_;
}
inline uint32_t Lane::lane_offset() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.lane_offset)
  return _internal_lane_offset();
}
inline void Lane::_internal_set_lane_offset(uint32_t value) {
  
  _impl_.lane_offset_ = value;
}
inline void Lane::set_lane_offset(uint32_t value) {
  _internal_set_lane_offset(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.lane_offset)
}

// string link_id = 7;
inline void Lane::clear_link_id() {
  _impl_.link_id_.ClearToEmpty();
}
inline const std::string& Lane::link_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.link_id)
  return _internal_link_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lane::set_link_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.link_id)
}
inline std::string* Lane::mutable_link_id() {
  std::string* _s = _internal_mutable_link_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.link_id)
  return _s;
}
inline const std::string& Lane::_internal_link_id() const {
  return _impl_.link_id_.Get();
}
inline void Lane::_internal_set_link_id(const std::string& value) {
  
  _impl_.link_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Lane::_internal_mutable_link_id() {
  
  return _impl_.link_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Lane::release_link_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.link_id)
  return _impl_.link_id_.Release();
}
inline void Lane::set_allocated_link_id(std::string* link_id) {
  if (link_id != nullptr) {
    
  } else {
    
  }
  _impl_.link_id_.SetAllocated(link_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_id_.IsDefault()) {
    _impl_.link_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.link_id)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Sign sign = 8;
inline bool Lane::_internal_has_sign() const {
  return this != internal_default_instance() && _impl_.sign_ != nullptr;
}
inline bool Lane::has_sign() const {
  return _internal_has_sign();
}
inline void Lane::clear_sign() {
  if (GetArenaForAllocation() == nullptr && _impl_.sign_ != nullptr) {
    delete _impl_.sign_;
  }
  _impl_.sign_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign& Lane::_internal_sign() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Sign_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign& Lane::sign() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.sign)
  return _internal_sign();
}
inline void Lane::unsafe_arena_set_allocated_sign(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.sign)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* Lane::release_sign() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* Lane::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.sign)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* Lane::_internal_mutable_sign() {
  
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign>(GetArenaForAllocation());
    _impl_.sign_ = p;
  }
  return _impl_.sign_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* Lane::mutable_sign() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.sign)
  return _msg;
}
inline void Lane::set_allocated_sign(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Sign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sign_;
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sign);
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.sign)
}

// repeated string connect_link_ids = 9;
inline int Lane::_internal_connect_link_ids_size() const {
  return _impl_.connect_link_ids_.size();
}
inline int Lane::connect_link_ids_size() const {
  return _internal_connect_link_ids_size();
}
inline void Lane::clear_connect_link_ids() {
  _impl_.connect_link_ids_.Clear();
}
inline std::string* Lane::add_connect_link_ids() {
  std::string* _s = _internal_add_connect_link_ids();
  // @@protoc_insertion_point(field_add_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
  return _s;
}
inline const std::string& Lane::_internal_connect_link_ids(int index) const {
  return _impl_.connect_link_ids_.Get(index);
}
inline const std::string& Lane::connect_link_ids(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
  return _internal_connect_link_ids(index);
}
inline std::string* Lane::mutable_connect_link_ids(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
  return _impl_.connect_link_ids_.Mutable(index);
}
inline void Lane::set_connect_link_ids(int index, const std::string& value) {
  _impl_.connect_link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
}
inline void Lane::set_connect_link_ids(int index, std::string&& value) {
  _impl_.connect_link_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
}
inline void Lane::set_connect_link_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.connect_link_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
}
inline void Lane::set_connect_link_ids(int index, const char* value, size_t size) {
  _impl_.connect_link_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
}
inline std::string* Lane::_internal_add_connect_link_ids() {
  return _impl_.connect_link_ids_.Add();
}
inline void Lane::add_connect_link_ids(const std::string& value) {
  _impl_.connect_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
}
inline void Lane::add_connect_link_ids(std::string&& value) {
  _impl_.connect_link_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
}
inline void Lane::add_connect_link_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.connect_link_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
}
inline void Lane::add_connect_link_ids(const char* value, size_t size) {
  _impl_.connect_link_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Lane::connect_link_ids() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
  return _impl_.connect_link_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Lane::mutable_connect_link_ids() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.connect_link_ids)
  return &_impl_.connect_link_ids_;
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point center_line = 10;
inline int Lane::_internal_center_line_size() const {
  return _impl_.center_line_.size();
}
inline int Lane::center_line_size() const {
  return _internal_center_line_size();
}
inline void Lane::clear_center_line() {
  _impl_.center_line_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Lane::mutable_center_line(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.center_line)
  return _impl_.center_line_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
Lane::mutable_center_line() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.center_line)
  return &_impl_.center_line_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Lane::_internal_center_line(int index) const {
  return _impl_.center_line_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Lane::center_line(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.center_line)
  return _internal_center_line(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Lane::_internal_add_center_line() {
  return _impl_.center_line_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Lane::add_center_line() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _add = _internal_add_center_line();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.center_line)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
Lane::center_line() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane.center_line)
  return _impl_.center_line_;
}

// -------------------------------------------------------------------

// Crosswalk

// string crosswalk_id = 1;
inline void Crosswalk::clear_crosswalk_id() {
  _impl_.crosswalk_id_.ClearToEmpty();
}
inline const std::string& Crosswalk::crosswalk_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.crosswalk_id)
  return _internal_crosswalk_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Crosswalk::set_crosswalk_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.crosswalk_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.crosswalk_id)
}
inline std::string* Crosswalk::mutable_crosswalk_id() {
  std::string* _s = _internal_mutable_crosswalk_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.crosswalk_id)
  return _s;
}
inline const std::string& Crosswalk::_internal_crosswalk_id() const {
  return _impl_.crosswalk_id_.Get();
}
inline void Crosswalk::_internal_set_crosswalk_id(const std::string& value) {
  
  _impl_.crosswalk_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Crosswalk::_internal_mutable_crosswalk_id() {
  
  return _impl_.crosswalk_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Crosswalk::release_crosswalk_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.crosswalk_id)
  return _impl_.crosswalk_id_.Release();
}
inline void Crosswalk::set_allocated_crosswalk_id(std::string* crosswalk_id) {
  if (crosswalk_id != nullptr) {
    
  } else {
    
  }
  _impl_.crosswalk_id_.SetAllocated(crosswalk_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.crosswalk_id_.IsDefault()) {
    _impl_.crosswalk_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.crosswalk_id)
}

// string name = 2;
inline void Crosswalk::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Crosswalk::name() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Crosswalk::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.name)
}
inline std::string* Crosswalk::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.name)
  return _s;
}
inline const std::string& Crosswalk::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Crosswalk::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Crosswalk::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Crosswalk::release_name() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.name)
  return _impl_.name_.Release();
}
inline void Crosswalk::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.name)
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 3;
inline int Crosswalk::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Crosswalk::shape_size() const {
  return _internal_shape_size();
}
inline void Crosswalk::clear_shape() {
  _impl_.shape_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Crosswalk::mutable_shape(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.shape)
  return _impl_.shape_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
Crosswalk::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.shape)
  return &_impl_.shape_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Crosswalk::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Crosswalk::shape(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.shape)
  return _internal_shape(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Crosswalk::_internal_add_shape() {
  return _impl_.shape_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Crosswalk::add_shape() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _add = _internal_add_shape();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.shape)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
Crosswalk::shape() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk.shape)
  return _impl_.shape_;
}

// -------------------------------------------------------------------

// Stopline

// string obj_id = 1;
inline void Stopline::clear_obj_id() {
  _impl_.obj_id_.ClearToEmpty();
}
inline const std::string& Stopline::obj_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.obj_id)
  return _internal_obj_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stopline::set_obj_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.obj_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.obj_id)
}
inline std::string* Stopline::mutable_obj_id() {
  std::string* _s = _internal_mutable_obj_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.obj_id)
  return _s;
}
inline const std::string& Stopline::_internal_obj_id() const {
  return _impl_.obj_id_.Get();
}
inline void Stopline::_internal_set_obj_id(const std::string& value) {
  
  _impl_.obj_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Stopline::_internal_mutable_obj_id() {
  
  return _impl_.obj_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Stopline::release_obj_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.obj_id)
  return _impl_.obj_id_.Release();
}
inline void Stopline::set_allocated_obj_id(std::string* obj_id) {
  if (obj_id != nullptr) {
    
  } else {
    
  }
  _impl_.obj_id_.SetAllocated(obj_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obj_id_.IsDefault()) {
    _impl_.obj_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.obj_id)
}

// string type = 2;
inline void Stopline::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Stopline::type() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stopline::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.type)
}
inline std::string* Stopline::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.type)
  return _s;
}
inline const std::string& Stopline::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Stopline::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Stopline::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Stopline::release_type() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.type)
  return _impl_.type_.Release();
}
inline void Stopline::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.type)
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point shape = 3;
inline int Stopline::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Stopline::shape_size() const {
  return _internal_shape_size();
}
inline void Stopline::clear_shape() {
  _impl_.shape_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Stopline::mutable_shape(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.shape)
  return _impl_.shape_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >*
Stopline::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.shape)
  return &_impl_.shape_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Stopline::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Stopline::shape(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.shape)
  return _internal_shape(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Stopline::_internal_add_shape() {
  return _impl_.shape_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Stopline::add_shape() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _add = _internal_add_shape();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.shape)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point >&
Stopline::shape() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline.shape)
  return _impl_.shape_;
}

// -------------------------------------------------------------------

// Hdtrafficmap

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction junctions = 1;
inline int Hdtrafficmap::_internal_junctions_size() const {
  return _impl_.junctions_.size();
}
inline int Hdtrafficmap::junctions_size() const {
  return _internal_junctions_size();
}
inline void Hdtrafficmap::clear_junctions() {
  _impl_.junctions_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* Hdtrafficmap::mutable_junctions(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.junctions)
  return _impl_.junctions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >*
Hdtrafficmap::mutable_junctions() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.junctions)
  return &_impl_.junctions_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction& Hdtrafficmap::_internal_junctions(int index) const {
  return _impl_.junctions_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction& Hdtrafficmap::junctions(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.junctions)
  return _internal_junctions(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* Hdtrafficmap::_internal_add_junctions() {
  return _impl_.junctions_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* Hdtrafficmap::add_junctions() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* _add = _internal_add_junctions();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.junctions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >&
Hdtrafficmap::junctions() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.junctions)
  return _impl_.junctions_;
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment segments = 2;
inline int Hdtrafficmap::_internal_segments_size() const {
  return _impl_.segments_.size();
}
inline int Hdtrafficmap::segments_size() const {
  return _internal_segments_size();
}
inline void Hdtrafficmap::clear_segments() {
  _impl_.segments_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* Hdtrafficmap::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.segments)
  return _impl_.segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >*
Hdtrafficmap::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.segments)
  return &_impl_.segments_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment& Hdtrafficmap::_internal_segments(int index) const {
  return _impl_.segments_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment& Hdtrafficmap::segments(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.segments)
  return _internal_segments(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* Hdtrafficmap::_internal_add_segments() {
  return _impl_.segments_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* Hdtrafficmap::add_segments() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* _add = _internal_add_segments();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >&
Hdtrafficmap::segments() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.segments)
  return _impl_.segments_;
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link links = 3;
inline int Hdtrafficmap::_internal_links_size() const {
  return _impl_.links_.size();
}
inline int Hdtrafficmap::links_size() const {
  return _internal_links_size();
}
inline void Hdtrafficmap::clear_links() {
  _impl_.links_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* Hdtrafficmap::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.links)
  return _impl_.links_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >*
Hdtrafficmap::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.links)
  return &_impl_.links_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link& Hdtrafficmap::_internal_links(int index) const {
  return _impl_.links_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link& Hdtrafficmap::links(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.links)
  return _internal_links(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* Hdtrafficmap::_internal_add_links() {
  return _impl_.links_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* Hdtrafficmap::add_links() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* _add = _internal_add_links();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.links)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >&
Hdtrafficmap::links() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.links)
  return _impl_.links_;
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane lanes = 4;
inline int Hdtrafficmap::_internal_lanes_size() const {
  return _impl_.lanes_.size();
}
inline int Hdtrafficmap::lanes_size() const {
  return _internal_lanes_size();
}
inline void Hdtrafficmap::clear_lanes() {
  _impl_.lanes_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* Hdtrafficmap::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.lanes)
  return _impl_.lanes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >*
Hdtrafficmap::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.lanes)
  return &_impl_.lanes_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane& Hdtrafficmap::_internal_lanes(int index) const {
  return _impl_.lanes_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane& Hdtrafficmap::lanes(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.lanes)
  return _internal_lanes(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* Hdtrafficmap::_internal_add_lanes() {
  return _impl_.lanes_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* Hdtrafficmap::add_lanes() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* _add = _internal_add_lanes();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.lanes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >&
Hdtrafficmap::lanes() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.lanes)
  return _impl_.lanes_;
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk crosswalks = 5;
inline int Hdtrafficmap::_internal_crosswalks_size() const {
  return _impl_.crosswalks_.size();
}
inline int Hdtrafficmap::crosswalks_size() const {
  return _internal_crosswalks_size();
}
inline void Hdtrafficmap::clear_crosswalks() {
  _impl_.crosswalks_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk* Hdtrafficmap::mutable_crosswalks(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.crosswalks)
  return _impl_.crosswalks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >*
Hdtrafficmap::mutable_crosswalks() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.crosswalks)
  return &_impl_.crosswalks_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk& Hdtrafficmap::_internal_crosswalks(int index) const {
  return _impl_.crosswalks_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk& Hdtrafficmap::crosswalks(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.crosswalks)
  return _internal_crosswalks(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk* Hdtrafficmap::_internal_add_crosswalks() {
  return _impl_.crosswalks_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk* Hdtrafficmap::add_crosswalks() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk* _add = _internal_add_crosswalks();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.crosswalks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >&
Hdtrafficmap::crosswalks() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.crosswalks)
  return _impl_.crosswalks_;
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline stoplines = 6;
inline int Hdtrafficmap::_internal_stoplines_size() const {
  return _impl_.stoplines_.size();
}
inline int Hdtrafficmap::stoplines_size() const {
  return _internal_stoplines_size();
}
inline void Hdtrafficmap::clear_stoplines() {
  _impl_.stoplines_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline* Hdtrafficmap::mutable_stoplines(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.stoplines)
  return _impl_.stoplines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >*
Hdtrafficmap::mutable_stoplines() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.stoplines)
  return &_impl_.stoplines_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline& Hdtrafficmap::_internal_stoplines(int index) const {
  return _impl_.stoplines_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline& Hdtrafficmap::stoplines(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.stoplines)
  return _internal_stoplines(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline* Hdtrafficmap::_internal_add_stoplines() {
  return _impl_.stoplines_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline* Hdtrafficmap::add_stoplines() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline* _add = _internal_add_stoplines();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.stoplines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >&
Hdtrafficmap::stoplines() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Hdtrafficmap.stoplines)
  return _impl_.stoplines_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace simulation
}  // namespace api
}  // namespace simulation_task_kratos
}  // namespace lasvsim
}  // namespace risenlighten

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fhdmap_2eproto
