// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: risenlighten/lasvsim/simulation_task_kratos/api/simulation/v2/simulation.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "risenlighten/lasvsim/simulation_task_kratos/api/simulation/v2/hdmap.pb.h"
#include "google/api/field_behavior.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
namespace risenlighten {
namespace lasvsim {
namespace simulation_task_kratos {
namespace api {
namespace simulation {
namespace v2 {
class BaseInfo;
struct BaseInfoDefaultTypeInternal;
extern BaseInfoDefaultTypeInternal _BaseInfo_default_instance_;
class ErrorMsg;
struct ErrorMsgDefaultTypeInternal;
extern ErrorMsgDefaultTypeInternal _ErrorMsg_default_instance_;
class GetAllTrafficPartReq;
struct GetAllTrafficPartReqDefaultTypeInternal;
extern GetAllTrafficPartReqDefaultTypeInternal _GetAllTrafficPartReq_default_instance_;
class GetAllTrafficPartRes;
struct GetAllTrafficPartResDefaultTypeInternal;
extern GetAllTrafficPartResDefaultTypeInternal _GetAllTrafficPartRes_default_instance_;
class GetJunctionReq;
struct GetJunctionReqDefaultTypeInternal;
extern GetJunctionReqDefaultTypeInternal _GetJunctionReq_default_instance_;
class GetJunctionRes;
struct GetJunctionResDefaultTypeInternal;
extern GetJunctionResDefaultTypeInternal _GetJunctionRes_default_instance_;
class GetLaneReq;
struct GetLaneReqDefaultTypeInternal;
extern GetLaneReqDefaultTypeInternal _GetLaneReq_default_instance_;
class GetLaneRes;
struct GetLaneResDefaultTypeInternal;
extern GetLaneResDefaultTypeInternal _GetLaneRes_default_instance_;
class GetLinkReq;
struct GetLinkReqDefaultTypeInternal;
extern GetLinkReqDefaultTypeInternal _GetLinkReq_default_instance_;
class GetLinkRes;
struct GetLinkResDefaultTypeInternal;
extern GetLinkResDefaultTypeInternal _GetLinkRes_default_instance_;
class GetMapReq;
struct GetMapReqDefaultTypeInternal;
extern GetMapReqDefaultTypeInternal _GetMapReq_default_instance_;
class GetMapRes;
struct GetMapResDefaultTypeInternal;
extern GetMapResDefaultTypeInternal _GetMapRes_default_instance_;
class GetResultsReq;
struct GetResultsReqDefaultTypeInternal;
extern GetResultsReqDefaultTypeInternal _GetResultsReq_default_instance_;
class GetResultsRes;
struct GetResultsResDefaultTypeInternal;
extern GetResultsResDefaultTypeInternal _GetResultsRes_default_instance_;
class GetResultsRes_ResultsEntry_DoNotUse;
struct GetResultsRes_ResultsEntry_DoNotUseDefaultTypeInternal;
extern GetResultsRes_ResultsEntry_DoNotUseDefaultTypeInternal _GetResultsRes_ResultsEntry_DoNotUse_default_instance_;
class GetResultsRes_arrays;
struct GetResultsRes_arraysDefaultTypeInternal;
extern GetResultsRes_arraysDefaultTypeInternal _GetResultsRes_arrays_default_instance_;
class GetResultsRes_item;
struct GetResultsRes_itemDefaultTypeInternal;
extern GetResultsRes_itemDefaultTypeInternal _GetResultsRes_item_default_instance_;
class GetSegmentReq;
struct GetSegmentReqDefaultTypeInternal;
extern GetSegmentReqDefaultTypeInternal _GetSegmentReq_default_instance_;
class GetSegmentRes;
struct GetSegmentResDefaultTypeInternal;
extern GetSegmentResDefaultTypeInternal _GetSegmentRes_default_instance_;
class GetVehicleReq;
struct GetVehicleReqDefaultTypeInternal;
extern GetVehicleReqDefaultTypeInternal _GetVehicleReq_default_instance_;
class GetVehicleRes;
struct GetVehicleResDefaultTypeInternal;
extern GetVehicleResDefaultTypeInternal _GetVehicleRes_default_instance_;
class Map;
struct MapDefaultTypeInternal;
extern MapDefaultTypeInternal _Map_default_instance_;
class Map_CrosswalkMapEntry_DoNotUse;
struct Map_CrosswalkMapEntry_DoNotUseDefaultTypeInternal;
extern Map_CrosswalkMapEntry_DoNotUseDefaultTypeInternal _Map_CrosswalkMapEntry_DoNotUse_default_instance_;
class Map_JunctionMapEntry_DoNotUse;
struct Map_JunctionMapEntry_DoNotUseDefaultTypeInternal;
extern Map_JunctionMapEntry_DoNotUseDefaultTypeInternal _Map_JunctionMapEntry_DoNotUse_default_instance_;
class Map_LaneMapEntry_DoNotUse;
struct Map_LaneMapEntry_DoNotUseDefaultTypeInternal;
extern Map_LaneMapEntry_DoNotUseDefaultTypeInternal _Map_LaneMapEntry_DoNotUse_default_instance_;
class Map_LinkMapEntry_DoNotUse;
struct Map_LinkMapEntry_DoNotUseDefaultTypeInternal;
extern Map_LinkMapEntry_DoNotUseDefaultTypeInternal _Map_LinkMapEntry_DoNotUse_default_instance_;
class Map_SegmentMapEntry_DoNotUse;
struct Map_SegmentMapEntry_DoNotUseDefaultTypeInternal;
extern Map_SegmentMapEntry_DoNotUseDefaultTypeInternal _Map_SegmentMapEntry_DoNotUse_default_instance_;
class Map_StopLineMapEntry_DoNotUse;
struct Map_StopLineMapEntry_DoNotUseDefaultTypeInternal;
extern Map_StopLineMapEntry_DoNotUseDefaultTypeInternal _Map_StopLineMapEntry_DoNotUse_default_instance_;
class MovingInfo;
struct MovingInfoDefaultTypeInternal;
extern MovingInfoDefaultTypeInternal _MovingInfo_default_instance_;
class MovingObj;
struct MovingObjDefaultTypeInternal;
extern MovingObjDefaultTypeInternal _MovingObj_default_instance_;
class NextStepReq;
struct NextStepReqDefaultTypeInternal;
extern NextStepReqDefaultTypeInternal _NextStepReq_default_instance_;
class NextStepRes;
struct NextStepResDefaultTypeInternal;
extern NextStepResDefaultTypeInternal _NextStepRes_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class ResetSimulationReq;
struct ResetSimulationReqDefaultTypeInternal;
extern ResetSimulationReqDefaultTypeInternal _ResetSimulationReq_default_instance_;
class ResetSimulationRes;
struct ResetSimulationResDefaultTypeInternal;
extern ResetSimulationResDefaultTypeInternal _ResetSimulationRes_default_instance_;
class SetVehicleControlReq;
struct SetVehicleControlReqDefaultTypeInternal;
extern SetVehicleControlReqDefaultTypeInternal _SetVehicleControlReq_default_instance_;
class SetVehicleControlRes;
struct SetVehicleControlResDefaultTypeInternal;
extern SetVehicleControlResDefaultTypeInternal _SetVehicleControlRes_default_instance_;
class SimulationState;
struct SimulationStateDefaultTypeInternal;
extern SimulationStateDefaultTypeInternal _SimulationState_default_instance_;
class StartSimulationReq;
struct StartSimulationReqDefaultTypeInternal;
extern StartSimulationReqDefaultTypeInternal _StartSimulationReq_default_instance_;
class StartSimulationRes;
struct StartSimulationResDefaultTypeInternal;
extern StartSimulationResDefaultTypeInternal _StartSimulationRes_default_instance_;
class StopSimulationReq;
struct StopSimulationReqDefaultTypeInternal;
extern StopSimulationReqDefaultTypeInternal _StopSimulationReq_default_instance_;
class StopSimulationRes;
struct StopSimulationResDefaultTypeInternal;
extern StopSimulationResDefaultTypeInternal _StopSimulationRes_default_instance_;
class Vehicle;
struct VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
class VehicleControl;
struct VehicleControlDefaultTypeInternal;
extern VehicleControlDefaultTypeInternal _VehicleControl_default_instance_;
}  // namespace v2
}  // namespace simulation
}  // namespace api
}  // namespace simulation_task_kratos
}  // namespace lasvsim
}  // namespace risenlighten
PROTOBUF_NAMESPACE_OPEN
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetAllTrafficPartRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetJunctionRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLaneRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetLinkRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetMapRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_ResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_ResultsEntry_DoNotUse>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetSegmentRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetVehicleRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_CrosswalkMapEntry_DoNotUse* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_CrosswalkMapEntry_DoNotUse>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_JunctionMapEntry_DoNotUse* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_JunctionMapEntry_DoNotUse>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_LaneMapEntry_DoNotUse* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_LaneMapEntry_DoNotUse>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_LinkMapEntry_DoNotUse* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_LinkMapEntry_DoNotUse>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_SegmentMapEntry_DoNotUse* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_SegmentMapEntry_DoNotUse>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_StopLineMapEntry_DoNotUse* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map_StopLineMapEntry_DoNotUse>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::NextStepRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ResetSimulationRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SetVehicleControlRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StartSimulationRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationReq>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::StopSimulationRes>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle>(Arena*);
template<> ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::VehicleControl* Arena::CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::VehicleControl>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace risenlighten {
namespace lasvsim {
namespace simulation_task_kratos {
namespace api {
namespace simulation {
namespace v2 {

// ===================================================================

class ErrorMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg) */ {
 public:
  inline ErrorMsg() : ErrorMsg(nullptr) {}
  ~ErrorMsg() override;
  explicit PROTOBUF_CONSTEXPR ErrorMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorMsg(const ErrorMsg& from);
  ErrorMsg(ErrorMsg&& from) noexcept
    : ErrorMsg() {
    *this = ::std::move(from);
  }

  inline ErrorMsg& operator=(const ErrorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorMsg& operator=(ErrorMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorMsg* internal_default_instance() {
    return reinterpret_cast<const ErrorMsg*>(
               &_ErrorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ErrorMsg& a, ErrorMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorMsg& from) {
    ErrorMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg";
  }
  protected:
  explicit ErrorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class BaseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo) */ {
 public:
  inline BaseInfo() : BaseInfo(nullptr) {}
  ~BaseInfo() override;
  explicit PROTOBUF_CONSTEXPR BaseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseInfo(const BaseInfo& from);
  BaseInfo(BaseInfo&& from) noexcept
    : BaseInfo() {
    *this = ::std::move(from);
  }

  inline BaseInfo& operator=(const BaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseInfo& operator=(BaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseInfo* internal_default_instance() {
    return reinterpret_cast<const BaseInfo*>(
               &_BaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BaseInfo& a, BaseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseInfo& from) {
    BaseInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo";
  }
  protected:
  explicit BaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kWeightFieldNumber = 4,
    kMaxDecFieldNumber = 5,
    kMaxAccFieldNumber = 6,
  };
  // double Length = 1;
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // double Width = 2;
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // double Height = 3;
  void clear_height();
  double height() const;
  void set_height(double value);
  private:
  double _internal_height() const;
  void _internal_set_height(double value);
  public:

  // double Weight = 4;
  void clear_weight();
  double weight() const;
  void set_weight(double value);
  private:
  double _internal_weight() const;
  void _internal_set_weight(double value);
  public:

  // double max_dec = 5;
  void clear_max_dec();
  double max_dec() const;
  void set_max_dec(double value);
  private:
  double _internal_max_dec() const;
  void _internal_set_max_dec(double value);
  public:

  // double max_acc = 6;
  void clear_max_acc();
  double max_acc() const;
  void set_max_acc(double value);
  private:
  double _internal_max_acc() const;
  void _internal_set_max_acc(double value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double length_;
    double width_;
    double height_;
    double weight_;
    double max_dec_;
    double max_acc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkIdFieldNumber = 3,
    kLaneIdFieldNumber = 5,
    kSegmentIdFieldNumber = 6,
    kJunctionIdFieldNumber = 7,
    kPointFieldNumber = 1,
    kPhiFieldNumber = 2,
    kDisToLinkEndFieldNumber = 4,
  };
  // string link_id = 3;
  void clear_link_id();
  const std::string& link_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link_id();
  PROTOBUF_NODISCARD std::string* release_link_id();
  void set_allocated_link_id(std::string* link_id);
  private:
  const std::string& _internal_link_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_id(const std::string& value);
  std::string* _internal_mutable_link_id();
  public:

  // string lane_id = 5;
  void clear_lane_id();
  const std::string& lane_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lane_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lane_id();
  PROTOBUF_NODISCARD std::string* release_lane_id();
  void set_allocated_lane_id(std::string* lane_id);
  private:
  const std::string& _internal_lane_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lane_id(const std::string& value);
  std::string* _internal_mutable_lane_id();
  public:

  // string segment_id = 6;
  void clear_segment_id();
  const std::string& segment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* segment_id);
  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(const std::string& value);
  std::string* _internal_mutable_segment_id();
  public:

  // string junction_id = 7;
  void clear_junction_id();
  const std::string& junction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_junction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_junction_id();
  PROTOBUF_NODISCARD std::string* release_junction_id();
  void set_allocated_junction_id(std::string* junction_id);
  private:
  const std::string& _internal_junction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_junction_id(const std::string& value);
  std::string* _internal_mutable_junction_id();
  public:

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& point() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* release_point();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* mutable_point();
  void set_allocated_point(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* point);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& _internal_point() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* point);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* unsafe_arena_release_point();

  // double phi = 2;
  void clear_phi();
  double phi() const;
  void set_phi(double value);
  private:
  double _internal_phi() const;
  void _internal_set_phi(double value);
  public:

  // double dis_to_link_end = 4;
  void clear_dis_to_link_end();
  double dis_to_link_end() const;
  void set_dis_to_link_end(double value);
  private:
  double _internal_dis_to_link_end() const;
  void _internal_set_dis_to_link_end(double value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lane_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segment_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr junction_id_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* point_;
    double phi_;
    double dis_to_link_end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class MovingInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo) */ {
 public:
  inline MovingInfo() : MovingInfo(nullptr) {}
  ~MovingInfo() override;
  explicit PROTOBUF_CONSTEXPR MovingInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovingInfo(const MovingInfo& from);
  MovingInfo(MovingInfo&& from) noexcept
    : MovingInfo() {
    *this = ::std::move(from);
  }

  inline MovingInfo& operator=(const MovingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovingInfo& operator=(MovingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovingInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovingInfo* internal_default_instance() {
    return reinterpret_cast<const MovingInfo*>(
               &_MovingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MovingInfo& a, MovingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MovingInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovingInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MovingInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MovingInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MovingInfo& from) {
    MovingInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovingInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo";
  }
  protected:
  explicit MovingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kUFieldNumber = 3,
    kLonAccFieldNumber = 4,
    kVFieldNumber = 5,
    kLatAccFieldNumber = 6,
    kWFieldNumber = 7,
    kWAccFieldNumber = 8,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& position() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* release_position();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* mutable_position();
  void set_allocated_position(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* position);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& _internal_position() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* position);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* unsafe_arena_release_position();

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // double u = 3;
  void clear_u();
  double u() const;
  void set_u(double value);
  private:
  double _internal_u() const;
  void _internal_set_u(double value);
  public:

  // double lon_acc = 4;
  void clear_lon_acc();
  double lon_acc() const;
  void set_lon_acc(double value);
  private:
  double _internal_lon_acc() const;
  void _internal_set_lon_acc(double value);
  public:

  // double v = 5;
  void clear_v();
  double v() const;
  void set_v(double value);
  private:
  double _internal_v() const;
  void _internal_set_v(double value);
  public:

  // double lat_acc = 6;
  void clear_lat_acc();
  double lat_acc() const;
  void set_lat_acc(double value);
  private:
  double _internal_lat_acc() const;
  void _internal_set_lat_acc(double value);
  public:

  // double w = 7;
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // double w_acc = 8;
  void clear_w_acc();
  double w_acc() const;
  void set_w_acc(double value);
  private:
  double _internal_w_acc() const;
  void _internal_set_w_acc(double value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* position_;
    int64_t timestamp_;
    double u_;
    double lon_acc_;
    double v_;
    double lat_acc_;
    double w_;
    double w_acc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class MovingObj final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj) */ {
 public:
  inline MovingObj() : MovingObj(nullptr) {}
  ~MovingObj() override;
  explicit PROTOBUF_CONSTEXPR MovingObj(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovingObj(const MovingObj& from);
  MovingObj(MovingObj&& from) noexcept
    : MovingObj() {
    *this = ::std::move(from);
  }

  inline MovingObj& operator=(const MovingObj& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovingObj& operator=(MovingObj&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovingObj& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovingObj* internal_default_instance() {
    return reinterpret_cast<const MovingObj*>(
               &_MovingObj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MovingObj& a, MovingObj& b) {
    a.Swap(&b);
  }
  inline void Swap(MovingObj* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovingObj* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovingObj* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MovingObj>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MovingObj& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MovingObj& from) {
    MovingObj::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovingObj* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj";
  }
  protected:
  explicit MovingObj(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTypeFieldNumber = 4,
    kBaseInfoFieldNumber = 2,
    kMovingInfoFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string type = 4;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo base_info = 2;
  bool has_base_info() const;
  private:
  bool _internal_has_base_info() const;
  public:
  void clear_base_info();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo& base_info() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* release_base_info();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* mutable_base_info();
  void set_allocated_base_info(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* base_info);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo& _internal_base_info() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* _internal_mutable_base_info();
  public:
  void unsafe_arena_set_allocated_base_info(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* base_info);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* unsafe_arena_release_base_info();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo moving_info = 3;
  bool has_moving_info() const;
  private:
  bool _internal_has_moving_info() const;
  public:
  void clear_moving_info();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo& moving_info() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* release_moving_info();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* mutable_moving_info();
  void set_allocated_moving_info(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* moving_info);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo& _internal_moving_info() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* _internal_mutable_moving_info();
  public:
  void unsafe_arena_set_allocated_moving_info(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* moving_info);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* unsafe_arena_release_moving_info();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* base_info_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* moving_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class Vehicle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle) */ {
 public:
  inline Vehicle() : Vehicle(nullptr) {}
  ~Vehicle() override;
  explicit PROTOBUF_CONSTEXPR Vehicle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vehicle(const Vehicle& from);
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vehicle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vehicle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vehicle& from) {
    Vehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle";
  }
  protected:
  explicit Vehicle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAroundMovingObjsFieldNumber = 2,
    kInfoFieldNumber = 1,
  };
  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj around_moving_objs = 2;
  int around_moving_objs_size() const;
  private:
  int _internal_around_moving_objs_size() const;
  public:
  void clear_around_moving_objs();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* mutable_around_moving_objs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj >*
      mutable_around_moving_objs();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& _internal_around_moving_objs(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* _internal_add_around_moving_objs();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& around_moving_objs(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* add_around_moving_objs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj >&
      around_moving_objs() const;

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& info() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* release_info();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* mutable_info();
  void set_allocated_info(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* info);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& _internal_info() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* info);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj > around_moving_objs_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class VehicleControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.VehicleControl) */ {
 public:
  inline VehicleControl() : VehicleControl(nullptr) {}
  ~VehicleControl() override;
  explicit PROTOBUF_CONSTEXPR VehicleControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehicleControl(const VehicleControl& from);
  VehicleControl(VehicleControl&& from) noexcept
    : VehicleControl() {
    *this = ::std::move(from);
  }

  inline VehicleControl& operator=(const VehicleControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleControl& operator=(VehicleControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleControl* internal_default_instance() {
    return reinterpret_cast<const VehicleControl*>(
               &_VehicleControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VehicleControl& a, VehicleControl& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehicleControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehicleControl& from) {
    VehicleControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.VehicleControl";
  }
  protected:
  explicit VehicleControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLonAccFieldNumber = 1,
    kSteWheelFieldNumber = 2,
  };
  // double lon_acc = 1;
  void clear_lon_acc();
  double lon_acc() const;
  void set_lon_acc(double value);
  private:
  double _internal_lon_acc() const;
  void _internal_set_lon_acc(double value);
  public:

  // double ste_wheel = 2;
  void clear_ste_wheel();
  double ste_wheel() const;
  void set_ste_wheel(double value);
  private:
  double _internal_ste_wheel() const;
  void _internal_set_ste_wheel(double value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.VehicleControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double lon_acc_;
    double ste_wheel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class Map_JunctionMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_JunctionMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_JunctionMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Map_JunctionMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Map_JunctionMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Map_JunctionMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Map_JunctionMapEntry_DoNotUse& other);
  static const Map_JunctionMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Map_JunctionMapEntry_DoNotUse*>(&_Map_JunctionMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.JunctionMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};

// -------------------------------------------------------------------

class Map_SegmentMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_SegmentMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_SegmentMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Map_SegmentMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Map_SegmentMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Map_SegmentMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Map_SegmentMapEntry_DoNotUse& other);
  static const Map_SegmentMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Map_SegmentMapEntry_DoNotUse*>(&_Map_SegmentMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.SegmentMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};

// -------------------------------------------------------------------

class Map_LinkMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_LinkMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_LinkMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Map_LinkMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Map_LinkMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Map_LinkMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Map_LinkMapEntry_DoNotUse& other);
  static const Map_LinkMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Map_LinkMapEntry_DoNotUse*>(&_Map_LinkMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.LinkMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};

// -------------------------------------------------------------------

class Map_LaneMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_LaneMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_LaneMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Map_LaneMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Map_LaneMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Map_LaneMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Map_LaneMapEntry_DoNotUse& other);
  static const Map_LaneMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Map_LaneMapEntry_DoNotUse*>(&_Map_LaneMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.LaneMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};

// -------------------------------------------------------------------

class Map_CrosswalkMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_CrosswalkMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_CrosswalkMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Map_CrosswalkMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Map_CrosswalkMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Map_CrosswalkMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Map_CrosswalkMapEntry_DoNotUse& other);
  static const Map_CrosswalkMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Map_CrosswalkMapEntry_DoNotUse*>(&_Map_CrosswalkMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.CrosswalkMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};

// -------------------------------------------------------------------

class Map_StopLineMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_StopLineMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Map_StopLineMapEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Map_StopLineMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Map_StopLineMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Map_StopLineMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Map_StopLineMapEntry_DoNotUse& other);
  static const Map_StopLineMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Map_StopLineMapEntry_DoNotUse*>(&_Map_StopLineMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.StopLineMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};

// -------------------------------------------------------------------

class Map final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map) */ {
 public:
  inline Map() : Map(nullptr) {}
  ~Map() override;
  explicit PROTOBUF_CONSTEXPR Map(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map(const Map& from);
  Map(Map&& from) noexcept
    : Map() {
    *this = ::std::move(from);
  }

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map& operator=(Map&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map* internal_default_instance() {
    return reinterpret_cast<const Map*>(
               &_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Map& a, Map& b) {
    a.Swap(&b);
  }
  inline void Swap(Map* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Map& from) {
    Map::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map";
  }
  protected:
  explicit Map(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kJunctionMapFieldNumber = 1,
    kSegmentMapFieldNumber = 2,
    kLinkMapFieldNumber = 3,
    kLaneMapFieldNumber = 4,
    kCrosswalkMapFieldNumber = 5,
    kStopLineMapFieldNumber = 6,
  };
  // map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction> junction_map = 1;
  int junction_map_size() const;
  private:
  int _internal_junction_map_size() const;
  public:
  void clear_junction_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >&
      _internal_junction_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >*
      _internal_mutable_junction_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >&
      junction_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >*
      mutable_junction_map();

  // map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment> segment_map = 2;
  int segment_map_size() const;
  private:
  int _internal_segment_map_size() const;
  public:
  void clear_segment_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >&
      _internal_segment_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >*
      _internal_mutable_segment_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >&
      segment_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >*
      mutable_segment_map();

  // map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link> link_map = 3;
  int link_map_size() const;
  private:
  int _internal_link_map_size() const;
  public:
  void clear_link_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >&
      _internal_link_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >*
      _internal_mutable_link_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >&
      link_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >*
      mutable_link_map();

  // map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane> lane_map = 4;
  int lane_map_size() const;
  private:
  int _internal_lane_map_size() const;
  public:
  void clear_lane_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >&
      _internal_lane_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >*
      _internal_mutable_lane_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >&
      lane_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >*
      mutable_lane_map();

  // map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk> crosswalk_map = 5;
  int crosswalk_map_size() const;
  private:
  int _internal_crosswalk_map_size() const;
  public:
  void clear_crosswalk_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >&
      _internal_crosswalk_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >*
      _internal_mutable_crosswalk_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >&
      crosswalk_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >*
      mutable_crosswalk_map();

  // map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline> stop_line_map = 6;
  int stop_line_map_size() const;
  private:
  int _internal_stop_line_map_size() const;
  public:
  void clear_stop_line_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >&
      _internal_stop_line_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >*
      _internal_mutable_stop_line_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >&
      stop_line_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >*
      mutable_stop_line_map();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Map_JunctionMapEntry_DoNotUse,
        std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> junction_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Map_SegmentMapEntry_DoNotUse,
        std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> segment_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Map_LinkMapEntry_DoNotUse,
        std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> link_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Map_LaneMapEntry_DoNotUse,
        std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> lane_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Map_CrosswalkMapEntry_DoNotUse,
        std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> crosswalk_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Map_StopLineMapEntry_DoNotUse,
        std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> stop_line_map_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class StartSimulationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq) */ {
 public:
  inline StartSimulationReq() : StartSimulationReq(nullptr) {}
  ~StartSimulationReq() override;
  explicit PROTOBUF_CONSTEXPR StartSimulationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartSimulationReq(const StartSimulationReq& from);
  StartSimulationReq(StartSimulationReq&& from) noexcept
    : StartSimulationReq() {
    *this = ::std::move(from);
  }

  inline StartSimulationReq& operator=(const StartSimulationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartSimulationReq& operator=(StartSimulationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartSimulationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartSimulationReq* internal_default_instance() {
    return reinterpret_cast<const StartSimulationReq*>(
               &_StartSimulationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StartSimulationReq& a, StartSimulationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StartSimulationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartSimulationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartSimulationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartSimulationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartSimulationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartSimulationReq& from) {
    StartSimulationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartSimulationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq";
  }
  protected:
  explicit StartSimulationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapIdFieldNumber = 1,
    kOriginFieldNumber = 2,
    kDestinationFieldNumber = 3,
  };
  // string map_id = 1;
  void clear_map_id();
  const std::string& map_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_id();
  PROTOBUF_NODISCARD std::string* release_map_id();
  void set_allocated_map_id(std::string* map_id);
  private:
  const std::string& _internal_map_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_id(const std::string& value);
  std::string* _internal_mutable_map_id();
  public:

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position origin = 2;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& origin() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* release_origin();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* mutable_origin();
  void set_allocated_origin(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* origin);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& _internal_origin() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* origin);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* unsafe_arena_release_origin();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position destination = 3;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& destination() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* release_destination();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* mutable_destination();
  void set_allocated_destination(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* destination);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& _internal_destination() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* _internal_mutable_destination();
  public:
  void unsafe_arena_set_allocated_destination(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* destination);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* unsafe_arena_release_destination();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_id_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* origin_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* destination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class StartSimulationRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes) */ {
 public:
  inline StartSimulationRes() : StartSimulationRes(nullptr) {}
  ~StartSimulationRes() override;
  explicit PROTOBUF_CONSTEXPR StartSimulationRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartSimulationRes(const StartSimulationRes& from);
  StartSimulationRes(StartSimulationRes&& from) noexcept
    : StartSimulationRes() {
    *this = ::std::move(from);
  }

  inline StartSimulationRes& operator=(const StartSimulationRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartSimulationRes& operator=(StartSimulationRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartSimulationRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartSimulationRes* internal_default_instance() {
    return reinterpret_cast<const StartSimulationRes*>(
               &_StartSimulationRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StartSimulationRes& a, StartSimulationRes& b) {
    a.Swap(&b);
  }
  inline void Swap(StartSimulationRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartSimulationRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartSimulationRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartSimulationRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartSimulationRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartSimulationRes& from) {
    StartSimulationRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartSimulationRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes";
  }
  protected:
  explicit StartSimulationRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string simulation_id = 1;
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class NextStepReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepReq) */ {
 public:
  inline NextStepReq() : NextStepReq(nullptr) {}
  ~NextStepReq() override;
  explicit PROTOBUF_CONSTEXPR NextStepReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextStepReq(const NextStepReq& from);
  NextStepReq(NextStepReq&& from) noexcept
    : NextStepReq() {
    *this = ::std::move(from);
  }

  inline NextStepReq& operator=(const NextStepReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextStepReq& operator=(NextStepReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextStepReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextStepReq* internal_default_instance() {
    return reinterpret_cast<const NextStepReq*>(
               &_NextStepReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NextStepReq& a, NextStepReq& b) {
    a.Swap(&b);
  }
  inline void Swap(NextStepReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextStepReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextStepReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextStepReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextStepReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextStepReq& from) {
    NextStepReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextStepReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepReq";
  }
  protected:
  explicit NextStepReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class SimulationState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState) */ {
 public:
  inline SimulationState() : SimulationState(nullptr) {}
  ~SimulationState() override;
  explicit PROTOBUF_CONSTEXPR SimulationState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimulationState(const SimulationState& from);
  SimulationState(SimulationState&& from) noexcept
    : SimulationState() {
    *this = ::std::move(from);
  }

  inline SimulationState& operator=(const SimulationState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulationState& operator=(SimulationState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimulationState& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimulationState* internal_default_instance() {
    return reinterpret_cast<const SimulationState*>(
               &_SimulationState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SimulationState& a, SimulationState& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulationState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulationState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimulationState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimulationState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimulationState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimulationState& from) {
    SimulationState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulationState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState";
  }
  protected:
  explicit SimulationState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kProgressFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 progress = 1;
  void clear_progress();
  int32_t progress() const;
  void set_progress(int32_t value);
  private:
  int32_t _internal_progress() const;
  void _internal_set_progress(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int32_t progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class NextStepRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes) */ {
 public:
  inline NextStepRes() : NextStepRes(nullptr) {}
  ~NextStepRes() override;
  explicit PROTOBUF_CONSTEXPR NextStepRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextStepRes(const NextStepRes& from);
  NextStepRes(NextStepRes&& from) noexcept
    : NextStepRes() {
    *this = ::std::move(from);
  }

  inline NextStepRes& operator=(const NextStepRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextStepRes& operator=(NextStepRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextStepRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextStepRes* internal_default_instance() {
    return reinterpret_cast<const NextStepRes*>(
               &_NextStepRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(NextStepRes& a, NextStepRes& b) {
    a.Swap(&b);
  }
  inline void Swap(NextStepRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextStepRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextStepRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextStepRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextStepRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextStepRes& from) {
    NextStepRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextStepRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes";
  }
  protected:
  explicit NextStepRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState& state() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* release_state();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* mutable_state();
  void set_allocated_state(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState& _internal_state() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* unsafe_arena_release_state();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class ResetSimulationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationReq) */ {
 public:
  inline ResetSimulationReq() : ResetSimulationReq(nullptr) {}
  ~ResetSimulationReq() override;
  explicit PROTOBUF_CONSTEXPR ResetSimulationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetSimulationReq(const ResetSimulationReq& from);
  ResetSimulationReq(ResetSimulationReq&& from) noexcept
    : ResetSimulationReq() {
    *this = ::std::move(from);
  }

  inline ResetSimulationReq& operator=(const ResetSimulationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetSimulationReq& operator=(ResetSimulationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetSimulationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetSimulationReq* internal_default_instance() {
    return reinterpret_cast<const ResetSimulationReq*>(
               &_ResetSimulationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResetSimulationReq& a, ResetSimulationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetSimulationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetSimulationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetSimulationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetSimulationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetSimulationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetSimulationReq& from) {
    ResetSimulationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetSimulationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationReq";
  }
  protected:
  explicit ResetSimulationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class ResetSimulationRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes) */ {
 public:
  inline ResetSimulationRes() : ResetSimulationRes(nullptr) {}
  ~ResetSimulationRes() override;
  explicit PROTOBUF_CONSTEXPR ResetSimulationRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetSimulationRes(const ResetSimulationRes& from);
  ResetSimulationRes(ResetSimulationRes&& from) noexcept
    : ResetSimulationRes() {
    *this = ::std::move(from);
  }

  inline ResetSimulationRes& operator=(const ResetSimulationRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetSimulationRes& operator=(ResetSimulationRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetSimulationRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetSimulationRes* internal_default_instance() {
    return reinterpret_cast<const ResetSimulationRes*>(
               &_ResetSimulationRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ResetSimulationRes& a, ResetSimulationRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetSimulationRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetSimulationRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetSimulationRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetSimulationRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetSimulationRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetSimulationRes& from) {
    ResetSimulationRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetSimulationRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes";
  }
  protected:
  explicit ResetSimulationRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string simulation_id = 1;
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class StopSimulationReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationReq) */ {
 public:
  inline StopSimulationReq() : StopSimulationReq(nullptr) {}
  ~StopSimulationReq() override;
  explicit PROTOBUF_CONSTEXPR StopSimulationReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopSimulationReq(const StopSimulationReq& from);
  StopSimulationReq(StopSimulationReq&& from) noexcept
    : StopSimulationReq() {
    *this = ::std::move(from);
  }

  inline StopSimulationReq& operator=(const StopSimulationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSimulationReq& operator=(StopSimulationReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopSimulationReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopSimulationReq* internal_default_instance() {
    return reinterpret_cast<const StopSimulationReq*>(
               &_StopSimulationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(StopSimulationReq& a, StopSimulationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSimulationReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSimulationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopSimulationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopSimulationReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopSimulationReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopSimulationReq& from) {
    StopSimulationReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSimulationReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationReq";
  }
  protected:
  explicit StopSimulationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 2,
  };
  // string simulation_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class StopSimulationRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes) */ {
 public:
  inline StopSimulationRes() : StopSimulationRes(nullptr) {}
  ~StopSimulationRes() override;
  explicit PROTOBUF_CONSTEXPR StopSimulationRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopSimulationRes(const StopSimulationRes& from);
  StopSimulationRes(StopSimulationRes&& from) noexcept
    : StopSimulationRes() {
    *this = ::std::move(from);
  }

  inline StopSimulationRes& operator=(const StopSimulationRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSimulationRes& operator=(StopSimulationRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopSimulationRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopSimulationRes* internal_default_instance() {
    return reinterpret_cast<const StopSimulationRes*>(
               &_StopSimulationRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(StopSimulationRes& a, StopSimulationRes& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSimulationRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSimulationRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopSimulationRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopSimulationRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopSimulationRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopSimulationRes& from) {
    StopSimulationRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSimulationRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes";
  }
  protected:
  explicit StopSimulationRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState& state() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* release_state();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* mutable_state();
  void set_allocated_state(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState& _internal_state() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* unsafe_arena_release_state();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetMapReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapReq) */ {
 public:
  inline GetMapReq() : GetMapReq(nullptr) {}
  ~GetMapReq() override;
  explicit PROTOBUF_CONSTEXPR GetMapReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMapReq(const GetMapReq& from);
  GetMapReq(GetMapReq&& from) noexcept
    : GetMapReq() {
    *this = ::std::move(from);
  }

  inline GetMapReq& operator=(const GetMapReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMapReq& operator=(GetMapReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMapReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMapReq* internal_default_instance() {
    return reinterpret_cast<const GetMapReq*>(
               &_GetMapReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetMapReq& a, GetMapReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMapReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMapReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMapReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMapReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMapReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMapReq& from) {
    GetMapReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMapReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapReq";
  }
  protected:
  explicit GetMapReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetMapRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes) */ {
 public:
  inline GetMapRes() : GetMapRes(nullptr) {}
  ~GetMapRes() override;
  explicit PROTOBUF_CONSTEXPR GetMapRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMapRes(const GetMapRes& from);
  GetMapRes(GetMapRes&& from) noexcept
    : GetMapRes() {
    *this = ::std::move(from);
  }

  inline GetMapRes& operator=(const GetMapRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMapRes& operator=(GetMapRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMapRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMapRes* internal_default_instance() {
    return reinterpret_cast<const GetMapRes*>(
               &_GetMapRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetMapRes& a, GetMapRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMapRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMapRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMapRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMapRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMapRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMapRes& from) {
    GetMapRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMapRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes";
  }
  protected:
  explicit GetMapRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kMapFieldNumber = 2,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map map = 2;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map& map() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* release_map();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* mutable_map();
  void set_allocated_map(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* map);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map& _internal_map() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* map);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* unsafe_arena_release_map();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* map_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetAllTrafficPartReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartReq) */ {
 public:
  inline GetAllTrafficPartReq() : GetAllTrafficPartReq(nullptr) {}
  ~GetAllTrafficPartReq() override;
  explicit PROTOBUF_CONSTEXPR GetAllTrafficPartReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllTrafficPartReq(const GetAllTrafficPartReq& from);
  GetAllTrafficPartReq(GetAllTrafficPartReq&& from) noexcept
    : GetAllTrafficPartReq() {
    *this = ::std::move(from);
  }

  inline GetAllTrafficPartReq& operator=(const GetAllTrafficPartReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllTrafficPartReq& operator=(GetAllTrafficPartReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllTrafficPartReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllTrafficPartReq* internal_default_instance() {
    return reinterpret_cast<const GetAllTrafficPartReq*>(
               &_GetAllTrafficPartReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetAllTrafficPartReq& a, GetAllTrafficPartReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllTrafficPartReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllTrafficPartReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllTrafficPartReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllTrafficPartReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllTrafficPartReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllTrafficPartReq& from) {
    GetAllTrafficPartReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllTrafficPartReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartReq";
  }
  protected:
  explicit GetAllTrafficPartReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetAllTrafficPartRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes) */ {
 public:
  inline GetAllTrafficPartRes() : GetAllTrafficPartRes(nullptr) {}
  ~GetAllTrafficPartRes() override;
  explicit PROTOBUF_CONSTEXPR GetAllTrafficPartRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllTrafficPartRes(const GetAllTrafficPartRes& from);
  GetAllTrafficPartRes(GetAllTrafficPartRes&& from) noexcept
    : GetAllTrafficPartRes() {
    *this = ::std::move(from);
  }

  inline GetAllTrafficPartRes& operator=(const GetAllTrafficPartRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllTrafficPartRes& operator=(GetAllTrafficPartRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllTrafficPartRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllTrafficPartRes* internal_default_instance() {
    return reinterpret_cast<const GetAllTrafficPartRes*>(
               &_GetAllTrafficPartRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetAllTrafficPartRes& a, GetAllTrafficPartRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllTrafficPartRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllTrafficPartRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllTrafficPartRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllTrafficPartRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllTrafficPartRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllTrafficPartRes& from) {
    GetAllTrafficPartRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllTrafficPartRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes";
  }
  protected:
  explicit GetAllTrafficPartRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj list = 2;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj >*
      mutable_list();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& _internal_list(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* _internal_add_list();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& list(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj >&
      list() const;

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj > list_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class SetVehicleControlReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq) */ {
 public:
  inline SetVehicleControlReq() : SetVehicleControlReq(nullptr) {}
  ~SetVehicleControlReq() override;
  explicit PROTOBUF_CONSTEXPR SetVehicleControlReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVehicleControlReq(const SetVehicleControlReq& from);
  SetVehicleControlReq(SetVehicleControlReq&& from) noexcept
    : SetVehicleControlReq() {
    *this = ::std::move(from);
  }

  inline SetVehicleControlReq& operator=(const SetVehicleControlReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVehicleControlReq& operator=(SetVehicleControlReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVehicleControlReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVehicleControlReq* internal_default_instance() {
    return reinterpret_cast<const SetVehicleControlReq*>(
               &_SetVehicleControlReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetVehicleControlReq& a, SetVehicleControlReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVehicleControlReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVehicleControlReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVehicleControlReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVehicleControlReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVehicleControlReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVehicleControlReq& from) {
    SetVehicleControlReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVehicleControlReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq";
  }
  protected:
  explicit SetVehicleControlReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
    kVehicleIdFieldNumber = 2,
    kLonAccFieldNumber = 3,
    kSteWheelFieldNumber = 4,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // string vehicle_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vehicle_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vehicle_id();
  PROTOBUF_NODISCARD std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // double lon_acc = 3;
  void clear_lon_acc();
  double lon_acc() const;
  void set_lon_acc(double value);
  private:
  double _internal_lon_acc() const;
  void _internal_set_lon_acc(double value);
  public:

  // double ste_wheel = 4;
  void clear_ste_wheel();
  double ste_wheel() const;
  void set_ste_wheel(double value);
  private:
  double _internal_ste_wheel() const;
  void _internal_set_ste_wheel(double value);
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
    double lon_acc_;
    double ste_wheel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class SetVehicleControlRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes) */ {
 public:
  inline SetVehicleControlRes() : SetVehicleControlRes(nullptr) {}
  ~SetVehicleControlRes() override;
  explicit PROTOBUF_CONSTEXPR SetVehicleControlRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVehicleControlRes(const SetVehicleControlRes& from);
  SetVehicleControlRes(SetVehicleControlRes&& from) noexcept
    : SetVehicleControlRes() {
    *this = ::std::move(from);
  }

  inline SetVehicleControlRes& operator=(const SetVehicleControlRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVehicleControlRes& operator=(SetVehicleControlRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVehicleControlRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVehicleControlRes* internal_default_instance() {
    return reinterpret_cast<const SetVehicleControlRes*>(
               &_SetVehicleControlRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SetVehicleControlRes& a, SetVehicleControlRes& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVehicleControlRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVehicleControlRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVehicleControlRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVehicleControlRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVehicleControlRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVehicleControlRes& from) {
    SetVehicleControlRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVehicleControlRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes";
  }
  protected:
  explicit SetVehicleControlRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kVehicleFieldNumber = 2,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle vehicle = 2;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle& vehicle() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* release_vehicle();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* mutable_vehicle();
  void set_allocated_vehicle(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle& _internal_vehicle() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* unsafe_arena_release_vehicle();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetVehicleReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq) */ {
 public:
  inline GetVehicleReq() : GetVehicleReq(nullptr) {}
  ~GetVehicleReq() override;
  explicit PROTOBUF_CONSTEXPR GetVehicleReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVehicleReq(const GetVehicleReq& from);
  GetVehicleReq(GetVehicleReq&& from) noexcept
    : GetVehicleReq() {
    *this = ::std::move(from);
  }

  inline GetVehicleReq& operator=(const GetVehicleReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVehicleReq& operator=(GetVehicleReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVehicleReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVehicleReq* internal_default_instance() {
    return reinterpret_cast<const GetVehicleReq*>(
               &_GetVehicleReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetVehicleReq& a, GetVehicleReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVehicleReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVehicleReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVehicleReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVehicleReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVehicleReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVehicleReq& from) {
    GetVehicleReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVehicleReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq";
  }
  protected:
  explicit GetVehicleReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
    kVehicleIdFieldNumber = 2,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // string vehicle_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vehicle_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vehicle_id();
  PROTOBUF_NODISCARD std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetVehicleRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes) */ {
 public:
  inline GetVehicleRes() : GetVehicleRes(nullptr) {}
  ~GetVehicleRes() override;
  explicit PROTOBUF_CONSTEXPR GetVehicleRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVehicleRes(const GetVehicleRes& from);
  GetVehicleRes(GetVehicleRes&& from) noexcept
    : GetVehicleRes() {
    *this = ::std::move(from);
  }

  inline GetVehicleRes& operator=(const GetVehicleRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVehicleRes& operator=(GetVehicleRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVehicleRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVehicleRes* internal_default_instance() {
    return reinterpret_cast<const GetVehicleRes*>(
               &_GetVehicleRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetVehicleRes& a, GetVehicleRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVehicleRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVehicleRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVehicleRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVehicleRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVehicleRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVehicleRes& from) {
    GetVehicleRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVehicleRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes";
  }
  protected:
  explicit GetVehicleRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kVehicleFieldNumber = 2,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle vehicle = 2;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle& vehicle() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* release_vehicle();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* mutable_vehicle();
  void set_allocated_vehicle(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle& _internal_vehicle() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* unsafe_arena_release_vehicle();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetResultsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsReq) */ {
 public:
  inline GetResultsReq() : GetResultsReq(nullptr) {}
  ~GetResultsReq() override;
  explicit PROTOBUF_CONSTEXPR GetResultsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResultsReq(const GetResultsReq& from);
  GetResultsReq(GetResultsReq&& from) noexcept
    : GetResultsReq() {
    *this = ::std::move(from);
  }

  inline GetResultsReq& operator=(const GetResultsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResultsReq& operator=(GetResultsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResultsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResultsReq* internal_default_instance() {
    return reinterpret_cast<const GetResultsReq*>(
               &_GetResultsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetResultsReq& a, GetResultsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResultsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResultsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResultsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResultsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResultsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResultsReq& from) {
    GetResultsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResultsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsReq";
  }
  protected:
  explicit GetResultsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetResultsRes_ResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResultsRes_ResultsEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResultsRes_ResultsEntry_DoNotUse, 
    std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetResultsRes_ResultsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetResultsRes_ResultsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetResultsRes_ResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResultsRes_ResultsEntry_DoNotUse& other);
  static const GetResultsRes_ResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResultsRes_ResultsEntry_DoNotUse*>(&_GetResultsRes_ResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.ResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};

// -------------------------------------------------------------------

class GetResultsRes_item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item) */ {
 public:
  inline GetResultsRes_item() : GetResultsRes_item(nullptr) {}
  ~GetResultsRes_item() override;
  explicit PROTOBUF_CONSTEXPR GetResultsRes_item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResultsRes_item(const GetResultsRes_item& from);
  GetResultsRes_item(GetResultsRes_item&& from) noexcept
    : GetResultsRes_item() {
    *this = ::std::move(from);
  }

  inline GetResultsRes_item& operator=(const GetResultsRes_item& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResultsRes_item& operator=(GetResultsRes_item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResultsRes_item& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResultsRes_item* internal_default_instance() {
    return reinterpret_cast<const GetResultsRes_item*>(
               &_GetResultsRes_item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetResultsRes_item& a, GetResultsRes_item& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResultsRes_item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResultsRes_item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResultsRes_item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResultsRes_item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResultsRes_item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResultsRes_item& from) {
    GetResultsRes_item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResultsRes_item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item";
  }
  protected:
  explicit GetResultsRes_item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
  };
  // repeated double r = 1;
  int r_size() const;
  private:
  int _internal_r_size() const;
  public:
  void clear_r();
  private:
  double _internal_r(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_r() const;
  void _internal_add_r(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_r();
  public:
  double r(int index) const;
  void set_r(int index, double value);
  void add_r(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      r() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_r();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > r_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetResultsRes_arrays final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays) */ {
 public:
  inline GetResultsRes_arrays() : GetResultsRes_arrays(nullptr) {}
  ~GetResultsRes_arrays() override;
  explicit PROTOBUF_CONSTEXPR GetResultsRes_arrays(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResultsRes_arrays(const GetResultsRes_arrays& from);
  GetResultsRes_arrays(GetResultsRes_arrays&& from) noexcept
    : GetResultsRes_arrays() {
    *this = ::std::move(from);
  }

  inline GetResultsRes_arrays& operator=(const GetResultsRes_arrays& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResultsRes_arrays& operator=(GetResultsRes_arrays&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResultsRes_arrays& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResultsRes_arrays* internal_default_instance() {
    return reinterpret_cast<const GetResultsRes_arrays*>(
               &_GetResultsRes_arrays_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetResultsRes_arrays& a, GetResultsRes_arrays& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResultsRes_arrays* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResultsRes_arrays* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResultsRes_arrays* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResultsRes_arrays>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResultsRes_arrays& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResultsRes_arrays& from) {
    GetResultsRes_arrays::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResultsRes_arrays* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays";
  }
  protected:
  explicit GetResultsRes_arrays(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrFieldNumber = 1,
  };
  // repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item arr = 1;
  int arr_size() const;
  private:
  int _internal_arr_size() const;
  public:
  void clear_arr();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item* mutable_arr(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item >*
      mutable_arr();
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item& _internal_arr(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item* _internal_add_arr();
  public:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item& arr(int index) const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item* add_arr();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item >&
      arr() const;

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item > arr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetResultsRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes) */ {
 public:
  inline GetResultsRes() : GetResultsRes(nullptr) {}
  ~GetResultsRes() override;
  explicit PROTOBUF_CONSTEXPR GetResultsRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResultsRes(const GetResultsRes& from);
  GetResultsRes(GetResultsRes&& from) noexcept
    : GetResultsRes() {
    *this = ::std::move(from);
  }

  inline GetResultsRes& operator=(const GetResultsRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResultsRes& operator=(GetResultsRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResultsRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResultsRes* internal_default_instance() {
    return reinterpret_cast<const GetResultsRes*>(
               &_GetResultsRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GetResultsRes& a, GetResultsRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResultsRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResultsRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResultsRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResultsRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResultsRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResultsRes& from) {
    GetResultsRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResultsRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes";
  }
  protected:
  explicit GetResultsRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetResultsRes_item item;
  typedef GetResultsRes_arrays arrays;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays> results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays >&
      _internal_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays >*
      _internal_mutable_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays >&
      results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays >*
      mutable_results();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetResultsRes_ResultsEntry_DoNotUse,
        std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> results_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetLinkReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq) */ {
 public:
  inline GetLinkReq() : GetLinkReq(nullptr) {}
  ~GetLinkReq() override;
  explicit PROTOBUF_CONSTEXPR GetLinkReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLinkReq(const GetLinkReq& from);
  GetLinkReq(GetLinkReq&& from) noexcept
    : GetLinkReq() {
    *this = ::std::move(from);
  }

  inline GetLinkReq& operator=(const GetLinkReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLinkReq& operator=(GetLinkReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLinkReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLinkReq* internal_default_instance() {
    return reinterpret_cast<const GetLinkReq*>(
               &_GetLinkReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetLinkReq& a, GetLinkReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLinkReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLinkReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLinkReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLinkReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLinkReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLinkReq& from) {
    GetLinkReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLinkReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq";
  }
  protected:
  explicit GetLinkReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
    kLinkIdFieldNumber = 2,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // string link_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_link_id();
  const std::string& link_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link_id();
  PROTOBUF_NODISCARD std::string* release_link_id();
  void set_allocated_link_id(std::string* link_id);
  private:
  const std::string& _internal_link_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_id(const std::string& value);
  std::string* _internal_mutable_link_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetLinkRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes) */ {
 public:
  inline GetLinkRes() : GetLinkRes(nullptr) {}
  ~GetLinkRes() override;
  explicit PROTOBUF_CONSTEXPR GetLinkRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLinkRes(const GetLinkRes& from);
  GetLinkRes(GetLinkRes&& from) noexcept
    : GetLinkRes() {
    *this = ::std::move(from);
  }

  inline GetLinkRes& operator=(const GetLinkRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLinkRes& operator=(GetLinkRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLinkRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLinkRes* internal_default_instance() {
    return reinterpret_cast<const GetLinkRes*>(
               &_GetLinkRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetLinkRes& a, GetLinkRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLinkRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLinkRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLinkRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLinkRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLinkRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLinkRes& from) {
    GetLinkRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLinkRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes";
  }
  protected:
  explicit GetLinkRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kLinkFieldNumber = 2,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link link = 2;
  bool has_link() const;
  private:
  bool _internal_has_link() const;
  public:
  void clear_link();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link& link() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* release_link();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* mutable_link();
  void set_allocated_link(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* link);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link& _internal_link() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* _internal_mutable_link();
  public:
  void unsafe_arena_set_allocated_link(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* link);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* unsafe_arena_release_link();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* link_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetLaneReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq) */ {
 public:
  inline GetLaneReq() : GetLaneReq(nullptr) {}
  ~GetLaneReq() override;
  explicit PROTOBUF_CONSTEXPR GetLaneReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLaneReq(const GetLaneReq& from);
  GetLaneReq(GetLaneReq&& from) noexcept
    : GetLaneReq() {
    *this = ::std::move(from);
  }

  inline GetLaneReq& operator=(const GetLaneReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLaneReq& operator=(GetLaneReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLaneReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLaneReq* internal_default_instance() {
    return reinterpret_cast<const GetLaneReq*>(
               &_GetLaneReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetLaneReq& a, GetLaneReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLaneReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLaneReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLaneReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLaneReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLaneReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLaneReq& from) {
    GetLaneReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLaneReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq";
  }
  protected:
  explicit GetLaneReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
    kLaneIdFieldNumber = 2,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // string lane_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_lane_id();
  const std::string& lane_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lane_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lane_id();
  PROTOBUF_NODISCARD std::string* release_lane_id();
  void set_allocated_lane_id(std::string* lane_id);
  private:
  const std::string& _internal_lane_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lane_id(const std::string& value);
  std::string* _internal_mutable_lane_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lane_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetLaneRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes) */ {
 public:
  inline GetLaneRes() : GetLaneRes(nullptr) {}
  ~GetLaneRes() override;
  explicit PROTOBUF_CONSTEXPR GetLaneRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLaneRes(const GetLaneRes& from);
  GetLaneRes(GetLaneRes&& from) noexcept
    : GetLaneRes() {
    *this = ::std::move(from);
  }

  inline GetLaneRes& operator=(const GetLaneRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLaneRes& operator=(GetLaneRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLaneRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLaneRes* internal_default_instance() {
    return reinterpret_cast<const GetLaneRes*>(
               &_GetLaneRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetLaneRes& a, GetLaneRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLaneRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLaneRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLaneRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLaneRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLaneRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLaneRes& from) {
    GetLaneRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLaneRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes";
  }
  protected:
  explicit GetLaneRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kLaneFieldNumber = 2,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane lane = 2;
  bool has_lane() const;
  private:
  bool _internal_has_lane() const;
  public:
  void clear_lane();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane& lane() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* release_lane();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* mutable_lane();
  void set_allocated_lane(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* lane);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane& _internal_lane() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* _internal_mutable_lane();
  public:
  void unsafe_arena_set_allocated_lane(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* lane);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* unsafe_arena_release_lane();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* lane_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetJunctionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq) */ {
 public:
  inline GetJunctionReq() : GetJunctionReq(nullptr) {}
  ~GetJunctionReq() override;
  explicit PROTOBUF_CONSTEXPR GetJunctionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetJunctionReq(const GetJunctionReq& from);
  GetJunctionReq(GetJunctionReq&& from) noexcept
    : GetJunctionReq() {
    *this = ::std::move(from);
  }

  inline GetJunctionReq& operator=(const GetJunctionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetJunctionReq& operator=(GetJunctionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetJunctionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetJunctionReq* internal_default_instance() {
    return reinterpret_cast<const GetJunctionReq*>(
               &_GetJunctionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetJunctionReq& a, GetJunctionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetJunctionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetJunctionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetJunctionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetJunctionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetJunctionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetJunctionReq& from) {
    GetJunctionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJunctionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq";
  }
  protected:
  explicit GetJunctionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
    kJunctionIdFieldNumber = 2,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // string junction_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_junction_id();
  const std::string& junction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_junction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_junction_id();
  PROTOBUF_NODISCARD std::string* release_junction_id();
  void set_allocated_junction_id(std::string* junction_id);
  private:
  const std::string& _internal_junction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_junction_id(const std::string& value);
  std::string* _internal_mutable_junction_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr junction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetJunctionRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes) */ {
 public:
  inline GetJunctionRes() : GetJunctionRes(nullptr) {}
  ~GetJunctionRes() override;
  explicit PROTOBUF_CONSTEXPR GetJunctionRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetJunctionRes(const GetJunctionRes& from);
  GetJunctionRes(GetJunctionRes&& from) noexcept
    : GetJunctionRes() {
    *this = ::std::move(from);
  }

  inline GetJunctionRes& operator=(const GetJunctionRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetJunctionRes& operator=(GetJunctionRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetJunctionRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetJunctionRes* internal_default_instance() {
    return reinterpret_cast<const GetJunctionRes*>(
               &_GetJunctionRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetJunctionRes& a, GetJunctionRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetJunctionRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetJunctionRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetJunctionRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetJunctionRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetJunctionRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetJunctionRes& from) {
    GetJunctionRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJunctionRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes";
  }
  protected:
  explicit GetJunctionRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kJunctionFieldNumber = 2,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction junction = 2;
  bool has_junction() const;
  private:
  bool _internal_has_junction() const;
  public:
  void clear_junction();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction& junction() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* release_junction();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* mutable_junction();
  void set_allocated_junction(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* junction);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction& _internal_junction() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* _internal_mutable_junction();
  public:
  void unsafe_arena_set_allocated_junction(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* junction);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* unsafe_arena_release_junction();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* junction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetSegmentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq) */ {
 public:
  inline GetSegmentReq() : GetSegmentReq(nullptr) {}
  ~GetSegmentReq() override;
  explicit PROTOBUF_CONSTEXPR GetSegmentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSegmentReq(const GetSegmentReq& from);
  GetSegmentReq(GetSegmentReq&& from) noexcept
    : GetSegmentReq() {
    *this = ::std::move(from);
  }

  inline GetSegmentReq& operator=(const GetSegmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSegmentReq& operator=(GetSegmentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSegmentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSegmentReq* internal_default_instance() {
    return reinterpret_cast<const GetSegmentReq*>(
               &_GetSegmentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetSegmentReq& a, GetSegmentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSegmentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSegmentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSegmentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSegmentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSegmentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSegmentReq& from) {
    GetSegmentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSegmentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq";
  }
  protected:
  explicit GetSegmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationIdFieldNumber = 1,
    kSegmentIdFieldNumber = 2,
  };
  // string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_simulation_id();
  const std::string& simulation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_simulation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_simulation_id();
  PROTOBUF_NODISCARD std::string* release_simulation_id();
  void set_allocated_simulation_id(std::string* simulation_id);
  private:
  const std::string& _internal_simulation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_simulation_id(const std::string& value);
  std::string* _internal_mutable_simulation_id();
  public:

  // string segment_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_segment_id();
  const std::string& segment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* segment_id);
  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(const std::string& value);
  std::string* _internal_mutable_segment_id();
  public:

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr simulation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segment_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// -------------------------------------------------------------------

class GetSegmentRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes) */ {
 public:
  inline GetSegmentRes() : GetSegmentRes(nullptr) {}
  ~GetSegmentRes() override;
  explicit PROTOBUF_CONSTEXPR GetSegmentRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSegmentRes(const GetSegmentRes& from);
  GetSegmentRes(GetSegmentRes&& from) noexcept
    : GetSegmentRes() {
    *this = ::std::move(from);
  }

  inline GetSegmentRes& operator=(const GetSegmentRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSegmentRes& operator=(GetSegmentRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSegmentRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSegmentRes* internal_default_instance() {
    return reinterpret_cast<const GetSegmentRes*>(
               &_GetSegmentRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(GetSegmentRes& a, GetSegmentRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSegmentRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSegmentRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSegmentRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSegmentRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSegmentRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSegmentRes& from) {
    GetSegmentRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSegmentRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes";
  }
  protected:
  explicit GetSegmentRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kSegmentFieldNumber = 2,
  };
  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* release_error();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* mutable_error();
  void set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& _internal_error() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* unsafe_arena_release_error();

  // .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment segment = 2;
  bool has_segment() const;
  private:
  bool _internal_has_segment() const;
  public:
  void clear_segment();
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment& segment() const;
  PROTOBUF_NODISCARD ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* release_segment();
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* mutable_segment();
  void set_allocated_segment(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* segment);
  private:
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment& _internal_segment() const;
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* _internal_mutable_segment();
  public:
  void unsafe_arena_set_allocated_segment(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* segment);
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* unsafe_arena_release_segment();

  // @@protoc_insertion_point(class_scope:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error_;
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* segment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ErrorMsg

// int32 code = 1;
inline void ErrorMsg::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t ErrorMsg::_internal_code() const {
  return _impl_.code_;
}
inline int32_t ErrorMsg::code() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg.code)
  return _internal_code();
}
inline void ErrorMsg::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void ErrorMsg::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg.code)
}

// string msg = 2;
inline void ErrorMsg::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& ErrorMsg::msg() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorMsg::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg.msg)
}
inline std::string* ErrorMsg::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg.msg)
  return _s;
}
inline const std::string& ErrorMsg::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void ErrorMsg::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorMsg::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorMsg::release_msg() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg.msg)
  return _impl_.msg_.Release();
}
inline void ErrorMsg::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg.msg)
}

// -------------------------------------------------------------------

// BaseInfo

// double Length = 1;
inline void BaseInfo::clear_length() {
  _impl_.length_ = 0;
}
inline double BaseInfo::_internal_length() const {
  return _impl_.length_;
}
inline double BaseInfo::length() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.Length)
  return _internal_length();
}
inline void BaseInfo::_internal_set_length(double value) {
  
  _impl_.length_ = value;
}
inline void BaseInfo::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.Length)
}

// double Width = 2;
inline void BaseInfo::clear_width() {
  _impl_.width_ = 0;
}
inline double BaseInfo::_internal_width() const {
  return _impl_.width_;
}
inline double BaseInfo::width() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.Width)
  return _internal_width();
}
inline void BaseInfo::_internal_set_width(double value) {
  
  _impl_.width_ = value;
}
inline void BaseInfo::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.Width)
}

// double Height = 3;
inline void BaseInfo::clear_height() {
  _impl_.height_ = 0;
}
inline double BaseInfo::_internal_height() const {
  return _impl_.height_;
}
inline double BaseInfo::height() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.Height)
  return _internal_height();
}
inline void BaseInfo::_internal_set_height(double value) {
  
  _impl_.height_ = value;
}
inline void BaseInfo::set_height(double value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.Height)
}

// double Weight = 4;
inline void BaseInfo::clear_weight() {
  _impl_.weight_ = 0;
}
inline double BaseInfo::_internal_weight() const {
  return _impl_.weight_;
}
inline double BaseInfo::weight() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.Weight)
  return _internal_weight();
}
inline void BaseInfo::_internal_set_weight(double value) {
  
  _impl_.weight_ = value;
}
inline void BaseInfo::set_weight(double value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.Weight)
}

// double max_dec = 5;
inline void BaseInfo::clear_max_dec() {
  _impl_.max_dec_ = 0;
}
inline double BaseInfo::_internal_max_dec() const {
  return _impl_.max_dec_;
}
inline double BaseInfo::max_dec() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.max_dec)
  return _internal_max_dec();
}
inline void BaseInfo::_internal_set_max_dec(double value) {
  
  _impl_.max_dec_ = value;
}
inline void BaseInfo::set_max_dec(double value) {
  _internal_set_max_dec(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.max_dec)
}

// double max_acc = 6;
inline void BaseInfo::clear_max_acc() {
  _impl_.max_acc_ = 0;
}
inline double BaseInfo::_internal_max_acc() const {
  return _impl_.max_acc_;
}
inline double BaseInfo::max_acc() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.max_acc)
  return _internal_max_acc();
}
inline void BaseInfo::_internal_set_max_acc(double value) {
  
  _impl_.max_acc_ = value;
}
inline void BaseInfo::set_max_acc(double value) {
  _internal_set_max_acc(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo.max_acc)
}

// -------------------------------------------------------------------

// Position

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Point point = 1;
inline bool Position::_internal_has_point() const {
  return this != internal_default_instance() && _impl_.point_ != nullptr;
}
inline bool Position::has_point() const {
  return _internal_has_point();
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Position::_internal_point() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Point_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point& Position::point() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.point)
  return _internal_point();
}
inline void Position::unsafe_arena_set_allocated_point(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.point)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Position::release_point() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Position::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.point)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Position::_internal_mutable_point() {
  
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* Position::mutable_point() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.point)
  return _msg;
}
inline void Position::set_allocated_point(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Point* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point));
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.point)
}

// double phi = 2;
inline void Position::clear_phi() {
  _impl_.phi_ = 0;
}
inline double Position::_internal_phi() const {
  return _impl_.phi_;
}
inline double Position::phi() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.phi)
  return _internal_phi();
}
inline void Position::_internal_set_phi(double value) {
  
  _impl_.phi_ = value;
}
inline void Position::set_phi(double value) {
  _internal_set_phi(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.phi)
}

// string link_id = 3;
inline void Position::clear_link_id() {
  _impl_.link_id_.ClearToEmpty();
}
inline const std::string& Position::link_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.link_id)
  return _internal_link_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Position::set_link_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.link_id)
}
inline std::string* Position::mutable_link_id() {
  std::string* _s = _internal_mutable_link_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.link_id)
  return _s;
}
inline const std::string& Position::_internal_link_id() const {
  return _impl_.link_id_.Get();
}
inline void Position::_internal_set_link_id(const std::string& value) {
  
  _impl_.link_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Position::_internal_mutable_link_id() {
  
  return _impl_.link_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Position::release_link_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.link_id)
  return _impl_.link_id_.Release();
}
inline void Position::set_allocated_link_id(std::string* link_id) {
  if (link_id != nullptr) {
    
  } else {
    
  }
  _impl_.link_id_.SetAllocated(link_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_id_.IsDefault()) {
    _impl_.link_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.link_id)
}

// double dis_to_link_end = 4;
inline void Position::clear_dis_to_link_end() {
  _impl_.dis_to_link_end_ = 0;
}
inline double Position::_internal_dis_to_link_end() const {
  return _impl_.dis_to_link_end_;
}
inline double Position::dis_to_link_end() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.dis_to_link_end)
  return _internal_dis_to_link_end();
}
inline void Position::_internal_set_dis_to_link_end(double value) {
  
  _impl_.dis_to_link_end_ = value;
}
inline void Position::set_dis_to_link_end(double value) {
  _internal_set_dis_to_link_end(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.dis_to_link_end)
}

// string lane_id = 5;
inline void Position::clear_lane_id() {
  _impl_.lane_id_.ClearToEmpty();
}
inline const std::string& Position::lane_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.lane_id)
  return _internal_lane_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Position::set_lane_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lane_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.lane_id)
}
inline std::string* Position::mutable_lane_id() {
  std::string* _s = _internal_mutable_lane_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.lane_id)
  return _s;
}
inline const std::string& Position::_internal_lane_id() const {
  return _impl_.lane_id_.Get();
}
inline void Position::_internal_set_lane_id(const std::string& value) {
  
  _impl_.lane_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Position::_internal_mutable_lane_id() {
  
  return _impl_.lane_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Position::release_lane_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.lane_id)
  return _impl_.lane_id_.Release();
}
inline void Position::set_allocated_lane_id(std::string* lane_id) {
  if (lane_id != nullptr) {
    
  } else {
    
  }
  _impl_.lane_id_.SetAllocated(lane_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lane_id_.IsDefault()) {
    _impl_.lane_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.lane_id)
}

// string segment_id = 6;
inline void Position::clear_segment_id() {
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& Position::segment_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.segment_id)
  return _internal_segment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Position::set_segment_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.segment_id)
}
inline std::string* Position::mutable_segment_id() {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.segment_id)
  return _s;
}
inline const std::string& Position::_internal_segment_id() const {
  return _impl_.segment_id_.Get();
}
inline void Position::_internal_set_segment_id(const std::string& value) {
  
  _impl_.segment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Position::_internal_mutable_segment_id() {
  
  return _impl_.segment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Position::release_segment_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.segment_id)
  return _impl_.segment_id_.Release();
}
inline void Position::set_allocated_segment_id(std::string* segment_id) {
  if (segment_id != nullptr) {
    
  } else {
    
  }
  _impl_.segment_id_.SetAllocated(segment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.segment_id)
}

// string junction_id = 7;
inline void Position::clear_junction_id() {
  _impl_.junction_id_.ClearToEmpty();
}
inline const std::string& Position::junction_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.junction_id)
  return _internal_junction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Position::set_junction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.junction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.junction_id)
}
inline std::string* Position::mutable_junction_id() {
  std::string* _s = _internal_mutable_junction_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.junction_id)
  return _s;
}
inline const std::string& Position::_internal_junction_id() const {
  return _impl_.junction_id_.Get();
}
inline void Position::_internal_set_junction_id(const std::string& value) {
  
  _impl_.junction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Position::_internal_mutable_junction_id() {
  
  return _impl_.junction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Position::release_junction_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.junction_id)
  return _impl_.junction_id_.Release();
}
inline void Position::set_allocated_junction_id(std::string* junction_id) {
  if (junction_id != nullptr) {
    
  } else {
    
  }
  _impl_.junction_id_.SetAllocated(junction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.junction_id_.IsDefault()) {
    _impl_.junction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position.junction_id)
}

// -------------------------------------------------------------------

// MovingInfo

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position position = 1;
inline bool MovingInfo::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool MovingInfo::has_position() const {
  return _internal_has_position();
}
inline void MovingInfo::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& MovingInfo::_internal_position() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Position_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& MovingInfo::position() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.position)
  return _internal_position();
}
inline void MovingInfo::unsafe_arena_set_allocated_position(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.position)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* MovingInfo::release_position() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* MovingInfo::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.position)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* MovingInfo::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* MovingInfo::mutable_position() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.position)
  return _msg;
}
inline void MovingInfo::set_allocated_position(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.position)
}

// int64 timestamp = 2;
inline void MovingInfo::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t MovingInfo::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t MovingInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.timestamp)
  return _internal_timestamp();
}
inline void MovingInfo::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void MovingInfo::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.timestamp)
}

// double u = 3;
inline void MovingInfo::clear_u() {
  _impl_.u_ = 0;
}
inline double MovingInfo::_internal_u() const {
  return _impl_.u_;
}
inline double MovingInfo::u() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.u)
  return _internal_u();
}
inline void MovingInfo::_internal_set_u(double value) {
  
  _impl_.u_ = value;
}
inline void MovingInfo::set_u(double value) {
  _internal_set_u(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.u)
}

// double lon_acc = 4;
inline void MovingInfo::clear_lon_acc() {
  _impl_.lon_acc_ = 0;
}
inline double MovingInfo::_internal_lon_acc() const {
  return _impl_.lon_acc_;
}
inline double MovingInfo::lon_acc() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.lon_acc)
  return _internal_lon_acc();
}
inline void MovingInfo::_internal_set_lon_acc(double value) {
  
  _impl_.lon_acc_ = value;
}
inline void MovingInfo::set_lon_acc(double value) {
  _internal_set_lon_acc(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.lon_acc)
}

// double v = 5;
inline void MovingInfo::clear_v() {
  _impl_.v_ = 0;
}
inline double MovingInfo::_internal_v() const {
  return _impl_.v_;
}
inline double MovingInfo::v() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.v)
  return _internal_v();
}
inline void MovingInfo::_internal_set_v(double value) {
  
  _impl_.v_ = value;
}
inline void MovingInfo::set_v(double value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.v)
}

// double lat_acc = 6;
inline void MovingInfo::clear_lat_acc() {
  _impl_.lat_acc_ = 0;
}
inline double MovingInfo::_internal_lat_acc() const {
  return _impl_.lat_acc_;
}
inline double MovingInfo::lat_acc() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.lat_acc)
  return _internal_lat_acc();
}
inline void MovingInfo::_internal_set_lat_acc(double value) {
  
  _impl_.lat_acc_ = value;
}
inline void MovingInfo::set_lat_acc(double value) {
  _internal_set_lat_acc(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.lat_acc)
}

// double w = 7;
inline void MovingInfo::clear_w() {
  _impl_.w_ = 0;
}
inline double MovingInfo::_internal_w() const {
  return _impl_.w_;
}
inline double MovingInfo::w() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.w)
  return _internal_w();
}
inline void MovingInfo::_internal_set_w(double value) {
  
  _impl_.w_ = value;
}
inline void MovingInfo::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.w)
}

// double w_acc = 8;
inline void MovingInfo::clear_w_acc() {
  _impl_.w_acc_ = 0;
}
inline double MovingInfo::_internal_w_acc() const {
  return _impl_.w_acc_;
}
inline double MovingInfo::w_acc() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.w_acc)
  return _internal_w_acc();
}
inline void MovingInfo::_internal_set_w_acc(double value) {
  
  _impl_.w_acc_ = value;
}
inline void MovingInfo::set_w_acc(double value) {
  _internal_set_w_acc(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo.w_acc)
}

// -------------------------------------------------------------------

// MovingObj

// string id = 1;
inline void MovingObj::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& MovingObj::id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MovingObj::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.id)
}
inline std::string* MovingObj::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.id)
  return _s;
}
inline const std::string& MovingObj::_internal_id() const {
  return _impl_.id_.Get();
}
inline void MovingObj::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* MovingObj::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* MovingObj::release_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.id)
  return _impl_.id_.Release();
}
inline void MovingObj::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.id)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.BaseInfo base_info = 2;
inline bool MovingObj::_internal_has_base_info() const {
  return this != internal_default_instance() && _impl_.base_info_ != nullptr;
}
inline bool MovingObj::has_base_info() const {
  return _internal_has_base_info();
}
inline void MovingObj::clear_base_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_info_ != nullptr) {
    delete _impl_.base_info_;
  }
  _impl_.base_info_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo& MovingObj::_internal_base_info() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* p = _impl_.base_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_BaseInfo_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo& MovingObj::base_info() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.base_info)
  return _internal_base_info();
}
inline void MovingObj::unsafe_arena_set_allocated_base_info(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* base_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_info_);
  }
  _impl_.base_info_ = base_info;
  if (base_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.base_info)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* MovingObj::release_base_info() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* temp = _impl_.base_info_;
  _impl_.base_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* MovingObj::unsafe_arena_release_base_info() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.base_info)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* temp = _impl_.base_info_;
  _impl_.base_info_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* MovingObj::_internal_mutable_base_info() {
  
  if (_impl_.base_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo>(GetArenaForAllocation());
    _impl_.base_info_ = p;
  }
  return _impl_.base_info_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* MovingObj::mutable_base_info() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* _msg = _internal_mutable_base_info();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.base_info)
  return _msg;
}
inline void MovingObj::set_allocated_base_info(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::BaseInfo* base_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_info_;
  }
  if (base_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base_info);
    if (message_arena != submessage_arena) {
      base_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_info_ = base_info;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.base_info)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingInfo moving_info = 3;
inline bool MovingObj::_internal_has_moving_info() const {
  return this != internal_default_instance() && _impl_.moving_info_ != nullptr;
}
inline bool MovingObj::has_moving_info() const {
  return _internal_has_moving_info();
}
inline void MovingObj::clear_moving_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.moving_info_ != nullptr) {
    delete _impl_.moving_info_;
  }
  _impl_.moving_info_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo& MovingObj::_internal_moving_info() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* p = _impl_.moving_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_MovingInfo_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo& MovingObj::moving_info() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.moving_info)
  return _internal_moving_info();
}
inline void MovingObj::unsafe_arena_set_allocated_moving_info(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* moving_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.moving_info_);
  }
  _impl_.moving_info_ = moving_info;
  if (moving_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.moving_info)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* MovingObj::release_moving_info() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* temp = _impl_.moving_info_;
  _impl_.moving_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* MovingObj::unsafe_arena_release_moving_info() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.moving_info)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* temp = _impl_.moving_info_;
  _impl_.moving_info_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* MovingObj::_internal_mutable_moving_info() {
  
  if (_impl_.moving_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo>(GetArenaForAllocation());
    _impl_.moving_info_ = p;
  }
  return _impl_.moving_info_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* MovingObj::mutable_moving_info() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* _msg = _internal_mutable_moving_info();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.moving_info)
  return _msg;
}
inline void MovingObj::set_allocated_moving_info(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingInfo* moving_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.moving_info_;
  }
  if (moving_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(moving_info);
    if (message_arena != submessage_arena) {
      moving_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moving_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.moving_info_ = moving_info;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.moving_info)
}

// string type = 4;
inline void MovingObj::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& MovingObj::type() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MovingObj::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.type)
}
inline std::string* MovingObj::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.type)
  return _s;
}
inline const std::string& MovingObj::_internal_type() const {
  return _impl_.type_.Get();
}
inline void MovingObj::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* MovingObj::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* MovingObj::release_type() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.type)
  return _impl_.type_.Release();
}
inline void MovingObj::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj.type)
}

// -------------------------------------------------------------------

// Vehicle

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj info = 1;
inline bool Vehicle::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool Vehicle::has_info() const {
  return _internal_has_info();
}
inline void Vehicle::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& Vehicle::_internal_info() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_MovingObj_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& Vehicle::info() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.info)
  return _internal_info();
}
inline void Vehicle::unsafe_arena_set_allocated_info(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.info)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* Vehicle::release_info() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* Vehicle::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.info)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* Vehicle::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* Vehicle::mutable_info() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.info)
  return _msg;
}
inline void Vehicle::set_allocated_info(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.info)
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj around_moving_objs = 2;
inline int Vehicle::_internal_around_moving_objs_size() const {
  return _impl_.around_moving_objs_.size();
}
inline int Vehicle::around_moving_objs_size() const {
  return _internal_around_moving_objs_size();
}
inline void Vehicle::clear_around_moving_objs() {
  _impl_.around_moving_objs_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* Vehicle::mutable_around_moving_objs(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.around_moving_objs)
  return _impl_.around_moving_objs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj >*
Vehicle::mutable_around_moving_objs() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.around_moving_objs)
  return &_impl_.around_moving_objs_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& Vehicle::_internal_around_moving_objs(int index) const {
  return _impl_.around_moving_objs_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& Vehicle::around_moving_objs(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.around_moving_objs)
  return _internal_around_moving_objs(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* Vehicle::_internal_add_around_moving_objs() {
  return _impl_.around_moving_objs_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* Vehicle::add_around_moving_objs() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* _add = _internal_add_around_moving_objs();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.around_moving_objs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj >&
Vehicle::around_moving_objs() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle.around_moving_objs)
  return _impl_.around_moving_objs_;
}

// -------------------------------------------------------------------

// VehicleControl

// double lon_acc = 1;
inline void VehicleControl::clear_lon_acc() {
  _impl_.lon_acc_ = 0;
}
inline double VehicleControl::_internal_lon_acc() const {
  return _impl_.lon_acc_;
}
inline double VehicleControl::lon_acc() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.VehicleControl.lon_acc)
  return _internal_lon_acc();
}
inline void VehicleControl::_internal_set_lon_acc(double value) {
  
  _impl_.lon_acc_ = value;
}
inline void VehicleControl::set_lon_acc(double value) {
  _internal_set_lon_acc(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.VehicleControl.lon_acc)
}

// double ste_wheel = 2;
inline void VehicleControl::clear_ste_wheel() {
  _impl_.ste_wheel_ = 0;
}
inline double VehicleControl::_internal_ste_wheel() const {
  return _impl_.ste_wheel_;
}
inline double VehicleControl::ste_wheel() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.VehicleControl.ste_wheel)
  return _internal_ste_wheel();
}
inline void VehicleControl::_internal_set_ste_wheel(double value) {
  
  _impl_.ste_wheel_ = value;
}
inline void VehicleControl::set_ste_wheel(double value) {
  _internal_set_ste_wheel(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.VehicleControl.ste_wheel)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Map

// map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction> junction_map = 1;
inline int Map::_internal_junction_map_size() const {
  return _impl_.junction_map_.size();
}
inline int Map::junction_map_size() const {
  return _internal_junction_map_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >&
Map::_internal_junction_map() const {
  return _impl_.junction_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >&
Map::junction_map() const {
  // @@protoc_insertion_point(field_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.junction_map)
  return _internal_junction_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >*
Map::_internal_mutable_junction_map() {
  return _impl_.junction_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction >*
Map::mutable_junction_map() {
  // @@protoc_insertion_point(field_mutable_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.junction_map)
  return _internal_mutable_junction_map();
}

// map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment> segment_map = 2;
inline int Map::_internal_segment_map_size() const {
  return _impl_.segment_map_.size();
}
inline int Map::segment_map_size() const {
  return _internal_segment_map_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >&
Map::_internal_segment_map() const {
  return _impl_.segment_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >&
Map::segment_map() const {
  // @@protoc_insertion_point(field_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.segment_map)
  return _internal_segment_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >*
Map::_internal_mutable_segment_map() {
  return _impl_.segment_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment >*
Map::mutable_segment_map() {
  // @@protoc_insertion_point(field_mutable_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.segment_map)
  return _internal_mutable_segment_map();
}

// map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link> link_map = 3;
inline int Map::_internal_link_map_size() const {
  return _impl_.link_map_.size();
}
inline int Map::link_map_size() const {
  return _internal_link_map_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >&
Map::_internal_link_map() const {
  return _impl_.link_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >&
Map::link_map() const {
  // @@protoc_insertion_point(field_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.link_map)
  return _internal_link_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >*
Map::_internal_mutable_link_map() {
  return _impl_.link_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link >*
Map::mutable_link_map() {
  // @@protoc_insertion_point(field_mutable_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.link_map)
  return _internal_mutable_link_map();
}

// map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane> lane_map = 4;
inline int Map::_internal_lane_map_size() const {
  return _impl_.lane_map_.size();
}
inline int Map::lane_map_size() const {
  return _internal_lane_map_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >&
Map::_internal_lane_map() const {
  return _impl_.lane_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >&
Map::lane_map() const {
  // @@protoc_insertion_point(field_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.lane_map)
  return _internal_lane_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >*
Map::_internal_mutable_lane_map() {
  return _impl_.lane_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane >*
Map::mutable_lane_map() {
  // @@protoc_insertion_point(field_mutable_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.lane_map)
  return _internal_mutable_lane_map();
}

// map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Crosswalk> crosswalk_map = 5;
inline int Map::_internal_crosswalk_map_size() const {
  return _impl_.crosswalk_map_.size();
}
inline int Map::crosswalk_map_size() const {
  return _internal_crosswalk_map_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >&
Map::_internal_crosswalk_map() const {
  return _impl_.crosswalk_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >&
Map::crosswalk_map() const {
  // @@protoc_insertion_point(field_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.crosswalk_map)
  return _internal_crosswalk_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >*
Map::_internal_mutable_crosswalk_map() {
  return _impl_.crosswalk_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Crosswalk >*
Map::mutable_crosswalk_map() {
  // @@protoc_insertion_point(field_mutable_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.crosswalk_map)
  return _internal_mutable_crosswalk_map();
}

// map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Stopline> stop_line_map = 6;
inline int Map::_internal_stop_line_map_size() const {
  return _impl_.stop_line_map_.size();
}
inline int Map::stop_line_map_size() const {
  return _internal_stop_line_map_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >&
Map::_internal_stop_line_map() const {
  return _impl_.stop_line_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >&
Map::stop_line_map() const {
  // @@protoc_insertion_point(field_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.stop_line_map)
  return _internal_stop_line_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >*
Map::_internal_mutable_stop_line_map() {
  return _impl_.stop_line_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Stopline >*
Map::mutable_stop_line_map() {
  // @@protoc_insertion_point(field_mutable_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map.stop_line_map)
  return _internal_mutable_stop_line_map();
}

// -------------------------------------------------------------------

// StartSimulationReq

// string map_id = 1;
inline void StartSimulationReq::clear_map_id() {
  _impl_.map_id_.ClearToEmpty();
}
inline const std::string& StartSimulationReq::map_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.map_id)
  return _internal_map_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartSimulationReq::set_map_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.map_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.map_id)
}
inline std::string* StartSimulationReq::mutable_map_id() {
  std::string* _s = _internal_mutable_map_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.map_id)
  return _s;
}
inline const std::string& StartSimulationReq::_internal_map_id() const {
  return _impl_.map_id_.Get();
}
inline void StartSimulationReq::_internal_set_map_id(const std::string& value) {
  
  _impl_.map_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StartSimulationReq::_internal_mutable_map_id() {
  
  return _impl_.map_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StartSimulationReq::release_map_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.map_id)
  return _impl_.map_id_.Release();
}
inline void StartSimulationReq::set_allocated_map_id(std::string* map_id) {
  if (map_id != nullptr) {
    
  } else {
    
  }
  _impl_.map_id_.SetAllocated(map_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_id_.IsDefault()) {
    _impl_.map_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.map_id)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position origin = 2;
inline bool StartSimulationReq::_internal_has_origin() const {
  return this != internal_default_instance() && _impl_.origin_ != nullptr;
}
inline bool StartSimulationReq::has_origin() const {
  return _internal_has_origin();
}
inline void StartSimulationReq::clear_origin() {
  if (GetArenaForAllocation() == nullptr && _impl_.origin_ != nullptr) {
    delete _impl_.origin_;
  }
  _impl_.origin_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& StartSimulationReq::_internal_origin() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* p = _impl_.origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Position_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& StartSimulationReq::origin() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.origin)
  return _internal_origin();
}
inline void StartSimulationReq::unsafe_arena_set_allocated_origin(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* origin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_);
  }
  _impl_.origin_ = origin;
  if (origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.origin)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* StartSimulationReq::release_origin() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* StartSimulationReq::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.origin)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* StartSimulationReq::_internal_mutable_origin() {
  
  if (_impl_.origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position>(GetArenaForAllocation());
    _impl_.origin_ = p;
  }
  return _impl_.origin_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* StartSimulationReq::mutable_origin() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.origin)
  return _msg;
}
inline void StartSimulationReq::set_allocated_origin(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(origin);
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.origin)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Position destination = 3;
inline bool StartSimulationReq::_internal_has_destination() const {
  return this != internal_default_instance() && _impl_.destination_ != nullptr;
}
inline bool StartSimulationReq::has_destination() const {
  return _internal_has_destination();
}
inline void StartSimulationReq::clear_destination() {
  if (GetArenaForAllocation() == nullptr && _impl_.destination_ != nullptr) {
    delete _impl_.destination_;
  }
  _impl_.destination_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& StartSimulationReq::_internal_destination() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* p = _impl_.destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Position_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position& StartSimulationReq::destination() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.destination)
  return _internal_destination();
}
inline void StartSimulationReq::unsafe_arena_set_allocated_destination(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* destination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destination_);
  }
  _impl_.destination_ = destination;
  if (destination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.destination)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* StartSimulationReq::release_destination() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* StartSimulationReq::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.destination)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* StartSimulationReq::_internal_mutable_destination() {
  
  if (_impl_.destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position>(GetArenaForAllocation());
    _impl_.destination_ = p;
  }
  return _impl_.destination_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* StartSimulationReq::mutable_destination() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.destination)
  return _msg;
}
inline void StartSimulationReq::set_allocated_destination(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Position* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.destination_;
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(destination);
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationReq.destination)
}

// -------------------------------------------------------------------

// StartSimulationRes

// string simulation_id = 1;
inline void StartSimulationRes::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& StartSimulationRes::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartSimulationRes::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.simulation_id)
}
inline std::string* StartSimulationRes::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.simulation_id)
  return _s;
}
inline const std::string& StartSimulationRes::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void StartSimulationRes::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StartSimulationRes::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StartSimulationRes::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void StartSimulationRes::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.simulation_id)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 2;
inline bool StartSimulationRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool StartSimulationRes::has_error() const {
  return _internal_has_error();
}
inline void StartSimulationRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& StartSimulationRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& StartSimulationRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.error)
  return _internal_error();
}
inline void StartSimulationRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* StartSimulationRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* StartSimulationRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* StartSimulationRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* StartSimulationRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.error)
  return _msg;
}
inline void StartSimulationRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StartSimulationRes.error)
}

// -------------------------------------------------------------------

// NextStepReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void NextStepReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& NextStepReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NextStepReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepReq.simulation_id)
}
inline std::string* NextStepReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepReq.simulation_id)
  return _s;
}
inline const std::string& NextStepReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void NextStepReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NextStepReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NextStepReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void NextStepReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepReq.simulation_id)
}

// -------------------------------------------------------------------

// SimulationState

// int32 progress = 1;
inline void SimulationState::clear_progress() {
  _impl_.progress_ = 0;
}
inline int32_t SimulationState::_internal_progress() const {
  return _impl_.progress_;
}
inline int32_t SimulationState::progress() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState.progress)
  return _internal_progress();
}
inline void SimulationState::_internal_set_progress(int32_t value) {
  
  _impl_.progress_ = value;
}
inline void SimulationState::set_progress(int32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState.progress)
}

// string msg = 2;
inline void SimulationState::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SimulationState::msg() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SimulationState::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState.msg)
}
inline std::string* SimulationState::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState.msg)
  return _s;
}
inline const std::string& SimulationState::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void SimulationState::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SimulationState::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* SimulationState::release_msg() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState.msg)
  return _impl_.msg_.Release();
}
inline void SimulationState::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState.msg)
}

// -------------------------------------------------------------------

// NextStepRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState state = 1;
inline bool NextStepRes::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool NextStepRes::has_state() const {
  return _internal_has_state();
}
inline void NextStepRes::clear_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState& NextStepRes::_internal_state() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_SimulationState_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState& NextStepRes::state() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.state)
  return _internal_state();
}
inline void NextStepRes::unsafe_arena_set_allocated_state(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.state)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* NextStepRes::release_state() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* NextStepRes::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.state)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* NextStepRes::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* NextStepRes::mutable_state() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.state)
  return _msg;
}
inline void NextStepRes::set_allocated_state(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.state)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 2;
inline bool NextStepRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool NextStepRes::has_error() const {
  return _internal_has_error();
}
inline void NextStepRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& NextStepRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& NextStepRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.error)
  return _internal_error();
}
inline void NextStepRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* NextStepRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* NextStepRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* NextStepRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* NextStepRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.error)
  return _msg;
}
inline void NextStepRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.NextStepRes.error)
}

// -------------------------------------------------------------------

// ResetSimulationReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void ResetSimulationReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& ResetSimulationReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetSimulationReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationReq.simulation_id)
}
inline std::string* ResetSimulationReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationReq.simulation_id)
  return _s;
}
inline const std::string& ResetSimulationReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void ResetSimulationReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResetSimulationReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResetSimulationReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void ResetSimulationReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationReq.simulation_id)
}

// -------------------------------------------------------------------

// ResetSimulationRes

// string simulation_id = 1;
inline void ResetSimulationRes::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& ResetSimulationRes::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetSimulationRes::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.simulation_id)
}
inline std::string* ResetSimulationRes::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.simulation_id)
  return _s;
}
inline const std::string& ResetSimulationRes::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void ResetSimulationRes::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResetSimulationRes::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResetSimulationRes::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void ResetSimulationRes::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.simulation_id)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 2;
inline bool ResetSimulationRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool ResetSimulationRes::has_error() const {
  return _internal_has_error();
}
inline void ResetSimulationRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& ResetSimulationRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& ResetSimulationRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.error)
  return _internal_error();
}
inline void ResetSimulationRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* ResetSimulationRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* ResetSimulationRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* ResetSimulationRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* ResetSimulationRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.error)
  return _msg;
}
inline void ResetSimulationRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ResetSimulationRes.error)
}

// -------------------------------------------------------------------

// StopSimulationReq

// string simulation_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void StopSimulationReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& StopSimulationReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopSimulationReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationReq.simulation_id)
}
inline std::string* StopSimulationReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationReq.simulation_id)
  return _s;
}
inline const std::string& StopSimulationReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void StopSimulationReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopSimulationReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopSimulationReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void StopSimulationReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationReq.simulation_id)
}

// -------------------------------------------------------------------

// StopSimulationRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SimulationState state = 1;
inline bool StopSimulationRes::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool StopSimulationRes::has_state() const {
  return _internal_has_state();
}
inline void StopSimulationRes::clear_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState& StopSimulationRes::_internal_state() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_SimulationState_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState& StopSimulationRes::state() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.state)
  return _internal_state();
}
inline void StopSimulationRes::unsafe_arena_set_allocated_state(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.state)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* StopSimulationRes::release_state() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* StopSimulationRes::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.state)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* StopSimulationRes::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* StopSimulationRes::mutable_state() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.state)
  return _msg;
}
inline void StopSimulationRes::set_allocated_state(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::SimulationState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.state)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 2;
inline bool StopSimulationRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool StopSimulationRes::has_error() const {
  return _internal_has_error();
}
inline void StopSimulationRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& StopSimulationRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& StopSimulationRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.error)
  return _internal_error();
}
inline void StopSimulationRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* StopSimulationRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* StopSimulationRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* StopSimulationRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* StopSimulationRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.error)
  return _msg;
}
inline void StopSimulationRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.StopSimulationRes.error)
}

// -------------------------------------------------------------------

// GetMapReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetMapReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& GetMapReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMapReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapReq.simulation_id)
}
inline std::string* GetMapReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapReq.simulation_id)
  return _s;
}
inline const std::string& GetMapReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void GetMapReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMapReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMapReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void GetMapReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapReq.simulation_id)
}

// -------------------------------------------------------------------

// GetMapRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
inline bool GetMapRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetMapRes::has_error() const {
  return _internal_has_error();
}
inline void GetMapRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetMapRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetMapRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.error)
  return _internal_error();
}
inline void GetMapRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetMapRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetMapRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetMapRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetMapRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.error)
  return _msg;
}
inline void GetMapRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.error)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Map map = 2;
inline bool GetMapRes::_internal_has_map() const {
  return this != internal_default_instance() && _impl_.map_ != nullptr;
}
inline bool GetMapRes::has_map() const {
  return _internal_has_map();
}
inline void GetMapRes::clear_map() {
  if (GetArenaForAllocation() == nullptr && _impl_.map_ != nullptr) {
    delete _impl_.map_;
  }
  _impl_.map_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map& GetMapRes::_internal_map() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* p = _impl_.map_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Map_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map& GetMapRes::map() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.map)
  return _internal_map();
}
inline void GetMapRes::unsafe_arena_set_allocated_map(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_);
  }
  _impl_.map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.map)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* GetMapRes::release_map() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* temp = _impl_.map_;
  _impl_.map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* GetMapRes::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.map)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* temp = _impl_.map_;
  _impl_.map_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* GetMapRes::_internal_mutable_map() {
  
  if (_impl_.map_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map>(GetArenaForAllocation());
    _impl_.map_ = p;
  }
  return _impl_.map_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* GetMapRes::mutable_map() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.map)
  return _msg;
}
inline void GetMapRes::set_allocated_map(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Map* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.map_;
  }
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.map_ = map;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetMapRes.map)
}

// -------------------------------------------------------------------

// GetAllTrafficPartReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetAllTrafficPartReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& GetAllTrafficPartReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllTrafficPartReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartReq.simulation_id)
}
inline std::string* GetAllTrafficPartReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartReq.simulation_id)
  return _s;
}
inline const std::string& GetAllTrafficPartReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void GetAllTrafficPartReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllTrafficPartReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllTrafficPartReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void GetAllTrafficPartReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartReq.simulation_id)
}

// -------------------------------------------------------------------

// GetAllTrafficPartRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
inline bool GetAllTrafficPartRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetAllTrafficPartRes::has_error() const {
  return _internal_has_error();
}
inline void GetAllTrafficPartRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetAllTrafficPartRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetAllTrafficPartRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.error)
  return _internal_error();
}
inline void GetAllTrafficPartRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetAllTrafficPartRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetAllTrafficPartRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetAllTrafficPartRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetAllTrafficPartRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.error)
  return _msg;
}
inline void GetAllTrafficPartRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.error)
}

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.MovingObj list = 2;
inline int GetAllTrafficPartRes::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetAllTrafficPartRes::list_size() const {
  return _internal_list_size();
}
inline void GetAllTrafficPartRes::clear_list() {
  _impl_.list_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* GetAllTrafficPartRes::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj >*
GetAllTrafficPartRes::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.list)
  return &_impl_.list_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& GetAllTrafficPartRes::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj& GetAllTrafficPartRes::list(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.list)
  return _internal_list(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* GetAllTrafficPartRes::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* GetAllTrafficPartRes::add_list() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::MovingObj >&
GetAllTrafficPartRes::list() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetAllTrafficPartRes.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// SetVehicleControlReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void SetVehicleControlReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& SetVehicleControlReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetVehicleControlReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.simulation_id)
}
inline std::string* SetVehicleControlReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.simulation_id)
  return _s;
}
inline const std::string& SetVehicleControlReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void SetVehicleControlReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetVehicleControlReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetVehicleControlReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void SetVehicleControlReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.simulation_id)
}

// string vehicle_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void SetVehicleControlReq::clear_vehicle_id() {
  _impl_.vehicle_id_.ClearToEmpty();
}
inline const std::string& SetVehicleControlReq::vehicle_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.vehicle_id)
  return _internal_vehicle_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetVehicleControlReq::set_vehicle_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vehicle_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.vehicle_id)
}
inline std::string* SetVehicleControlReq::mutable_vehicle_id() {
  std::string* _s = _internal_mutable_vehicle_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.vehicle_id)
  return _s;
}
inline const std::string& SetVehicleControlReq::_internal_vehicle_id() const {
  return _impl_.vehicle_id_.Get();
}
inline void SetVehicleControlReq::_internal_set_vehicle_id(const std::string& value) {
  
  _impl_.vehicle_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetVehicleControlReq::_internal_mutable_vehicle_id() {
  
  return _impl_.vehicle_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetVehicleControlReq::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.vehicle_id)
  return _impl_.vehicle_id_.Release();
}
inline void SetVehicleControlReq::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  _impl_.vehicle_id_.SetAllocated(vehicle_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vehicle_id_.IsDefault()) {
    _impl_.vehicle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.vehicle_id)
}

// double lon_acc = 3;
inline void SetVehicleControlReq::clear_lon_acc() {
  _impl_.lon_acc_ = 0;
}
inline double SetVehicleControlReq::_internal_lon_acc() const {
  return _impl_.lon_acc_;
}
inline double SetVehicleControlReq::lon_acc() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.lon_acc)
  return _internal_lon_acc();
}
inline void SetVehicleControlReq::_internal_set_lon_acc(double value) {
  
  _impl_.lon_acc_ = value;
}
inline void SetVehicleControlReq::set_lon_acc(double value) {
  _internal_set_lon_acc(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.lon_acc)
}

// double ste_wheel = 4;
inline void SetVehicleControlReq::clear_ste_wheel() {
  _impl_.ste_wheel_ = 0;
}
inline double SetVehicleControlReq::_internal_ste_wheel() const {
  return _impl_.ste_wheel_;
}
inline double SetVehicleControlReq::ste_wheel() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.ste_wheel)
  return _internal_ste_wheel();
}
inline void SetVehicleControlReq::_internal_set_ste_wheel(double value) {
  
  _impl_.ste_wheel_ = value;
}
inline void SetVehicleControlReq::set_ste_wheel(double value) {
  _internal_set_ste_wheel(value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlReq.ste_wheel)
}

// -------------------------------------------------------------------

// SetVehicleControlRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
inline bool SetVehicleControlRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool SetVehicleControlRes::has_error() const {
  return _internal_has_error();
}
inline void SetVehicleControlRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& SetVehicleControlRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& SetVehicleControlRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.error)
  return _internal_error();
}
inline void SetVehicleControlRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* SetVehicleControlRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* SetVehicleControlRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* SetVehicleControlRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* SetVehicleControlRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.error)
  return _msg;
}
inline void SetVehicleControlRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.error)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle vehicle = 2;
inline bool SetVehicleControlRes::_internal_has_vehicle() const {
  return this != internal_default_instance() && _impl_.vehicle_ != nullptr;
}
inline bool SetVehicleControlRes::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void SetVehicleControlRes::clear_vehicle() {
  if (GetArenaForAllocation() == nullptr && _impl_.vehicle_ != nullptr) {
    delete _impl_.vehicle_;
  }
  _impl_.vehicle_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle& SetVehicleControlRes::_internal_vehicle() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Vehicle_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle& SetVehicleControlRes::vehicle() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.vehicle)
  return _internal_vehicle();
}
inline void SetVehicleControlRes::unsafe_arena_set_allocated_vehicle(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.vehicle)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* SetVehicleControlRes::release_vehicle() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* SetVehicleControlRes::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.vehicle)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* SetVehicleControlRes::_internal_mutable_vehicle() {
  
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* SetVehicleControlRes::mutable_vehicle() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.vehicle)
  return _msg;
}
inline void SetVehicleControlRes::set_allocated_vehicle(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.SetVehicleControlRes.vehicle)
}

// -------------------------------------------------------------------

// GetVehicleReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetVehicleReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& GetVehicleReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVehicleReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.simulation_id)
}
inline std::string* GetVehicleReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.simulation_id)
  return _s;
}
inline const std::string& GetVehicleReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void GetVehicleReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetVehicleReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetVehicleReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void GetVehicleReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.simulation_id)
}

// string vehicle_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void GetVehicleReq::clear_vehicle_id() {
  _impl_.vehicle_id_.ClearToEmpty();
}
inline const std::string& GetVehicleReq::vehicle_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.vehicle_id)
  return _internal_vehicle_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVehicleReq::set_vehicle_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vehicle_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.vehicle_id)
}
inline std::string* GetVehicleReq::mutable_vehicle_id() {
  std::string* _s = _internal_mutable_vehicle_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.vehicle_id)
  return _s;
}
inline const std::string& GetVehicleReq::_internal_vehicle_id() const {
  return _impl_.vehicle_id_.Get();
}
inline void GetVehicleReq::_internal_set_vehicle_id(const std::string& value) {
  
  _impl_.vehicle_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetVehicleReq::_internal_mutable_vehicle_id() {
  
  return _impl_.vehicle_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetVehicleReq::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.vehicle_id)
  return _impl_.vehicle_id_.Release();
}
inline void GetVehicleReq::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  _impl_.vehicle_id_.SetAllocated(vehicle_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vehicle_id_.IsDefault()) {
    _impl_.vehicle_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleReq.vehicle_id)
}

// -------------------------------------------------------------------

// GetVehicleRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
inline bool GetVehicleRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetVehicleRes::has_error() const {
  return _internal_has_error();
}
inline void GetVehicleRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetVehicleRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetVehicleRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.error)
  return _internal_error();
}
inline void GetVehicleRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetVehicleRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetVehicleRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetVehicleRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetVehicleRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.error)
  return _msg;
}
inline void GetVehicleRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.error)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Vehicle vehicle = 2;
inline bool GetVehicleRes::_internal_has_vehicle() const {
  return this != internal_default_instance() && _impl_.vehicle_ != nullptr;
}
inline bool GetVehicleRes::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void GetVehicleRes::clear_vehicle() {
  if (GetArenaForAllocation() == nullptr && _impl_.vehicle_ != nullptr) {
    delete _impl_.vehicle_;
  }
  _impl_.vehicle_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle& GetVehicleRes::_internal_vehicle() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Vehicle_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle& GetVehicleRes::vehicle() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.vehicle)
  return _internal_vehicle();
}
inline void GetVehicleRes::unsafe_arena_set_allocated_vehicle(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.vehicle)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* GetVehicleRes::release_vehicle() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* GetVehicleRes::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.vehicle)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* GetVehicleRes::_internal_mutable_vehicle() {
  
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* GetVehicleRes::mutable_vehicle() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.vehicle)
  return _msg;
}
inline void GetVehicleRes::set_allocated_vehicle(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Vehicle* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetVehicleRes.vehicle)
}

// -------------------------------------------------------------------

// GetResultsReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetResultsReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& GetResultsReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResultsReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsReq.simulation_id)
}
inline std::string* GetResultsReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsReq.simulation_id)
  return _s;
}
inline const std::string& GetResultsReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void GetResultsReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResultsReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResultsReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void GetResultsReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsReq.simulation_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetResultsRes_item

// repeated double r = 1;
inline int GetResultsRes_item::_internal_r_size() const {
  return _impl_.r_.size();
}
inline int GetResultsRes_item::r_size() const {
  return _internal_r_size();
}
inline void GetResultsRes_item::clear_r() {
  _impl_.r_.Clear();
}
inline double GetResultsRes_item::_internal_r(int index) const {
  return _impl_.r_.Get(index);
}
inline double GetResultsRes_item::r(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item.r)
  return _internal_r(index);
}
inline void GetResultsRes_item::set_r(int index, double value) {
  _impl_.r_.Set(index, value);
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item.r)
}
inline void GetResultsRes_item::_internal_add_r(double value) {
  _impl_.r_.Add(value);
}
inline void GetResultsRes_item::add_r(double value) {
  _internal_add_r(value);
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item.r)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GetResultsRes_item::_internal_r() const {
  return _impl_.r_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
GetResultsRes_item::r() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item.r)
  return _internal_r();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GetResultsRes_item::_internal_mutable_r() {
  return &_impl_.r_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
GetResultsRes_item::mutable_r() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item.r)
  return _internal_mutable_r();
}

// -------------------------------------------------------------------

// GetResultsRes_arrays

// repeated .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.item arr = 1;
inline int GetResultsRes_arrays::_internal_arr_size() const {
  return _impl_.arr_.size();
}
inline int GetResultsRes_arrays::arr_size() const {
  return _internal_arr_size();
}
inline void GetResultsRes_arrays::clear_arr() {
  _impl_.arr_.Clear();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item* GetResultsRes_arrays::mutable_arr(int index) {
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays.arr)
  return _impl_.arr_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item >*
GetResultsRes_arrays::mutable_arr() {
  // @@protoc_insertion_point(field_mutable_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays.arr)
  return &_impl_.arr_;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item& GetResultsRes_arrays::_internal_arr(int index) const {
  return _impl_.arr_.Get(index);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item& GetResultsRes_arrays::arr(int index) const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays.arr)
  return _internal_arr(index);
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item* GetResultsRes_arrays::_internal_add_arr() {
  return _impl_.arr_.Add();
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item* GetResultsRes_arrays::add_arr() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item* _add = _internal_add_arr();
  // @@protoc_insertion_point(field_add:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays.arr)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_item >&
GetResultsRes_arrays::arr() const {
  // @@protoc_insertion_point(field_list:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays.arr)
  return _impl_.arr_;
}

// -------------------------------------------------------------------

// GetResultsRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
inline bool GetResultsRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetResultsRes::has_error() const {
  return _internal_has_error();
}
inline void GetResultsRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetResultsRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetResultsRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.error)
  return _internal_error();
}
inline void GetResultsRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetResultsRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetResultsRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetResultsRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetResultsRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.error)
  return _msg;
}
inline void GetResultsRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.error)
}

// map<string, .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.arrays> results = 2;
inline int GetResultsRes::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int GetResultsRes::results_size() const {
  return _internal_results_size();
}
inline void GetResultsRes::clear_results() {
  _impl_.results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays >&
GetResultsRes::_internal_results() const {
  return _impl_.results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays >&
GetResultsRes::results() const {
  // @@protoc_insertion_point(field_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.results)
  return _internal_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays >*
GetResultsRes::_internal_mutable_results() {
  return _impl_.results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::GetResultsRes_arrays >*
GetResultsRes::mutable_results() {
  // @@protoc_insertion_point(field_mutable_map:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetResultsRes.results)
  return _internal_mutable_results();
}

// -------------------------------------------------------------------

// GetLinkReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetLinkReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& GetLinkReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLinkReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.simulation_id)
}
inline std::string* GetLinkReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.simulation_id)
  return _s;
}
inline const std::string& GetLinkReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void GetLinkReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLinkReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLinkReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void GetLinkReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.simulation_id)
}

// string link_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void GetLinkReq::clear_link_id() {
  _impl_.link_id_.ClearToEmpty();
}
inline const std::string& GetLinkReq::link_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.link_id)
  return _internal_link_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLinkReq::set_link_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.link_id)
}
inline std::string* GetLinkReq::mutable_link_id() {
  std::string* _s = _internal_mutable_link_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.link_id)
  return _s;
}
inline const std::string& GetLinkReq::_internal_link_id() const {
  return _impl_.link_id_.Get();
}
inline void GetLinkReq::_internal_set_link_id(const std::string& value) {
  
  _impl_.link_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLinkReq::_internal_mutable_link_id() {
  
  return _impl_.link_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLinkReq::release_link_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.link_id)
  return _impl_.link_id_.Release();
}
inline void GetLinkReq::set_allocated_link_id(std::string* link_id) {
  if (link_id != nullptr) {
    
  } else {
    
  }
  _impl_.link_id_.SetAllocated(link_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_id_.IsDefault()) {
    _impl_.link_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkReq.link_id)
}

// -------------------------------------------------------------------

// GetLinkRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
inline bool GetLinkRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetLinkRes::has_error() const {
  return _internal_has_error();
}
inline void GetLinkRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetLinkRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetLinkRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.error)
  return _internal_error();
}
inline void GetLinkRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetLinkRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetLinkRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetLinkRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetLinkRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.error)
  return _msg;
}
inline void GetLinkRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.error)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Link link = 2;
inline bool GetLinkRes::_internal_has_link() const {
  return this != internal_default_instance() && _impl_.link_ != nullptr;
}
inline bool GetLinkRes::has_link() const {
  return _internal_has_link();
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link& GetLinkRes::_internal_link() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* p = _impl_.link_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Link_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link& GetLinkRes::link() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.link)
  return _internal_link();
}
inline void GetLinkRes::unsafe_arena_set_allocated_link(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* link) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_);
  }
  _impl_.link_ = link;
  if (link) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.link)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* GetLinkRes::release_link() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* GetLinkRes::unsafe_arena_release_link() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.link)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* GetLinkRes::_internal_mutable_link() {
  
  if (_impl_.link_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link>(GetArenaForAllocation());
    _impl_.link_ = p;
  }
  return _impl_.link_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* GetLinkRes::mutable_link() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* _msg = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.link)
  return _msg;
}
inline void GetLinkRes::set_allocated_link(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Link* link) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_);
  }
  if (link) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link));
    if (message_arena != submessage_arena) {
      link = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.link_ = link;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLinkRes.link)
}

// -------------------------------------------------------------------

// GetLaneReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetLaneReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& GetLaneReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLaneReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.simulation_id)
}
inline std::string* GetLaneReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.simulation_id)
  return _s;
}
inline const std::string& GetLaneReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void GetLaneReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLaneReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLaneReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void GetLaneReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.simulation_id)
}

// string lane_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void GetLaneReq::clear_lane_id() {
  _impl_.lane_id_.ClearToEmpty();
}
inline const std::string& GetLaneReq::lane_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.lane_id)
  return _internal_lane_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLaneReq::set_lane_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lane_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.lane_id)
}
inline std::string* GetLaneReq::mutable_lane_id() {
  std::string* _s = _internal_mutable_lane_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.lane_id)
  return _s;
}
inline const std::string& GetLaneReq::_internal_lane_id() const {
  return _impl_.lane_id_.Get();
}
inline void GetLaneReq::_internal_set_lane_id(const std::string& value) {
  
  _impl_.lane_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLaneReq::_internal_mutable_lane_id() {
  
  return _impl_.lane_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLaneReq::release_lane_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.lane_id)
  return _impl_.lane_id_.Release();
}
inline void GetLaneReq::set_allocated_lane_id(std::string* lane_id) {
  if (lane_id != nullptr) {
    
  } else {
    
  }
  _impl_.lane_id_.SetAllocated(lane_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lane_id_.IsDefault()) {
    _impl_.lane_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneReq.lane_id)
}

// -------------------------------------------------------------------

// GetLaneRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
inline bool GetLaneRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetLaneRes::has_error() const {
  return _internal_has_error();
}
inline void GetLaneRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetLaneRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetLaneRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.error)
  return _internal_error();
}
inline void GetLaneRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetLaneRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetLaneRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetLaneRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetLaneRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.error)
  return _msg;
}
inline void GetLaneRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.error)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Lane lane = 2;
inline bool GetLaneRes::_internal_has_lane() const {
  return this != internal_default_instance() && _impl_.lane_ != nullptr;
}
inline bool GetLaneRes::has_lane() const {
  return _internal_has_lane();
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane& GetLaneRes::_internal_lane() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* p = _impl_.lane_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Lane_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane& GetLaneRes::lane() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.lane)
  return _internal_lane();
}
inline void GetLaneRes::unsafe_arena_set_allocated_lane(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* lane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lane_);
  }
  _impl_.lane_ = lane;
  if (lane) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.lane)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* GetLaneRes::release_lane() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* temp = _impl_.lane_;
  _impl_.lane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* GetLaneRes::unsafe_arena_release_lane() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.lane)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* temp = _impl_.lane_;
  _impl_.lane_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* GetLaneRes::_internal_mutable_lane() {
  
  if (_impl_.lane_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane>(GetArenaForAllocation());
    _impl_.lane_ = p;
  }
  return _impl_.lane_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* GetLaneRes::mutable_lane() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* _msg = _internal_mutable_lane();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.lane)
  return _msg;
}
inline void GetLaneRes::set_allocated_lane(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Lane* lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lane_);
  }
  if (lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lane));
    if (message_arena != submessage_arena) {
      lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lane, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lane_ = lane;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetLaneRes.lane)
}

// -------------------------------------------------------------------

// GetJunctionReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetJunctionReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& GetJunctionReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetJunctionReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.simulation_id)
}
inline std::string* GetJunctionReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.simulation_id)
  return _s;
}
inline const std::string& GetJunctionReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void GetJunctionReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetJunctionReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetJunctionReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void GetJunctionReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.simulation_id)
}

// string junction_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void GetJunctionReq::clear_junction_id() {
  _impl_.junction_id_.ClearToEmpty();
}
inline const std::string& GetJunctionReq::junction_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.junction_id)
  return _internal_junction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetJunctionReq::set_junction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.junction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.junction_id)
}
inline std::string* GetJunctionReq::mutable_junction_id() {
  std::string* _s = _internal_mutable_junction_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.junction_id)
  return _s;
}
inline const std::string& GetJunctionReq::_internal_junction_id() const {
  return _impl_.junction_id_.Get();
}
inline void GetJunctionReq::_internal_set_junction_id(const std::string& value) {
  
  _impl_.junction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetJunctionReq::_internal_mutable_junction_id() {
  
  return _impl_.junction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetJunctionReq::release_junction_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.junction_id)
  return _impl_.junction_id_.Release();
}
inline void GetJunctionReq::set_allocated_junction_id(std::string* junction_id) {
  if (junction_id != nullptr) {
    
  } else {
    
  }
  _impl_.junction_id_.SetAllocated(junction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.junction_id_.IsDefault()) {
    _impl_.junction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionReq.junction_id)
}

// -------------------------------------------------------------------

// GetJunctionRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
inline bool GetJunctionRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetJunctionRes::has_error() const {
  return _internal_has_error();
}
inline void GetJunctionRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetJunctionRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetJunctionRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.error)
  return _internal_error();
}
inline void GetJunctionRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetJunctionRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetJunctionRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetJunctionRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetJunctionRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.error)
  return _msg;
}
inline void GetJunctionRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.error)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Junction junction = 2;
inline bool GetJunctionRes::_internal_has_junction() const {
  return this != internal_default_instance() && _impl_.junction_ != nullptr;
}
inline bool GetJunctionRes::has_junction() const {
  return _internal_has_junction();
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction& GetJunctionRes::_internal_junction() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* p = _impl_.junction_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Junction_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction& GetJunctionRes::junction() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.junction)
  return _internal_junction();
}
inline void GetJunctionRes::unsafe_arena_set_allocated_junction(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* junction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.junction_);
  }
  _impl_.junction_ = junction;
  if (junction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.junction)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* GetJunctionRes::release_junction() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* temp = _impl_.junction_;
  _impl_.junction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* GetJunctionRes::unsafe_arena_release_junction() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.junction)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* temp = _impl_.junction_;
  _impl_.junction_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* GetJunctionRes::_internal_mutable_junction() {
  
  if (_impl_.junction_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction>(GetArenaForAllocation());
    _impl_.junction_ = p;
  }
  return _impl_.junction_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* GetJunctionRes::mutable_junction() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* _msg = _internal_mutable_junction();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.junction)
  return _msg;
}
inline void GetJunctionRes::set_allocated_junction(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Junction* junction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.junction_);
  }
  if (junction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(junction));
    if (message_arena != submessage_arena) {
      junction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, junction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.junction_ = junction;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetJunctionRes.junction)
}

// -------------------------------------------------------------------

// GetSegmentReq

// string simulation_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GetSegmentReq::clear_simulation_id() {
  _impl_.simulation_id_.ClearToEmpty();
}
inline const std::string& GetSegmentReq::simulation_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.simulation_id)
  return _internal_simulation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSegmentReq::set_simulation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.simulation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.simulation_id)
}
inline std::string* GetSegmentReq::mutable_simulation_id() {
  std::string* _s = _internal_mutable_simulation_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.simulation_id)
  return _s;
}
inline const std::string& GetSegmentReq::_internal_simulation_id() const {
  return _impl_.simulation_id_.Get();
}
inline void GetSegmentReq::_internal_set_simulation_id(const std::string& value) {
  
  _impl_.simulation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSegmentReq::_internal_mutable_simulation_id() {
  
  return _impl_.simulation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSegmentReq::release_simulation_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.simulation_id)
  return _impl_.simulation_id_.Release();
}
inline void GetSegmentReq::set_allocated_simulation_id(std::string* simulation_id) {
  if (simulation_id != nullptr) {
    
  } else {
    
  }
  _impl_.simulation_id_.SetAllocated(simulation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.simulation_id_.IsDefault()) {
    _impl_.simulation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.simulation_id)
}

// string segment_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void GetSegmentReq::clear_segment_id() {
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& GetSegmentReq::segment_id() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.segment_id)
  return _internal_segment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSegmentReq::set_segment_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.segment_id)
}
inline std::string* GetSegmentReq::mutable_segment_id() {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.segment_id)
  return _s;
}
inline const std::string& GetSegmentReq::_internal_segment_id() const {
  return _impl_.segment_id_.Get();
}
inline void GetSegmentReq::_internal_set_segment_id(const std::string& value) {
  
  _impl_.segment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSegmentReq::_internal_mutable_segment_id() {
  
  return _impl_.segment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSegmentReq::release_segment_id() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.segment_id)
  return _impl_.segment_id_.Release();
}
inline void GetSegmentReq::set_allocated_segment_id(std::string* segment_id) {
  if (segment_id != nullptr) {
    
  } else {
    
  }
  _impl_.segment_id_.SetAllocated(segment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentReq.segment_id)
}

// -------------------------------------------------------------------

// GetSegmentRes

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.ErrorMsg error = 1;
inline bool GetSegmentRes::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetSegmentRes::has_error() const {
  return _internal_has_error();
}
inline void GetSegmentRes::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetSegmentRes::_internal_error() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_ErrorMsg_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg& GetSegmentRes::error() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.error)
  return _internal_error();
}
inline void GetSegmentRes::unsafe_arena_set_allocated_error(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.error)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetSegmentRes::release_error() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetSegmentRes::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.error)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetSegmentRes::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* GetSegmentRes::mutable_error() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.error)
  return _msg;
}
inline void GetSegmentRes::set_allocated_error(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.error)
}

// .risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.Segment segment = 2;
inline bool GetSegmentRes::_internal_has_segment() const {
  return this != internal_default_instance() && _impl_.segment_ != nullptr;
}
inline bool GetSegmentRes::has_segment() const {
  return _internal_has_segment();
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment& GetSegmentRes::_internal_segment() const {
  const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* p = _impl_.segment_;
  return p != nullptr ? *p : reinterpret_cast<const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment&>(
      ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::_Segment_default_instance_);
}
inline const ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment& GetSegmentRes::segment() const {
  // @@protoc_insertion_point(field_get:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.segment)
  return _internal_segment();
}
inline void GetSegmentRes::unsafe_arena_set_allocated_segment(
    ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* segment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.segment_);
  }
  _impl_.segment_ = segment;
  if (segment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.segment)
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* GetSegmentRes::release_segment() {
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* temp = _impl_.segment_;
  _impl_.segment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* GetSegmentRes::unsafe_arena_release_segment() {
  // @@protoc_insertion_point(field_release:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.segment)
  
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* temp = _impl_.segment_;
  _impl_.segment_ = nullptr;
  return temp;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* GetSegmentRes::_internal_mutable_segment() {
  
  if (_impl_.segment_ == nullptr) {
    auto* p = CreateMaybeMessage<::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment>(GetArenaForAllocation());
    _impl_.segment_ = p;
  }
  return _impl_.segment_;
}
inline ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* GetSegmentRes::mutable_segment() {
  ::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* _msg = _internal_mutable_segment();
  // @@protoc_insertion_point(field_mutable:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.segment)
  return _msg;
}
inline void GetSegmentRes::set_allocated_segment(::risenlighten::lasvsim::simulation_task_kratos::api::simulation::v2::Segment* segment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.segment_);
  }
  if (segment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(segment));
    if (message_arena != submessage_arena) {
      segment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.segment_ = segment;
  // @@protoc_insertion_point(field_set_allocated:risenlighten.lasvsim.simulation_task_kratos.api.simulation.v2.GetSegmentRes.segment)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace simulation
}  // namespace api
}  // namespace simulation_task_kratos
}  // namespace lasvsim
}  // namespace risenlighten

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_risenlighten_2flasvsim_2fsimulation_5ftask_5fkratos_2fapi_2fsimulation_2fv2_2fsimulation_2eproto
